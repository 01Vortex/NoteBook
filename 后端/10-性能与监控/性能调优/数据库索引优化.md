

> 索引是数据库性能优化的核心，合理的索引设计能让查询速度提升几十甚至上百倍
> 本笔记基于 MySQL 8.0+，涵盖索引原理、设计策略、优化实战及常见问题

---

## 目录

1. [索引基础概念](#1-索引基础概念)
2. [索引数据结构](#2-索引数据结构)
3. [索引类型详解](#3-索引类型详解)
4. [索引设计原则](#4-索引设计原则)
5. [EXPLAIN 执行计划](#5-explain-执行计划)
6. [索引优化策略](#6-索引优化策略)
7. [索引失效场景](#7-索引失效场景)
8. [覆盖索引与回表](#8-覆盖索引与回表)
9. [联合索引优化](#9-联合索引优化)
10. [排序与分组优化](#10-排序与分组优化)
11. [分页查询优化](#11-分页查询优化)
12. [索引维护与监控](#12-索引维护与监控)
13. [常见错误与解决方案](#13-常见错误与解决方案)
14. [最佳实践总结](#14-最佳实践总结)

---

## 1. 索引基础概念

### 1.1 什么是索引？

索引就像书的目录，帮助数据库快速定位数据，而不需要扫描整张表。

**没有索引时**：
```
查找"张三"的记录
→ 从第 1 行开始，逐行扫描
→ 扫描 100 万行，找到 1 条记录
→ 耗时：10 秒
```

**有索引时**：
```
查找"张三"的记录
→ 通过索引直接定位
→ 只访问 3-4 个索引节点 + 1 条数据
→ 耗时：0.001 秒
```

### 1.2 索引的代价

索引不是越多越好，它有代价：

| 优点 | 缺点 |
|------|------|
| 加速查询 | 占用磁盘空间 |
| 加速排序 | 降低写入速度（INSERT/UPDATE/DELETE） |
| 加速分组 | 增加优化器选择成本 |
| 保证唯一性 | 维护成本 |

**经验法则**：
- 读多写少的表：多建索引
- 写多读少的表：少建索引
- 单表索引数量建议不超过 5-6 个

### 1.3 索引术语

| 术语 | 说明 |
|------|------|
| 聚簇索引 | 数据和索引存储在一起，InnoDB 主键索引 |
| 二级索引 | 非聚簇索引，叶子节点存储主键值 |
| 回表 | 通过二级索引找到主键，再查聚簇索引获取数据 |
| 覆盖索引 | 索引包含查询所需的所有列，无需回表 |
| 索引下推 | ICP，在存储引擎层过滤数据，减少回表 |
| 最左前缀 | 联合索引从最左列开始匹配 |
| 索引选择性 | 不重复值数量 / 总行数，越高越好 |

---

## 2. 索引数据结构

### 2.1 为什么用 B+ 树？

MySQL InnoDB 使用 B+ 树作为索引结构，而不是二叉树、红黑树或 Hash。

```
对比不同数据结构：

二叉搜索树：
- 问题：可能退化成链表，高度不可控
- 100 万数据，最坏情况高度 100 万

红黑树（平衡二叉树）：
- 问题：高度仍然较高
- 100 万数据，高度约 20 层
- 每层一次磁盘 IO，太慢

B 树：
- 多路平衡树，高度低
- 但数据分布在所有节点，范围查询效率低

B+ 树：
- 数据只在叶子节点
- 叶子节点形成有序链表
- 高度通常 3-4 层
- 范围查询高效
```

### 2.2 B+ 树结构

```
                    ┌─────────────────┐
                    │   [30, 60]      │  ← 根节点（非叶子）
                    └────────┬────────┘
           ┌─────────────────┼─────────────────┐
           ↓                 ↓                 ↓
    ┌──────────┐      ┌──────────┐      ┌──────────┐
    │ [10, 20] │      │ [40, 50] │      │ [70, 80] │  ← 非叶子节点
    └────┬─────┘      └────┬─────┘      └────┬─────┘
    ┌────┼────┐       ┌────┼────┐       ┌────┼────┐
    ↓    ↓    ↓       ↓    ↓    ↓       ↓    ↓    ↓
  ┌───┐┌───┐┌───┐   ┌───┐┌───┐┌───┐   ┌───┐┌───┐┌───┐
  │10 ││20 ││30 │   │40 ││50 ││60 │   │70 ││80 ││90 │  ← 叶子节点
  │...││...││...│   │...││...││...│   │...││...││...│    （存储数据）
  └─┬─┘└─┬─┘└─┬─┘   └─┬─┘└─┬─┘└─┬─┘   └─┬─┘└─┬─┘└───┘
    └────┴────┴───────┴────┴────┴───────┴────┘
              ↑ 叶子节点形成双向链表，支持范围查询
```

### 2.3 InnoDB 索引结构

```
聚簇索引（主键索引）：
┌─────────────────────────────────────────────────────┐
│  叶子节点存储完整的行数据                             │
│  主键值 → 完整行数据                                 │
└─────────────────────────────────────────────────────┘

二级索引（非主键索引）：
┌─────────────────────────────────────────────────────┐
│  叶子节点存储主键值                                   │
│  索引列值 → 主键值                                   │
│  查询时需要回表：二级索引 → 主键 → 聚簇索引 → 数据    │
└─────────────────────────────────────────────────────┘
```

### 2.4 页与 B+ 树高度

```sql
-- InnoDB 页大小默认 16KB
SHOW VARIABLES LIKE 'innodb_page_size';

-- 假设：
-- 主键 BIGINT 8 字节
-- 指针 6 字节
-- 每页可存储：16384 / (8 + 6) ≈ 1170 个索引项

-- B+ 树高度计算：
-- 高度 2：1170 个叶子页
-- 高度 3：1170 × 1170 ≈ 137 万行
-- 高度 4：1170 × 1170 × 1170 ≈ 16 亿行

-- 结论：3-4 层 B+ 树可以存储海量数据
-- 每次查询只需 3-4 次磁盘 IO
```

---

## 3. 索引类型详解

### 3.1 主键索引

```sql
-- 创建表时指定主键
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100)
) ENGINE=InnoDB;

-- 或者
CREATE TABLE users (
    id BIGINT NOT NULL AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL,
    PRIMARY KEY (id)
);

-- 主键特点：
-- 1. 唯一且非空
-- 2. 聚簇索引，数据按主键顺序存储
-- 3. 建议使用自增整数，避免页分裂
```

### 3.2 唯一索引

```sql
-- 创建唯一索引
CREATE UNIQUE INDEX idx_email ON users(email);

-- 或在建表时
CREATE TABLE users (
    id BIGINT PRIMARY KEY,
    email VARCHAR(100),
    UNIQUE KEY uk_email (email)
);

-- 唯一索引 vs 普通索引：
-- 唯一索引：找到第一条匹配记录后停止
-- 普通索引：继续查找直到不匹配（因为可能有重复值）
-- 性能差异很小，主要用于业务约束
```

### 3.3 普通索引

```sql
-- 创建普通索引
CREATE INDEX idx_username ON users(username);

-- 或
ALTER TABLE users ADD INDEX idx_username(username);

-- 查看索引
SHOW INDEX FROM users;
```

### 3.4 联合索引（复合索引）

```sql
-- 创建联合索引
CREATE INDEX idx_name_age_city ON users(name, age, city);

-- 联合索引遵循最左前缀原则
-- 可以使用索引的查询：
WHERE name = '张三'                    -- ✓ 使用 name
WHERE name = '张三' AND age = 25       -- ✓ 使用 name, age
WHERE name = '张三' AND age = 25 AND city = '北京'  -- ✓ 全部使用

-- 不能使用索引的查询：
WHERE age = 25                         -- ✗ 缺少 name
WHERE city = '北京'                    -- ✗ 缺少 name, age
WHERE age = 25 AND city = '北京'       -- ✗ 缺少 name
```

### 3.5 前缀索引

```sql
-- 对长字符串只索引前 N 个字符
CREATE INDEX idx_email_prefix ON users(email(10));

-- 计算合适的前缀长度
SELECT 
    COUNT(DISTINCT email) / COUNT(*) AS full_selectivity,
    COUNT(DISTINCT LEFT(email, 5)) / COUNT(*) AS prefix_5,
    COUNT(DISTINCT LEFT(email, 10)) / COUNT(*) AS prefix_10,
    COUNT(DISTINCT LEFT(email, 15)) / COUNT(*) AS prefix_15
FROM users;

-- 选择性接近完整列时的最小长度

-- 注意：前缀索引不能用于 ORDER BY 和 GROUP BY
```

### 3.6 全文索引

```sql
-- 创建全文索引（MySQL 5.6+ InnoDB 支持）
CREATE FULLTEXT INDEX idx_content ON articles(title, content);

-- 使用全文索引
SELECT * FROM articles 
WHERE MATCH(title, content) AGAINST('MySQL 优化' IN NATURAL LANGUAGE MODE);

-- 布尔模式
SELECT * FROM articles 
WHERE MATCH(title, content) AGAINST('+MySQL -Oracle' IN BOOLEAN MODE);

-- 注意：中文需要配置分词器（ngram）
-- my.cnf 配置
[mysqld]
ngram_token_size=2
```


### 3.7 空间索引

```sql
-- 创建空间索引（用于地理位置数据）
CREATE TABLE locations (
    id BIGINT PRIMARY KEY,
    name VARCHAR(100),
    position POINT NOT NULL SRID 4326,
    SPATIAL INDEX idx_position (position)
);

-- 插入数据
INSERT INTO locations VALUES (1, '北京', ST_GeomFromText('POINT(116.4 39.9)', 4326));

-- 查询附近的点
SELECT * FROM locations 
WHERE ST_Distance_Sphere(position, ST_GeomFromText('POINT(116.4 39.9)', 4326)) < 1000;
```

### 3.8 降序索引（MySQL 8.0+）

```sql
-- MySQL 8.0 之前，DESC 被忽略
-- MySQL 8.0+ 真正支持降序索引

CREATE INDEX idx_created_desc ON orders(created_at DESC);

-- 适用场景：ORDER BY created_at DESC 的查询
SELECT * FROM orders ORDER BY created_at DESC LIMIT 10;
```

### 3.9 函数索引（MySQL 8.0.13+）

```sql
-- 对表达式创建索引
CREATE INDEX idx_upper_name ON users((UPPER(name)));

-- 使用
SELECT * FROM users WHERE UPPER(name) = 'ZHANGSAN';

-- JSON 字段索引
CREATE INDEX idx_json_age ON users((CAST(info->>'$.age' AS UNSIGNED)));
```

### 3.10 不可见索引（MySQL 8.0+）

```sql
-- 创建不可见索引（优化器不使用，但仍然维护）
CREATE INDEX idx_test ON users(test_col) INVISIBLE;

-- 修改索引可见性
ALTER TABLE users ALTER INDEX idx_test VISIBLE;
ALTER TABLE users ALTER INDEX idx_test INVISIBLE;

-- 用途：测试删除索引的影响，而不真正删除
```

---

## 4. 索引设计原则

### 4.1 选择性原则

```sql
-- 索引选择性 = 不重复值数量 / 总行数
-- 选择性越高，索引效果越好

-- 计算选择性
SELECT 
    COUNT(DISTINCT status) / COUNT(*) AS status_selectivity,
    COUNT(DISTINCT user_id) / COUNT(*) AS user_id_selectivity,
    COUNT(DISTINCT order_no) / COUNT(*) AS order_no_selectivity
FROM orders;

-- 结果示例：
-- status_selectivity: 0.0001（只有几个状态值，选择性低）
-- user_id_selectivity: 0.1（较好）
-- order_no_selectivity: 1.0（唯一，最好）

-- 结论：
-- 不要对选择性很低的列单独建索引（如 status、gender）
-- 可以放在联合索引的后面
```

### 4.2 最左前缀原则

```sql
-- 联合索引 (a, b, c)
-- 相当于创建了三个索引：(a), (a,b), (a,b,c)

-- 能使用索引的情况：
WHERE a = 1                      -- ✓
WHERE a = 1 AND b = 2            -- ✓
WHERE a = 1 AND b = 2 AND c = 3  -- ✓
WHERE a = 1 AND c = 3            -- ✓ 只用到 a
WHERE b = 2 AND a = 1            -- ✓ 优化器会调整顺序

-- 不能使用索引的情况：
WHERE b = 2                      -- ✗
WHERE c = 3                      -- ✗
WHERE b = 2 AND c = 3            -- ✗
```

### 4.3 覆盖索引原则

```sql
-- 尽量让查询只访问索引，不回表

-- 假设有索引 idx_name_age(name, age)

-- 需要回表（查询了索引外的列）
SELECT * FROM users WHERE name = '张三';

-- 覆盖索引（只查询索引中的列）
SELECT name, age FROM users WHERE name = '张三';

-- 优化：将常用查询列加入索引
CREATE INDEX idx_name_age_email ON users(name, age, email);
SELECT name, age, email FROM users WHERE name = '张三';  -- 覆盖索引
```

### 4.4 索引列顺序原则

```sql
-- 联合索引列顺序很重要，考虑因素：

-- 1. 等值查询的列放前面
-- 2. 选择性高的列放前面
-- 3. 排序列放后面

-- 示例：查询条件 status = 1 AND user_id = 100 ORDER BY created_at

-- 分析：
-- status 选择性低（只有几个值）
-- user_id 选择性高
-- created_at 用于排序

-- 推荐索引顺序：
CREATE INDEX idx_user_status_created ON orders(user_id, status, created_at);

-- 而不是：
CREATE INDEX idx_status_user_created ON orders(status, user_id, created_at);
```

### 4.5 避免冗余索引

```sql
-- 冗余索引示例
CREATE INDEX idx_a ON t(a);
CREATE INDEX idx_a_b ON t(a, b);  -- idx_a 是冗余的

-- 查找冗余索引
SELECT 
    t.TABLE_SCHEMA,
    t.TABLE_NAME,
    t.INDEX_NAME,
    t.COLUMN_NAME,
    t.SEQ_IN_INDEX
FROM information_schema.STATISTICS t
WHERE t.TABLE_SCHEMA = 'your_database'
ORDER BY t.TABLE_NAME, t.INDEX_NAME, t.SEQ_IN_INDEX;

-- MySQL 8.0+ 使用 sys 库
SELECT * FROM sys.schema_redundant_indexes;
```

---

## 5. EXPLAIN 执行计划

### 5.1 EXPLAIN 基础

```sql
-- 查看执行计划
EXPLAIN SELECT * FROM users WHERE name = '张三';

-- 更详细的信息
EXPLAIN FORMAT=JSON SELECT * FROM users WHERE name = '张三';

-- MySQL 8.0.18+ 实际执行并显示计划
EXPLAIN ANALYZE SELECT * FROM users WHERE name = '张三';
```

### 5.2 EXPLAIN 输出字段详解

```sql
EXPLAIN SELECT * FROM orders WHERE user_id = 100 AND status = 1;

+----+-------------+--------+------+---------------+------+---------+------+------+-------------+
| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows | Extra       |
+----+-------------+--------+------+---------------+------+---------+------+------+-------------+
|  1 | SIMPLE      | orders | ref  | idx_user      | idx_user | 8   | const|  100 | Using where |
+----+-------------+--------+------+---------------+------+---------+------+------+-------------+
```

**字段说明**：

| 字段 | 说明 |
|------|------|
| id | 查询序号，id 相同从上到下执行，id 不同大的先执行 |
| select_type | 查询类型 |
| table | 访问的表 |
| type | 访问类型（重要！） |
| possible_keys | 可能使用的索引 |
| key | 实际使用的索引 |
| key_len | 使用的索引长度 |
| ref | 与索引比较的列或常量 |
| rows | 预估扫描行数 |
| filtered | 过滤百分比 |
| Extra | 额外信息 |

### 5.3 type 访问类型（从好到差）

```sql
-- system：表只有一行
-- const：通过主键或唯一索引查询，最多一行
EXPLAIN SELECT * FROM users WHERE id = 1;  -- type: const

-- eq_ref：连接查询，使用主键或唯一索引
EXPLAIN SELECT * FROM orders o JOIN users u ON o.user_id = u.id;

-- ref：使用非唯一索引
EXPLAIN SELECT * FROM orders WHERE user_id = 100;  -- type: ref

-- range：索引范围扫描
EXPLAIN SELECT * FROM orders WHERE created_at > '2024-01-01';  -- type: range

-- index：全索引扫描（比全表扫描好）
EXPLAIN SELECT id FROM users;  -- type: index

-- ALL：全表扫描（最差，需要优化）
EXPLAIN SELECT * FROM users WHERE name LIKE '%张%';  -- type: ALL
```

**优化目标**：至少达到 range 级别，最好是 ref 或 const

### 5.4 Extra 重要信息

```sql
-- Using index：覆盖索引，无需回表（好）
EXPLAIN SELECT name FROM users WHERE name = '张三';

-- Using where：在存储引擎层过滤后，还需要在服务层过滤
EXPLAIN SELECT * FROM users WHERE name = '张三' AND age > 20;

-- Using index condition：索引下推 ICP（好）
EXPLAIN SELECT * FROM users WHERE name = '张三' AND age > 20;

-- Using temporary：使用临时表（需要优化）
EXPLAIN SELECT DISTINCT name FROM users;

-- Using filesort：额外排序（需要优化）
EXPLAIN SELECT * FROM users ORDER BY name;

-- Using join buffer：连接缓冲（可能需要优化）
EXPLAIN SELECT * FROM t1 JOIN t2 ON t1.col = t2.col;
```

### 5.5 key_len 计算

```sql
-- key_len 表示使用的索引字节数，用于判断联合索引使用了几列

-- 计算规则：
-- CHAR(n)：n 字节（utf8mb4 为 4n）
-- VARCHAR(n)：n 字节 + 2（长度）
-- INT：4 字节
-- BIGINT：8 字节
-- DATE：3 字节
-- DATETIME：8 字节
-- 允许 NULL：+1 字节

-- 示例：索引 (name VARCHAR(50), age INT)
-- name: 50 * 4 + 2 + 1 = 203 字节（utf8mb4，允许 NULL）
-- age: 4 + 1 = 5 字节

-- 如果 key_len = 203，只用了 name
-- 如果 key_len = 208，用了 name 和 age
```


---

## 6. 索引优化策略

### 6.1 单表查询优化

```sql
-- 原始查询（全表扫描）
SELECT * FROM orders 
WHERE user_id = 100 
  AND status = 1 
  AND created_at > '2024-01-01'
ORDER BY created_at DESC
LIMIT 10;

-- 分析：
-- 1. user_id 等值查询，选择性高
-- 2. status 等值查询，选择性低
-- 3. created_at 范围查询 + 排序

-- 优化方案1：联合索引
CREATE INDEX idx_user_status_created ON orders(user_id, status, created_at);

-- 优化方案2：如果 status 值很少，可以省略
CREATE INDEX idx_user_created ON orders(user_id, created_at);
-- 然后在应用层过滤 status
```

### 6.2 多表连接优化

```sql
-- 原始查询
SELECT o.*, u.name, p.product_name
FROM orders o
JOIN users u ON o.user_id = u.id
JOIN products p ON o.product_id = p.id
WHERE o.status = 1 AND o.created_at > '2024-01-01';

-- 优化原则：
-- 1. 小表驱动大表
-- 2. 被驱动表的连接字段要有索引
-- 3. 尽量使用覆盖索引

-- 确保索引存在
CREATE INDEX idx_user_id ON orders(user_id);
CREATE INDEX idx_product_id ON orders(product_id);
-- users.id 和 products.id 是主键，已有索引

-- 优化后（使用 STRAIGHT_JOIN 强制顺序，如果优化器选择不当）
SELECT o.*, u.name, p.product_name
FROM orders o
STRAIGHT_JOIN users u ON o.user_id = u.id
STRAIGHT_JOIN products p ON o.product_id = p.id
WHERE o.status = 1 AND o.created_at > '2024-01-01';
```

### 6.3 子查询优化

```sql
-- 低效的子查询
SELECT * FROM orders 
WHERE user_id IN (SELECT id FROM users WHERE status = 1);

-- 优化方案1：改为 JOIN
SELECT o.* FROM orders o
JOIN users u ON o.user_id = u.id
WHERE u.status = 1;

-- 优化方案2：EXISTS（当外表小时）
SELECT * FROM orders o
WHERE EXISTS (SELECT 1 FROM users u WHERE u.id = o.user_id AND u.status = 1);

-- MySQL 8.0 对子查询优化较好，但 JOIN 通常更可控
```

### 6.4 OR 条件优化

```sql
-- OR 可能导致索引失效
SELECT * FROM orders WHERE user_id = 100 OR status = 1;

-- 优化方案1：UNION ALL
SELECT * FROM orders WHERE user_id = 100
UNION ALL
SELECT * FROM orders WHERE status = 1 AND user_id != 100;

-- 优化方案2：分别建索引，让优化器使用 index_merge
CREATE INDEX idx_user_id ON orders(user_id);
CREATE INDEX idx_status ON orders(status);
-- 优化器可能使用 index_merge（type: index_merge）
```

### 6.5 LIKE 优化

```sql
-- 前缀匹配可以使用索引
SELECT * FROM users WHERE name LIKE '张%';  -- ✓ 使用索引

-- 后缀或中间匹配不能使用索引
SELECT * FROM users WHERE name LIKE '%三';   -- ✗ 全表扫描
SELECT * FROM users WHERE name LIKE '%张三%'; -- ✗ 全表扫描

-- 优化方案1：使用全文索引
CREATE FULLTEXT INDEX idx_name_ft ON users(name);
SELECT * FROM users WHERE MATCH(name) AGAINST('张三');

-- 优化方案2：使用搜索引擎（Elasticsearch）

-- 优化方案3：冗余反转字段（用于后缀匹配）
ALTER TABLE users ADD COLUMN name_reverse VARCHAR(50);
UPDATE users SET name_reverse = REVERSE(name);
CREATE INDEX idx_name_reverse ON users(name_reverse);
-- 查询 LIKE '%三' 变为
SELECT * FROM users WHERE name_reverse LIKE '三%';
```

### 6.6 NULL 值处理

```sql
-- IS NULL 可以使用索引
SELECT * FROM users WHERE email IS NULL;  -- ✓

-- IS NOT NULL 通常不使用索引（因为大部分数据非空）
SELECT * FROM users WHERE email IS NOT NULL;  -- 可能全表扫描

-- 建议：
-- 1. 尽量设置 NOT NULL DEFAULT ''
-- 2. 使用特殊值代替 NULL（如 0、空字符串）
```

---

## 7. 索引失效场景

### 7.1 常见索引失效情况

```sql
-- 1. 对索引列使用函数
SELECT * FROM users WHERE YEAR(created_at) = 2024;  -- ✗
-- 优化
SELECT * FROM users WHERE created_at >= '2024-01-01' AND created_at < '2025-01-01';

-- 2. 对索引列进行运算
SELECT * FROM orders WHERE price * 0.9 > 100;  -- ✗
-- 优化
SELECT * FROM orders WHERE price > 100 / 0.9;

-- 3. 隐式类型转换
-- phone 是 VARCHAR 类型
SELECT * FROM users WHERE phone = 13800138000;  -- ✗ 数字会转为字符串比较
-- 优化
SELECT * FROM users WHERE phone = '13800138000';

-- 4. 隐式字符集转换
-- 两表字符集不同时，连接可能失效
SELECT * FROM t1 JOIN t2 ON t1.name = t2.name;  -- 如果字符集不同，可能失效

-- 5. LIKE 以通配符开头
SELECT * FROM users WHERE name LIKE '%张三';  -- ✗

-- 6. OR 连接非索引列
SELECT * FROM users WHERE name = '张三' OR age = 25;  -- 如果 age 无索引，整体失效

-- 7. NOT IN、NOT EXISTS、!=、<>
SELECT * FROM users WHERE status != 1;  -- 可能不使用索引
SELECT * FROM users WHERE id NOT IN (1, 2, 3);  -- 可能不使用索引

-- 8. 联合索引不满足最左前缀
-- 索引 (a, b, c)
SELECT * FROM t WHERE b = 1;  -- ✗ 缺少 a
```

### 7.2 索引失效验证

```sql
-- 使用 EXPLAIN 验证
EXPLAIN SELECT * FROM users WHERE YEAR(created_at) = 2024;
-- type: ALL，key: NULL → 索引失效

EXPLAIN SELECT * FROM users WHERE created_at >= '2024-01-01';
-- type: range，key: idx_created → 索引生效
```

### 7.3 强制使用索引

```sql
-- 当优化器选择错误时，可以强制使用索引
SELECT * FROM orders FORCE INDEX(idx_user_id) WHERE user_id = 100;

-- 忽略某个索引
SELECT * FROM orders IGNORE INDEX(idx_status) WHERE status = 1;

-- 建议使用某个索引（优化器可能不采纳）
SELECT * FROM orders USE INDEX(idx_user_id) WHERE user_id = 100;

-- 注意：强制索引应该是最后手段，优先考虑优化查询或索引
```

---

## 8. 覆盖索引与回表

### 8.1 什么是回表？

```sql
-- 假设有表和索引
CREATE TABLE users (
    id BIGINT PRIMARY KEY,
    name VARCHAR(50),
    age INT,
    email VARCHAR(100),
    INDEX idx_name(name)
);

-- 查询过程
SELECT * FROM users WHERE name = '张三';

-- 执行步骤：
-- 1. 在 idx_name 索引中找到 name='张三' 的记录
-- 2. 获取对应的主键 id
-- 3. 回到聚簇索引（主键索引）查找完整数据
-- 4. 返回结果

-- 这个"回到聚簇索引"的过程就是回表
```

### 8.2 覆盖索引避免回表

```sql
-- 创建覆盖索引
CREATE INDEX idx_name_age_email ON users(name, age, email);

-- 查询只需要索引中的列
SELECT name, age, email FROM users WHERE name = '张三';

-- 执行步骤：
-- 1. 在索引中找到 name='张三' 的记录
-- 2. 直接从索引中获取 name, age, email
-- 3. 无需回表！

-- EXPLAIN 显示 Extra: Using index
```

### 8.3 覆盖索引优化实例

```sql
-- 场景：分页查询订单列表
-- 原始查询（需要回表）
SELECT id, order_no, amount, status, created_at 
FROM orders 
WHERE user_id = 100 
ORDER BY created_at DESC 
LIMIT 10;

-- 优化：创建覆盖索引
CREATE INDEX idx_user_created_covering 
ON orders(user_id, created_at, id, order_no, amount, status);

-- 现在查询可以完全在索引中完成，无需回表
-- Extra: Using index
```

### 8.4 索引下推（ICP）

```sql
-- MySQL 5.6+ 支持索引下推
-- 在存储引擎层过滤数据，减少回表次数

-- 假设索引 idx_name_age(name, age)
SELECT * FROM users WHERE name LIKE '张%' AND age = 25;

-- 没有 ICP：
-- 1. 索引找到所有 name LIKE '张%' 的记录
-- 2. 回表获取完整数据
-- 3. 在服务层过滤 age = 25

-- 有 ICP：
-- 1. 索引找到 name LIKE '张%' 的记录
-- 2. 在索引层直接过滤 age = 25
-- 3. 只对满足条件的记录回表

-- EXPLAIN 显示 Extra: Using index condition

-- 查看 ICP 是否开启
SHOW VARIABLES LIKE 'optimizer_switch';
-- index_condition_pushdown=on
```

---

## 9. 联合索引优化

### 9.1 联合索引设计

```sql
-- 场景：电商订单查询
-- 常见查询：
-- 1. 查询某用户的订单
-- 2. 查询某用户某状态的订单
-- 3. 查询某用户某时间段的订单
-- 4. 查询某用户的订单并按时间排序

-- 分析查询模式
SELECT * FROM orders WHERE user_id = ?;
SELECT * FROM orders WHERE user_id = ? AND status = ?;
SELECT * FROM orders WHERE user_id = ? AND created_at > ?;
SELECT * FROM orders WHERE user_id = ? ORDER BY created_at DESC;

-- 设计联合索引
CREATE INDEX idx_user_status_created ON orders(user_id, status, created_at);

-- 这个索引可以支持：
-- WHERE user_id = ?                           ✓
-- WHERE user_id = ? AND status = ?            ✓
-- WHERE user_id = ? AND status = ? AND created_at > ?  ✓
-- WHERE user_id = ? ORDER BY created_at       ✗ (status 在中间，排序用不上)

-- 如果排序很重要，考虑：
CREATE INDEX idx_user_created ON orders(user_id, created_at);
```

### 9.2 范围查询对联合索引的影响

```sql
-- 索引 (a, b, c)
-- 范围查询会"截断"后面的列

SELECT * FROM t WHERE a = 1 AND b > 10 AND c = 100;
-- a = 1：使用索引
-- b > 10：使用索引（范围）
-- c = 100：不能使用索引！（b 是范围查询，c 被截断）

-- 优化：调整索引顺序
CREATE INDEX idx_a_c_b ON t(a, c, b);
-- 现在 a = 1 AND c = 100 都是等值查询，b > 10 在最后
```

### 9.3 排序与联合索引

```sql
-- 索引 (a, b, c)

-- 可以使用索引排序：
ORDER BY a
ORDER BY a, b
ORDER BY a, b, c
ORDER BY a DESC, b DESC, c DESC  -- 全部降序也可以

-- 不能使用索引排序：
ORDER BY b                -- 缺少 a
ORDER BY a, c             -- 缺少 b
ORDER BY a ASC, b DESC    -- 方向不一致（MySQL 8.0 前）

-- MySQL 8.0+ 支持降序索引
CREATE INDEX idx_a_b_desc ON t(a ASC, b DESC);
-- 现在 ORDER BY a ASC, b DESC 可以使用索引
```


---

## 10. 排序与分组优化

### 10.1 ORDER BY 优化

```sql
-- 排序的两种方式：
-- 1. 使用索引排序（高效）
-- 2. filesort 文件排序（需要优化）

-- 使用索引排序的条件：
-- 1. ORDER BY 列有索引
-- 2. 满足最左前缀
-- 3. 排序方向一致

-- 示例：索引 idx_user_created(user_id, created_at)

-- 使用索引排序 ✓
SELECT * FROM orders WHERE user_id = 100 ORDER BY created_at;
SELECT * FROM orders WHERE user_id = 100 ORDER BY user_id, created_at;

-- filesort ✗
SELECT * FROM orders WHERE user_id = 100 ORDER BY status;  -- status 不在索引中
SELECT * FROM orders ORDER BY created_at;  -- 缺少 user_id 条件

-- 优化 filesort
-- 增加 sort_buffer_size
SET sort_buffer_size = 4 * 1024 * 1024;  -- 4MB

-- 减少排序数据量
SELECT id, created_at FROM orders ORDER BY created_at LIMIT 10;  -- 只查需要的列
```

### 10.2 GROUP BY 优化

```sql
-- GROUP BY 也可以使用索引

-- 使用索引分组 ✓
-- 索引 idx_user_id(user_id)
SELECT user_id, COUNT(*) FROM orders GROUP BY user_id;

-- 使用临时表 ✗
SELECT status, COUNT(*) FROM orders GROUP BY status;  -- status 无索引

-- 优化方案
CREATE INDEX idx_status ON orders(status);

-- 或者使用覆盖索引
CREATE INDEX idx_status_covering ON orders(status, id);
SELECT status, COUNT(*) FROM orders GROUP BY status;  -- Using index
```

### 10.3 DISTINCT 优化

```sql
-- DISTINCT 类似于 GROUP BY

-- 使用索引 ✓
SELECT DISTINCT user_id FROM orders;  -- 如果 user_id 有索引

-- 使用临时表 ✗
SELECT DISTINCT status, user_id FROM orders;  -- 可能需要临时表

-- 优化：创建联合索引
CREATE INDEX idx_status_user ON orders(status, user_id);
```

### 10.4 避免 filesort 和临时表

```sql
-- 查看是否使用了 filesort 或临时表
EXPLAIN SELECT ...;
-- Extra: Using filesort      → 需要优化
-- Extra: Using temporary     → 需要优化

-- 优化策略：
-- 1. 创建合适的索引
-- 2. 减少排序/分组的数据量
-- 3. 调整 sort_buffer_size 和 tmp_table_size
-- 4. 使用覆盖索引
```

---

## 11. 分页查询优化

### 11.1 传统分页的问题

```sql
-- 传统分页
SELECT * FROM orders ORDER BY id LIMIT 1000000, 10;

-- 问题：MySQL 需要扫描 1000010 行，丢弃前 1000000 行
-- 偏移量越大，性能越差

-- 执行时间对比：
-- LIMIT 0, 10      → 0.001s
-- LIMIT 10000, 10  → 0.05s
-- LIMIT 100000, 10 → 0.5s
-- LIMIT 1000000, 10 → 5s
```

### 11.2 延迟关联优化

```sql
-- 优化方案1：延迟关联
-- 先查主键，再关联获取数据

SELECT o.* FROM orders o
JOIN (
    SELECT id FROM orders ORDER BY id LIMIT 1000000, 10
) t ON o.id = t.id;

-- 原理：
-- 子查询只扫描索引，获取 id（覆盖索引）
-- 外层查询只需要回表 10 次
```

### 11.3 游标分页（推荐）

```sql
-- 优化方案2：基于游标的分页
-- 记住上一页最后一条记录的 id

-- 第一页
SELECT * FROM orders ORDER BY id LIMIT 10;
-- 假设最后一条 id = 100

-- 第二页
SELECT * FROM orders WHERE id > 100 ORDER BY id LIMIT 10;
-- 假设最后一条 id = 200

-- 第三页
SELECT * FROM orders WHERE id > 200 ORDER BY id LIMIT 10;

-- 优点：无论第几页，性能都一样
-- 缺点：不能跳页，只能上一页/下一页
```

### 11.4 复杂排序的分页

```sql
-- 场景：按创建时间倒序分页
-- 问题：created_at 可能重复

-- 方案1：联合排序
SELECT * FROM orders 
WHERE (created_at, id) < ('2024-01-15 10:00:00', 1000)
ORDER BY created_at DESC, id DESC 
LIMIT 10;

-- 方案2：使用覆盖索引 + 延迟关联
CREATE INDEX idx_created_id ON orders(created_at DESC, id DESC);

SELECT o.* FROM orders o
JOIN (
    SELECT id FROM orders 
    WHERE created_at < '2024-01-15 10:00:00'
    ORDER BY created_at DESC, id DESC 
    LIMIT 10
) t ON o.id = t.id;
```

### 11.5 总数统计优化

```sql
-- 分页通常需要总数
SELECT COUNT(*) FROM orders WHERE user_id = 100;
SELECT * FROM orders WHERE user_id = 100 LIMIT 0, 10;

-- 优化方案：

-- 1. 使用缓存存储总数
-- 在 Redis 中缓存 count，定期更新

-- 2. 使用近似值
SELECT TABLE_ROWS FROM information_schema.TABLES 
WHERE TABLE_NAME = 'orders';  -- 近似值，不准确

-- 3. 限制最大页数
-- 只显示前 100 页，超过提示"更多结果请使用搜索"

-- 4. 异步计算
-- 先返回数据，总数异步计算后更新
```

---

## 12. 索引维护与监控

### 12.1 查看索引使用情况

```sql
-- MySQL 8.0+ 查看索引使用统计
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    INDEX_NAME,
    COUNT_STAR AS query_count,
    COUNT_READ,
    COUNT_WRITE,
    COUNT_FETCH
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE OBJECT_SCHEMA = 'your_database'
ORDER BY COUNT_STAR DESC;

-- 查找未使用的索引
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    INDEX_NAME
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE INDEX_NAME IS NOT NULL
  AND COUNT_STAR = 0
  AND OBJECT_SCHEMA = 'your_database';
```

### 12.2 索引碎片整理

```sql
-- 查看表状态
SHOW TABLE STATUS LIKE 'orders';
-- Data_free 表示碎片空间

-- 重建表（整理碎片）
ALTER TABLE orders ENGINE=InnoDB;

-- 或者
OPTIMIZE TABLE orders;

-- 在线重建（MySQL 5.6+）
ALTER TABLE orders FORCE, ALGORITHM=INPLACE, LOCK=NONE;
```

### 12.3 索引统计信息

```sql
-- 查看索引基数（Cardinality）
SHOW INDEX FROM orders;

-- 更新统计信息
ANALYZE TABLE orders;

-- 查看统计信息
SELECT * FROM mysql.innodb_table_stats WHERE table_name = 'orders';
SELECT * FROM mysql.innodb_index_stats WHERE table_name = 'orders';
```

### 12.4 慢查询分析

```sql
-- 开启慢查询日志
SET GLOBAL slow_query_log = ON;
SET GLOBAL long_query_time = 1;  -- 超过 1 秒记录
SET GLOBAL slow_query_log_file = '/var/log/mysql/slow.log';

-- 查看慢查询
SHOW VARIABLES LIKE 'slow_query%';

-- 使用 mysqldumpslow 分析
mysqldumpslow -s t -t 10 /var/log/mysql/slow.log

-- 使用 pt-query-digest（推荐）
pt-query-digest /var/log/mysql/slow.log > slow_report.txt
```

### 12.5 索引建议工具

```sql
-- MySQL 8.0+ 索引建议
EXPLAIN FORMAT=JSON SELECT * FROM orders WHERE user_id = 100;
-- 查看 "possible_keys" 和 "used_key_parts"

-- 使用 pt-index-usage 分析索引使用
pt-index-usage --host=localhost slow.log

-- 使用 sys 库
SELECT * FROM sys.schema_unused_indexes;
SELECT * FROM sys.schema_redundant_indexes;
```

---

## 13. 常见错误与解决方案

### 13.1 索引选择错误

```sql
-- 问题：优化器选择了错误的索引
EXPLAIN SELECT * FROM orders WHERE user_id = 100 AND status = 1;
-- 可能选择了 idx_status 而不是 idx_user_id

-- 原因：
-- 1. 统计信息不准确
-- 2. 数据分布不均匀

-- 解决方案：
-- 1. 更新统计信息
ANALYZE TABLE orders;

-- 2. 强制使用索引
SELECT * FROM orders FORCE INDEX(idx_user_id) WHERE user_id = 100 AND status = 1;

-- 3. 创建更合适的联合索引
CREATE INDEX idx_user_status ON orders(user_id, status);
```

### 13.2 索引过多

```sql
-- 问题：表有太多索引，写入变慢

-- 诊断：
SHOW INDEX FROM orders;
-- 如果索引超过 5-6 个，考虑优化

-- 解决方案：
-- 1. 删除冗余索引
SELECT * FROM sys.schema_redundant_indexes WHERE table_name = 'orders';

-- 2. 删除未使用的索引
SELECT * FROM sys.schema_unused_indexes WHERE object_name = 'orders';

-- 3. 合并索引
-- 将 idx_a, idx_b 合并为 idx_a_b
DROP INDEX idx_a ON orders;
DROP INDEX idx_b ON orders;
CREATE INDEX idx_a_b ON orders(a, b);
```

### 13.3 索引列选择不当

```sql
-- 问题：对低选择性列建索引
CREATE INDEX idx_status ON orders(status);  -- status 只有 3-5 个值

-- 诊断：
SELECT COUNT(DISTINCT status) / COUNT(*) AS selectivity FROM orders;
-- 如果 < 0.1，选择性太低

-- 解决方案：
-- 1. 不单独建索引，放入联合索引
CREATE INDEX idx_user_status ON orders(user_id, status);

-- 2. 使用分区表
CREATE TABLE orders (
    ...
) PARTITION BY LIST(status) (
    PARTITION p_pending VALUES IN (0),
    PARTITION p_paid VALUES IN (1),
    PARTITION p_shipped VALUES IN (2)
);
```

### 13.4 主键设计问题

```sql
-- 问题1：使用 UUID 作为主键
CREATE TABLE users (
    id CHAR(36) PRIMARY KEY,  -- UUID
    ...
);
-- 问题：
-- 1. UUID 无序，导致页分裂
-- 2. 占用空间大（36字节 vs 8字节）
-- 3. 二级索引也变大

-- 解决方案：
-- 1. 使用自增 ID
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    uuid CHAR(36) UNIQUE,
    ...
);

-- 2. 使用有序 UUID（MySQL 8.0+）
CREATE TABLE users (
    id BINARY(16) PRIMARY KEY,
    ...
);
INSERT INTO users (id) VALUES (UUID_TO_BIN(UUID(), 1));

-- 问题2：主键太长
-- 主键会被复制到所有二级索引
-- 建议主键使用 INT 或 BIGINT
```

### 13.5 字符集问题

```sql
-- 问题：连接时字符集不同导致索引失效
SELECT * FROM t1 JOIN t2 ON t1.name = t2.name;
-- 如果 t1.name 是 utf8，t2.name 是 utf8mb4，可能失效

-- 诊断：
SHOW CREATE TABLE t1;
SHOW CREATE TABLE t2;

-- 解决方案：
ALTER TABLE t1 CONVERT TO CHARACTER SET utf8mb4;
-- 或者
ALTER TABLE t1 MODIFY name VARCHAR(50) CHARACTER SET utf8mb4;
```

### 13.6 锁等待问题

```sql
-- 问题：索引不当导致锁范围过大

-- 场景：更新订单状态
UPDATE orders SET status = 2 WHERE user_id = 100 AND status = 1;

-- 如果没有合适的索引，可能锁住整个表或大量行

-- 解决方案：
-- 1. 确保 WHERE 条件有索引
CREATE INDEX idx_user_status ON orders(user_id, status);

-- 2. 减小事务范围
-- 3. 使用乐观锁
UPDATE orders SET status = 2, version = version + 1 
WHERE id = 1 AND version = 1;
```


---

## 14. 最佳实践总结

### 14.1 索引设计清单

```
□ 主键设计
  □ 使用自增整数（BIGINT）
  □ 避免使用 UUID 或长字符串
  □ 避免使用业务字段作为主键

□ 索引选择
  □ 高选择性列优先
  □ 查询频繁的列
  □ 连接条件列
  □ 排序和分组列

□ 联合索引
  □ 遵循最左前缀原则
  □ 等值查询列在前
  □ 范围查询列在后
  □ 排序列考虑顺序

□ 索引数量
  □ 单表不超过 5-6 个
  □ 删除冗余索引
  □ 删除未使用索引

□ 索引维护
  □ 定期更新统计信息
  □ 定期整理碎片
  □ 监控索引使用情况
```

### 14.2 SQL 编写规范

```sql
-- 1. 避免 SELECT *
-- 错误
SELECT * FROM orders WHERE user_id = 100;
-- 正确
SELECT id, order_no, amount FROM orders WHERE user_id = 100;

-- 2. 避免在索引列上使用函数
-- 错误
SELECT * FROM orders WHERE DATE(created_at) = '2024-01-15';
-- 正确
SELECT * FROM orders WHERE created_at >= '2024-01-15' AND created_at < '2024-01-16';

-- 3. 避免隐式类型转换
-- 错误（phone 是 VARCHAR）
SELECT * FROM users WHERE phone = 13800138000;
-- 正确
SELECT * FROM users WHERE phone = '13800138000';

-- 4. 使用 LIMIT 限制结果集
SELECT * FROM orders WHERE status = 1 LIMIT 100;

-- 5. 避免大事务
-- 将大批量操作拆分成小批次
DELETE FROM logs WHERE created_at < '2024-01-01' LIMIT 1000;

-- 6. 使用 EXISTS 代替 IN（大数据集时）
-- 可能较慢
SELECT * FROM orders WHERE user_id IN (SELECT id FROM users WHERE status = 1);
-- 可能更快
SELECT * FROM orders o WHERE EXISTS (SELECT 1 FROM users u WHERE u.id = o.user_id AND u.status = 1);
```

### 14.3 索引命名规范

```sql
-- 推荐命名规范
-- 主键：pk_表名
-- 唯一索引：uk_表名_列名
-- 普通索引：idx_表名_列名
-- 联合索引：idx_表名_列1_列2

CREATE TABLE orders (
    id BIGINT PRIMARY KEY,                           -- pk_orders
    order_no VARCHAR(32),
    user_id BIGINT,
    status TINYINT,
    created_at DATETIME,
    
    UNIQUE KEY uk_orders_order_no (order_no),
    INDEX idx_orders_user_id (user_id),
    INDEX idx_orders_user_status_created (user_id, status, created_at)
);
```

### 14.4 性能基准

```sql
-- 查询性能参考标准
-- 简单查询（主键/唯一索引）：< 1ms
-- 普通索引查询：< 10ms
-- 复杂查询（多表连接）：< 100ms
-- 报表查询：< 1s

-- 索引效率参考
-- type = const/eq_ref：最优
-- type = ref：良好
-- type = range：可接受
-- type = index：需要优化
-- type = ALL：必须优化

-- 扫描行数参考
-- rows < 100：优秀
-- rows < 1000：良好
-- rows < 10000：可接受
-- rows > 10000：需要优化
```

### 14.5 常用诊断 SQL

```sql
-- 1. 查看表索引
SHOW INDEX FROM orders;

-- 2. 查看表结构
SHOW CREATE TABLE orders;

-- 3. 查看执行计划
EXPLAIN SELECT * FROM orders WHERE user_id = 100;
EXPLAIN FORMAT=JSON SELECT * FROM orders WHERE user_id = 100;
EXPLAIN ANALYZE SELECT * FROM orders WHERE user_id = 100;  -- MySQL 8.0.18+

-- 4. 查看索引使用情况
SELECT * FROM sys.schema_index_statistics WHERE table_name = 'orders';

-- 5. 查看未使用的索引
SELECT * FROM sys.schema_unused_indexes;

-- 6. 查看冗余索引
SELECT * FROM sys.schema_redundant_indexes;

-- 7. 查看表统计信息
SELECT * FROM mysql.innodb_table_stats WHERE table_name = 'orders';

-- 8. 更新统计信息
ANALYZE TABLE orders;

-- 9. 查看慢查询
SELECT * FROM mysql.slow_log ORDER BY start_time DESC LIMIT 10;

-- 10. 查看当前执行的查询
SHOW PROCESSLIST;
SELECT * FROM information_schema.PROCESSLIST WHERE COMMAND != 'Sleep';
```

### 14.6 索引优化流程

```
1. 发现问题
   ├── 慢查询日志
   ├── 监控告警
   └── 用户反馈

2. 分析问题
   ├── EXPLAIN 执行计划
   ├── 查看索引使用情况
   └── 分析数据分布

3. 制定方案
   ├── 添加索引
   ├── 修改索引
   ├── 优化 SQL
   └── 调整表结构

4. 测试验证
   ├── 测试环境验证
   ├── 对比执行计划
   └── 压测性能

5. 上线实施
   ├── 低峰期执行
   ├── 使用 pt-online-schema-change
   └── 监控影响

6. 效果评估
   ├── 查询时间对比
   ├── 资源使用对比
   └── 持续监控
```

### 14.7 在线 DDL 工具

```bash
# 使用 pt-online-schema-change 添加索引（不锁表）
pt-online-schema-change \
  --alter "ADD INDEX idx_user_id(user_id)" \
  --host=localhost \
  --user=root \
  --password=xxx \
  D=database,t=orders \
  --execute

# MySQL 8.0 原生支持在线 DDL
ALTER TABLE orders ADD INDEX idx_user_id(user_id), ALGORITHM=INPLACE, LOCK=NONE;

# 查看 DDL 进度
SELECT * FROM performance_schema.events_stages_current;
```

---

## 参考资料

- [MySQL 8.0 官方文档 - 优化](https://dev.mysql.com/doc/refman/8.0/en/optimization.html)
- [MySQL 索引原理](https://dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html)
- [High Performance MySQL](https://www.oreilly.com/library/view/high-performance-mysql/9781492080503/)
- [Percona Toolkit](https://www.percona.com/software/database-tools/percona-toolkit)
- [MySQL Explain 详解](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html)
