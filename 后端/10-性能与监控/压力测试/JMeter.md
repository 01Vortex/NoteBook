# JMeter 压力测试完全指南

> 基于 Java 8 + Spring Boot 2.7.18 的 JMeter 深度学习笔记

---

## 目录

1. [JMeter 概述](#1-jmeter-概述)
2. [安装与配置](#2-安装与配置)
3. [核心概念](#3-核心概念)
4. [基础使用](#4-基础使用)
5. [高级功能](#5-高级功能)
6. [Spring Boot 接口测试实战](#6-spring-boot-接口测试实战)
7. [分布式压测](#7-分布式压测)
8. [性能指标分析](#8-性能指标分析)
9. [最佳实践](#9-最佳实践)
10. [常见错误与解决](#10-常见错误与解决)

---

## 1. JMeter 概述

### 1.1 什么是 JMeter？

Apache JMeter 是一款开源的性能测试工具，最初设计用于 Web 应用测试，现在已扩展到各种服务的测试。

**通俗理解**：JMeter 就像一个"压力制造机"，可以模拟成千上万的用户同时访问你的系统，帮你找出系统的性能瓶颈。

```
┌─────────────────────────────────────────────────────────────────────┐
│                        JMeter 工作原理                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│   ┌─────────────┐                         ┌─────────────────────┐   │
│   │   JMeter    │   模拟 N 个并发用户      │   被测系统           │   │
│   │   压测机     │ ═══════════════════════▶│   (Spring Boot)     │   │
│   │             │   发送 HTTP 请求         │                     │   │
│   └─────────────┘                         └─────────────────────┘   │
│         │                                           │               │
│         │ 收集响应数据                               │ 返回响应      │
│         ◀═══════════════════════════════════════════╝               │
│         │                                                           │
│         ▼                                                           │
│   ┌─────────────┐                                                   │
│   │  生成报告    │  响应时间、吞吐量、错误率等                        │
│   └─────────────┘                                                   │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 1.2 JMeter 能测试什么？

| 协议/类型 | 说明 |
|----------|------|
| HTTP/HTTPS | Web 应用、REST API |
| JDBC | 数据库性能测试 |
| FTP | 文件传输测试 |
| JMS | 消息队列测试 |
| SOAP/REST | Web Service 测试 |
| TCP | Socket 测试 |
| LDAP | 目录服务测试 |
| Mail | 邮件服务测试 |

### 1.3 性能测试类型

```
┌─────────────────────────────────────────────────────────────────────┐
│                        性能测试类型                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  1. 负载测试 (Load Testing)                                         │
│     目的：验证系统在预期负载下的表现                                  │
│     方法：逐步增加用户数，观察系统响应                                │
│                                                                      │
│  2. 压力测试 (Stress Testing)                                       │
│     目的：找出系统的极限和崩溃点                                     │
│     方法：持续增加负载直到系统崩溃                                   │
│                                                                      │
│  3. 稳定性测试 (Soak Testing)                                       │
│     目的：验证系统长时间运行的稳定性                                  │
│     方法：在正常负载下运行较长时间（如 24 小时）                      │
│                                                                      │
│  4. 峰值测试 (Spike Testing)                                        │
│     目的：验证系统应对突发流量的能力                                  │
│     方法：突然增加大量用户，观察系统反应                              │
│                                                                      │
│  5. 容量测试 (Capacity Testing)                                     │
│     目的：确定系统能处理的最大用户数                                  │
│     方法：逐步增加用户数，找出性能拐点                                │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 2. 安装与配置

### 2.1 下载安装

```bash
# 1. 下载 JMeter (推荐 5.5+ 版本)
# 官网: https://jmeter.apache.org/download_jmeter.cgi

# 2. 解压到指定目录
# Windows
unzip apache-jmeter-5.5.zip -d C:\Tools\

# Linux/Mac
tar -xzf apache-jmeter-5.5.tgz -C /opt/

# 3. 配置环境变量
# Windows: 添加 JMETER_HOME 和 PATH
set JMETER_HOME=C:\Tools\apache-jmeter-5.5
set PATH=%PATH%;%JMETER_HOME%\bin

# Linux/Mac: 编辑 ~/.bashrc 或 ~/.zshrc
export JMETER_HOME=/opt/apache-jmeter-5.5
export PATH=$PATH:$JMETER_HOME/bin

# 4. 验证安装
jmeter -v
```

### 2.2 目录结构

```
apache-jmeter-5.5/
├── bin/                    # 可执行文件和配置
│   ├── jmeter.bat         # Windows 启动脚本
│   ├── jmeter.sh          # Linux/Mac 启动脚本
│   ├── jmeter.properties  # 主配置文件
│   └── user.properties    # 用户自定义配置
├── lib/                    # 核心库文件
│   └── ext/               # 扩展插件目录
├── docs/                   # 文档
├── extras/                 # 额外工具（Ant 脚本等）
└── printable_docs/         # 可打印文档
```

### 2.3 重要配置优化

```properties
# bin/jmeter.properties 或 bin/user.properties

# 1. 语言设置（中文）
language=zh_CN

# 2. 编码设置
sampleresult.default.encoding=UTF-8

# 3. 增大 JVM 内存（大规模测试必须）
# 编辑 bin/jmeter.bat 或 bin/jmeter.sh
# Windows: 修改 jmeter.bat
set HEAP=-Xms1g -Xmx4g -XX:MaxMetaspaceSize=512m

# Linux: 修改 jmeter.sh
HEAP="-Xms1g -Xmx4g -XX:MaxMetaspaceSize=512m"

# 4. 结果文件配置
jmeter.save.saveservice.output_format=csv
jmeter.save.saveservice.response_data=false
jmeter.save.saveservice.samplerData=false

# 5. 禁用不必要的监听器（提升性能）
jmeter.save.saveservice.print_field_names=true
```


### 2.4 插件安装

```bash
# 推荐安装的插件

# 1. 下载 JMeter Plugins Manager
# https://jmeter-plugins.org/install/Install/
# 将 jmeter-plugins-manager-x.x.jar 放入 lib/ext 目录

# 2. 通过 Plugins Manager 安装常用插件
# - jpgc-graphs-basic: 基础图表
# - jpgc-graphs-additional: 额外图表
# - jpgc-casutg: 自定义线程组
# - jpgc-perfmon: 服务器监控
# - jpgc-json: JSON 处理

# 3. 命令行安装插件
java -jar lib/cmdrunner-2.2.jar --tool org.jmeterplugins.repository.PluginManagerCMD install jpgc-casutg
```

---

## 3. 核心概念

### 3.1 测试计划结构

```
测试计划 (Test Plan)
│
├── 线程组 (Thread Group)           ← 模拟用户
│   │
│   ├── 配置元件 (Config Element)   ← 全局配置
│   │   ├── HTTP 请求默认值
│   │   ├── HTTP Cookie 管理器
│   │   └── CSV 数据文件设置
│   │
│   ├── 前置处理器 (Pre Processor)  ← 请求前执行
│   │   └── 用户参数
│   │
│   ├── 取样器 (Sampler)            ← 发送请求
│   │   ├── HTTP 请求
│   │   ├── JDBC 请求
│   │   └── Debug 取样器
│   │
│   ├── 后置处理器 (Post Processor) ← 请求后执行
│   │   ├── JSON 提取器
│   │   ├── 正则表达式提取器
│   │   └── BeanShell 后置处理器
│   │
│   ├── 断言 (Assertion)            ← 验证响应
│   │   ├── 响应断言
│   │   └── JSON 断言
│   │
│   ├── 定时器 (Timer)              ← 控制节奏
│   │   ├── 固定定时器
│   │   └── 随机定时器
│   │
│   └── 监听器 (Listener)           ← 收集结果
│       ├── 查看结果树
│       ├── 聚合报告
│       └── 图形结果
│
└── 全局配置元件
```

### 3.2 元件执行顺序

```
┌─────────────────────────────────────────────────────────────────────┐
│                        元件执行顺序                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  1. 配置元件 (Config Element)                                       │
│     ↓                                                               │
│  2. 前置处理器 (Pre Processor)                                      │
│     ↓                                                               │
│  3. 定时器 (Timer)                                                  │
│     ↓                                                               │
│  4. 取样器 (Sampler)                                                │
│     ↓                                                               │
│  5. 后置处理器 (Post Processor)                                     │
│     ↓                                                               │
│  6. 断言 (Assertion)                                                │
│     ↓                                                               │
│  7. 监听器 (Listener)                                               │
│                                                                      │
│  注意：同级元件按照在测试计划中的顺序执行                             │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.3 作用域规则

```
测试计划
│
├── HTTP Cookie 管理器 ──────────────┐
│                                    │ 作用于整个测试计划
├── 线程组 1                         │
│   ├── HTTP 请求默认值 ─────────────┼─ 作用于线程组 1
│   ├── HTTP 请求 A                  │
│   │   └── JSON 提取器 ─────────────┼─ 只作用于请求 A
│   └── HTTP 请求 B                  │
│                                    │
└── 线程组 2                         │
    └── HTTP 请求 C ─────────────────┘ 也能使用 Cookie 管理器

规则总结：
1. 父级元件作用于所有子级
2. 同级元件按顺序执行
3. 子级元件只作用于其父级取样器
```

### 3.4 线程组详解

```
┌─────────────────────────────────────────────────────────────────────┐
│                        线程组配置                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  线程数 (Number of Threads)                                         │
│  └── 模拟的并发用户数                                                │
│                                                                      │
│  Ramp-Up 时间 (Ramp-Up Period)                                      │
│  └── 所有线程启动完成所需的时间（秒）                                 │
│  └── 例：100 线程，Ramp-Up=10s，则每秒启动 10 个线程                 │
│                                                                      │
│  循环次数 (Loop Count)                                               │
│  └── 每个线程执行测试的次数                                          │
│  └── 勾选"永远"则持续运行直到手动停止                                │
│                                                                      │
│  调度器 (Scheduler)                                                  │
│  └── 持续时间：测试运行的总时间                                      │
│  └── 启动延迟：测试开始前的等待时间                                  │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

```
线程启动示例：100 线程，Ramp-Up=10s

时间(s)  0   1   2   3   4   5   6   7   8   9   10
线程数   0  10  20  30  40  50  60  70  80  90  100
         │   │   │   │   │   │   │   │   │   │   │
         ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼
        ┌───────────────────────────────────────────┐
        │ ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ │
        │ ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ │
        │ ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ │
        └───────────────────────────────────────────┘
                    并发用户数逐渐增加
```


---

## 4. 基础使用

### 4.1 创建第一个测试计划

**场景**：测试一个简单的 Spring Boot GET 接口

```java
// Spring Boot 控制器示例
@RestController
@RequestMapping("/api")
public class UserController {
    
    @GetMapping("/users/{id}")
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        User user = userService.findById(id);
        return ResponseEntity.ok(user);
    }
    
    @GetMapping("/users")
    public ResponseEntity<List<User>> listUsers(
            @RequestParam(defaultValue = "1") int page,
            @RequestParam(defaultValue = "10") int size) {
        List<User> users = userService.findAll(page, size);
        return ResponseEntity.ok(users);
    }
}
```

**JMeter 测试步骤**：

```
步骤 1：创建测试计划
┌─────────────────────────────────────────────────────────────────────┐
│ 文件 → 新建                                                          │
│ 右键"测试计划" → 重命名为"用户接口测试"                               │
└─────────────────────────────────────────────────────────────────────┘

步骤 2：添加线程组
┌─────────────────────────────────────────────────────────────────────┐
│ 右键"测试计划" → 添加 → 线程(用户) → 线程组                          │
│                                                                      │
│ 配置：                                                               │
│ - 线程数：100                                                        │
│ - Ramp-Up 时间：10                                                   │
│ - 循环次数：10                                                       │
└─────────────────────────────────────────────────────────────────────┘

步骤 3：添加 HTTP 请求默认值
┌─────────────────────────────────────────────────────────────────────┐
│ 右键"线程组" → 添加 → 配置元件 → HTTP 请求默认值                      │
│                                                                      │
│ 配置：                                                               │
│ - 协议：http                                                         │
│ - 服务器名称或 IP：localhost                                         │
│ - 端口号：8080                                                       │
└─────────────────────────────────────────────────────────────────────┘

步骤 4：添加 HTTP 请求
┌─────────────────────────────────────────────────────────────────────┐
│ 右键"线程组" → 添加 → 取样器 → HTTP 请求                              │
│                                                                      │
│ 配置：                                                               │
│ - 名称：获取用户详情                                                  │
│ - 方法：GET                                                          │
│ - 路径：/api/users/1                                                 │
└─────────────────────────────────────────────────────────────────────┘

步骤 5：添加监听器
┌─────────────────────────────────────────────────────────────────────┐
│ 右键"线程组" → 添加 → 监听器 → 查看结果树                             │
│ 右键"线程组" → 添加 → 监听器 → 聚合报告                               │
│ 右键"线程组" → 添加 → 监听器 → 汇总报告                               │
└─────────────────────────────────────────────────────────────────────┘
```

### 4.2 HTTP 请求详解

#### 4.2.1 GET 请求

```
┌─────────────────────────────────────────────────────────────────────┐
│ HTTP 请求配置 - GET                                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 名称：获取用户列表                                                    │
│ 方法：GET                                                            │
│ 路径：/api/users                                                     │
│                                                                      │
│ 参数（Parameters）：                                                  │
│ ┌──────────┬─────────┬──────────┐                                   │
│ │ 名称      │ 值      │ 编码？    │                                   │
│ ├──────────┼─────────┼──────────┤                                   │
│ │ page     │ 1       │ ☑        │                                   │
│ │ size     │ 10      │ ☑        │                                   │
│ │ keyword  │ 张三    │ ☑        │  ← 中文需要编码                    │
│ └──────────┴─────────┴──────────┘                                   │
│                                                                      │
│ 实际请求：GET /api/users?page=1&size=10&keyword=%E5%BC%A0%E4%B8%89   │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 4.2.2 POST 请求（JSON）

```java
// Spring Boot 接口
@PostMapping("/users")
public ResponseEntity<User> createUser(@RequestBody UserDTO userDTO) {
    User user = userService.create(userDTO);
    return ResponseEntity.status(HttpStatus.CREATED).body(user);
}
```

```
┌─────────────────────────────────────────────────────────────────────┐
│ HTTP 请求配置 - POST JSON                                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 名称：创建用户                                                        │
│ 方法：POST                                                           │
│ 路径：/api/users                                                     │
│                                                                      │
│ Body Data（消息体数据）：                                             │
│ ┌─────────────────────────────────────────────────────────────────┐ │
│ │ {                                                                │ │
│ │   "username": "zhangsan",                                        │ │
│ │   "email": "zhangsan@example.com",                               │ │
│ │   "age": 25                                                      │ │
│ │ }                                                                │ │
│ └─────────────────────────────────────────────────────────────────┘ │
│                                                                      │
│ 需要添加 HTTP 信息头管理器：                                          │
│ Content-Type: application/json                                       │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

**添加 HTTP 信息头管理器**：

```
右键"HTTP 请求" → 添加 → 配置元件 → HTTP 信息头管理器

┌──────────────────┬─────────────────────────────┐
│ 名称              │ 值                          │
├──────────────────┼─────────────────────────────┤
│ Content-Type     │ application/json            │
│ Accept           │ application/json            │
│ Authorization    │ Bearer ${token}             │
└──────────────────┴─────────────────────────────┘
```

#### 4.2.3 POST 请求（表单）

```
┌─────────────────────────────────────────────────────────────────────┐
│ HTTP 请求配置 - POST Form                                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 名称：用户登录                                                        │
│ 方法：POST                                                           │
│ 路径：/api/login                                                     │
│                                                                      │
│ 参数（Parameters）：                                                  │
│ ┌──────────┬─────────────────┬──────────┐                           │
│ │ 名称      │ 值              │ 编码？    │                           │
│ ├──────────┼─────────────────┼──────────┤                           │
│ │ username │ admin           │ ☑        │                           │
│ │ password │ 123456          │ ☑        │                           │
│ └──────────┴─────────────────┴──────────┘                           │
│                                                                      │
│ Content-Type: application/x-www-form-urlencoded                      │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 4.2.4 文件上传

```
┌─────────────────────────────────────────────────────────────────────┐
│ HTTP 请求配置 - 文件上传                                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 名称：上传文件                                                        │
│ 方法：POST                                                           │
│ 路径：/api/upload                                                    │
│                                                                      │
│ 文件上传（Files Upload）：                                            │
│ ┌────────────────────────┬──────────────┬─────────────────────────┐ │
│ │ 文件路径                │ 参数名称      │ MIME 类型               │ │
│ ├────────────────────────┼──────────────┼─────────────────────────┤ │
│ │ C:\test\image.jpg      │ file         │ image/jpeg              │ │
│ └────────────────────────┴──────────────┴─────────────────────────┘ │
│                                                                      │
│ ☑ 使用 multipart/form-data                                          │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```


### 4.3 断言配置

#### 4.3.1 响应断言

```
┌─────────────────────────────────────────────────────────────────────┐
│ 响应断言配置                                                          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 右键"HTTP 请求" → 添加 → 断言 → 响应断言                              │
│                                                                      │
│ Apply to（应用于）：                                                  │
│ ○ Main sample only（仅主样本）                                       │
│                                                                      │
│ 测试字段：                                                            │
│ ○ 响应文本                                                           │
│ ○ 响应代码                                                           │
│ ○ 响应信息                                                           │
│ ○ 响应头                                                             │
│                                                                      │
│ 模式匹配规则：                                                        │
│ ○ 包括（Contains）                                                   │
│ ○ 匹配（Matches）- 正则表达式                                        │
│ ○ 相等（Equals）                                                     │
│ ○ 字符串（Substring）                                                │
│                                                                      │
│ 测试模式：                                                            │
│ ┌─────────────────────────────────────────────────────────────────┐ │
│ │ "success": true                                                  │ │
│ │ "code": 200                                                      │ │
│ └─────────────────────────────────────────────────────────────────┘ │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 4.3.2 JSON 断言

```
┌─────────────────────────────────────────────────────────────────────┐
│ JSON 断言配置                                                        │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 右键"HTTP 请求" → 添加 → 断言 → JSON 断言                             │
│                                                                      │
│ Assert JSON Path exists（断言 JSON 路径存在）：                       │
│ $.data.id                                                            │
│                                                                      │
│ Additionally assert value（额外断言值）：                             │
│ ☑ 启用                                                               │
│                                                                      │
│ Expected Value（期望值）：                                            │
│ 1                                                                    │
│                                                                      │
│ ☐ Match as regular expression（作为正则表达式匹配）                   │
│                                                                      │
│ 常用 JSON Path 表达式：                                               │
│ $.code              → 根节点下的 code 字段                            │
│ $.data.id           → data 对象下的 id 字段                          │
│ $.data[0].name      → data 数组第一个元素的 name                     │
│ $.data[*].id        → data 数组所有元素的 id                         │
│ $.data.length()     → data 数组的长度                                │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 4.3.3 响应代码断言

```
┌─────────────────────────────────────────────────────────────────────┐
│ 响应代码断言                                                          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 测试字段：○ 响应代码                                                  │
│ 模式匹配规则：○ 相等                                                  │
│                                                                      │
│ 测试模式：                                                            │
│ ┌─────────────────────────────────────────────────────────────────┐ │
│ │ 200                                                              │ │
│ └─────────────────────────────────────────────────────────────────┘ │
│                                                                      │
│ 或者使用正则匹配多个状态码：                                          │
│ 模式匹配规则：○ 匹配                                                  │
│ 测试模式：2\d{2}    → 匹配所有 2xx 状态码                             │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 4.4 定时器配置

#### 4.4.1 固定定时器

```
┌─────────────────────────────────────────────────────────────────────┐
│ 固定定时器                                                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 右键"HTTP 请求" → 添加 → 定时器 → 固定定时器                          │
│                                                                      │
│ 线程延迟（毫秒）：1000                                                │
│                                                                      │
│ 作用：每个请求之间固定等待 1 秒                                       │
│                                                                      │
│ 使用场景：                                                            │
│ - 模拟用户思考时间                                                    │
│ - 控制请求频率                                                        │
│ - 避免对服务器造成过大压力                                            │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 4.4.2 高斯随机定时器

```
┌─────────────────────────────────────────────────────────────────────┐
│ 高斯随机定时器                                                        │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 偏差（毫秒）：500                                                     │
│ 固定延迟偏移（毫秒）：1000                                            │
│                                                                      │
│ 实际延迟 = 高斯分布随机值(偏差) + 固定延迟                            │
│ 范围大约在：500ms ~ 1500ms                                           │
│                                                                      │
│ 使用场景：更真实地模拟用户行为                                        │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 4.4.3 统一随机定时器

```
┌─────────────────────────────────────────────────────────────────────┐
│ 统一随机定时器                                                        │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 随机延迟最大值（毫秒）：2000                                          │
│ 固定延迟偏移（毫秒）：1000                                            │
│                                                                      │
│ 实际延迟 = 随机值(0 ~ 2000) + 1000                                   │
│ 范围：1000ms ~ 3000ms                                                │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 4.4.4 常数吞吐量定时器

```
┌─────────────────────────────────────────────────────────────────────┐
│ 常数吞吐量定时器                                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 目标吞吐量（每分钟样本数）：600                                        │
│ → 即每秒 10 个请求 (600/60=10 TPS)                                   │
│                                                                      │
│ 基于计算的吞吐量：                                                    │
│ ○ 只有此线程                                                         │
│ ○ 当前线程组中的所有活动线程                                          │
│ ○ 所有活动线程                                                        │
│ ○ 当前线程组中的所有活动线程（共享）                                  │
│ ○ 所有活动线程（共享）                                                │
│                                                                      │
│ 使用场景：精确控制系统的 TPS                                          │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```


---

## 5. 高级功能

### 5.1 参数化

#### 5.1.1 CSV 数据文件设置

```
┌─────────────────────────────────────────────────────────────────────┐
│ CSV 数据文件设置                                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 右键"线程组" → 添加 → 配置元件 → CSV 数据文件设置                     │
│                                                                      │
│ 文件名：C:\test\users.csv                                            │
│ 文件编码：UTF-8                                                       │
│ 变量名称：username,password,email                                    │
│ 忽略首行：True（如果 CSV 有标题行）                                   │
│ 分隔符：,                                                            │
│ 遇到文件结束符再次循环：True                                          │
│ 遇到文件结束符停止线程：False                                         │
│ 线程共享模式：所有线程                                                │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

**CSV 文件示例** (users.csv)：

```csv
username,password,email
user001,pass001,user001@test.com
user002,pass002,user002@test.com
user003,pass003,user003@test.com
user004,pass004,user004@test.com
user005,pass005,user005@test.com
```

**在请求中使用变量**：

```
POST /api/login
Body:
{
    "username": "${username}",
    "password": "${password}",
    "email": "${email}"
}
```

#### 5.1.2 线程共享模式详解

```
┌─────────────────────────────────────────────────────────────────────┐
│ 线程共享模式                                                          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 1. 所有线程 (All threads)                                            │
│    所有线程共享同一个文件指针，每行数据只被使用一次                    │
│    适用：每个用户数据只能用一次的场景                                  │
│                                                                      │
│ 2. 当前线程组 (Current thread group)                                 │
│    同一线程组内的线程共享文件指针                                     │
│    适用：多线程组测试，每组使用独立数据                                │
│                                                                      │
│ 3. 当前线程 (Current thread)                                         │
│    每个线程独立读取文件，从头开始                                     │
│    适用：每个线程需要完整遍历所有数据                                  │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

```
示例：3 个线程，CSV 有 5 行数据

所有线程模式：
线程1: user001 → user004
线程2: user002 → user005
线程3: user003 → (循环到 user001)

当前线程模式：
线程1: user001 → user002 → user003 → user004 → user005
线程2: user001 → user002 → user003 → user004 → user005
线程3: user001 → user002 → user003 → user004 → user005
```

#### 5.1.3 用户定义的变量

```
┌─────────────────────────────────────────────────────────────────────┐
│ 用户定义的变量                                                        │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 右键"测试计划" → 添加 → 配置元件 → 用户定义的变量                     │
│                                                                      │
│ ┌──────────────┬─────────────────────────────────────┐              │
│ │ 名称          │ 值                                  │              │
│ ├──────────────┼─────────────────────────────────────┤              │
│ │ BASE_URL     │ http://localhost:8080               │              │
│ │ API_VERSION  │ v1                                  │              │
│ │ TIMEOUT      │ 5000                                │              │
│ └──────────────┴─────────────────────────────────────┘              │
│                                                                      │
│ 使用：${BASE_URL}/api/${API_VERSION}/users                           │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 5.1.4 JMeter 内置函数

```
┌─────────────────────────────────────────────────────────────────────┐
│ 常用内置函数                                                          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 1. 随机数                                                            │
│    ${__Random(1,100)}           → 1-100 的随机整数                   │
│    ${__Random(1,100,randVar)}   → 结果存入 randVar 变量              │
│                                                                      │
│ 2. 随机字符串                                                         │
│    ${__RandomString(10,abcdef)} → 10 位随机字符串                    │
│    ${__UUID}                    → 生成 UUID                          │
│                                                                      │
│ 3. 时间函数                                                           │
│    ${__time()}                  → 当前时间戳（毫秒）                  │
│    ${__time(yyyy-MM-dd)}        → 格式化日期                         │
│    ${__time(yyyy-MM-dd HH:mm:ss)} → 格式化日期时间                   │
│    ${__timeShift(yyyy-MM-dd,,P1D,,)} → 明天的日期                    │
│                                                                      │
│ 4. 计数器                                                             │
│    ${__counter(TRUE)}           → 每个线程独立计数                   │
│    ${__counter(FALSE)}          → 所有线程共享计数                   │
│                                                                      │
│ 5. 属性函数                                                           │
│    ${__P(propertyName,default)} → 获取属性值                         │
│    ${__setProperty(name,value)} → 设置属性值                         │
│                                                                      │
│ 6. 变量函数                                                           │
│    ${__V(varName)}              → 获取变量值                         │
│    ${__eval(${varName})}        → 计算表达式                         │
│                                                                      │
│ 7. 字符串函数                                                         │
│    ${__split(a|b|c,varName,|)}  → 分割字符串                         │
│    ${__groovy(code)}            → 执行 Groovy 代码                   │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 5.2 关联（提取响应数据）

#### 5.2.1 JSON 提取器

```java
// Spring Boot 登录接口返回
{
    "code": 200,
    "message": "success",
    "data": {
        "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
        "userId": 12345,
        "username": "admin"
    }
}
```

```
┌─────────────────────────────────────────────────────────────────────┐
│ JSON 提取器配置                                                       │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 右键"登录请求" → 添加 → 后置处理器 → JSON 提取器                      │
│                                                                      │
│ Names of created variables（变量名）：token                          │
│ JSON Path expressions（JSON 路径）：$.data.token                     │
│ Match No.（匹配数字）：1                                              │
│ Default Values（默认值）：NOT_FOUND                                   │
│                                                                      │
│ 提取多个值：                                                          │
│ Names：token;userId;username                                         │
│ JSON Path：$.data.token;$.data.userId;$.data.username                │
│                                                                      │
│ 后续请求使用：                                                        │
│ Authorization: Bearer ${token}                                       │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 5.2.2 正则表达式提取器

```
┌─────────────────────────────────────────────────────────────────────┐
│ 正则表达式提取器                                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 右键"HTTP 请求" → 添加 → 后置处理器 → 正则表达式提取器                │
│                                                                      │
│ 引用名称：sessionId                                                   │
│ 正则表达式："sessionId":"(.+?)"                                       │
│ 模板：$1$                                                            │
│ 匹配数字：1                                                           │
│ 默认值：NOT_FOUND                                                     │
│                                                                      │
│ 正则表达式说明：                                                      │
│ (.+?)  → 非贪婪匹配，捕获组 1                                        │
│ $1$    → 使用捕获组 1 的内容                                         │
│ $0$    → 使用整个匹配内容                                            │
│                                                                      │
│ 常用正则：                                                            │
│ "token":"(.+?)"           → 提取 token                               │
│ <input.*?name="csrf".*?value="(.+?)"  → 提取 CSRF token             │
│ Set-Cookie: JSESSIONID=(.+?);  → 提取 Session ID                    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 5.2.3 边界提取器

```
┌─────────────────────────────────────────────────────────────────────┐
│ 边界提取器（JMeter 5.0+）                                             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 右键"HTTP 请求" → 添加 → 后置处理器 → 边界提取器                      │
│                                                                      │
│ 引用名称：orderId                                                     │
│ 左边界："orderId":                                                    │
│ 右边界：,                                                            │
│ 匹配数字：1                                                           │
│ 默认值：NOT_FOUND                                                     │
│                                                                      │
│ 优点：比正则表达式更简单，性能更好                                    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```


### 5.3 逻辑控制器

#### 5.3.1 如果（If）控制器

```
┌─────────────────────────────────────────────────────────────────────┐
│ If 控制器                                                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 右键"线程组" → 添加 → 逻辑控制器 → 如果（If）控制器                   │
│                                                                      │
│ 条件表达式（使用 __jexl3 或 __groovy）：                              │
│                                                                      │
│ 方式 1：JEXL3 表达式                                                  │
│ ${__jexl3("${status}" == "success")}                                 │
│                                                                      │
│ 方式 2：Groovy 表达式                                                 │
│ ${__groovy(vars.get("status") == "success")}                         │
│                                                                      │
│ 方式 3：勾选"Interpret Condition as Variable Expression"             │
│ ${status} == success                                                 │
│                                                                      │
│ 常用条件：                                                            │
│ ${__jexl3(${code} == 200)}                → 数字比较                 │
│ ${__jexl3("${token}" != "NOT_FOUND")}     → 字符串不等于             │
│ ${__jexl3("${token}".length() > 0)}       → 字符串长度               │
│ ${__jexl3(${count} > 0 && ${count} < 10)} → 多条件                   │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

**使用场景示例**：

```
线程组
├── 登录请求
│   └── JSON 提取器（提取 token）
├── If 控制器（条件：token 不为空）
│   └── 获取用户信息请求（使用 token）
└── If 控制器（条件：token 为空）
    └── 错误处理请求
```

#### 5.3.2 循环控制器

```
┌─────────────────────────────────────────────────────────────────────┐
│ 循环控制器                                                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 右键"线程组" → 添加 → 逻辑控制器 → 循环控制器                         │
│                                                                      │
│ 循环次数：10                                                          │
│ 或勾选"永远"持续循环                                                  │
│                                                                      │
│ 使用场景：                                                            │
│ - 重复执行某个请求                                                    │
│ - 配合计数器实现分页查询                                              │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

**分页查询示例**：

```
线程组
├── 计数器（起始值：1，递增：1，引用名：pageNum）
└── 循环控制器（循环 10 次）
    └── HTTP 请求
        路径：/api/users?page=${pageNum}&size=10
```

#### 5.3.3 ForEach 控制器

```
┌─────────────────────────────────────────────────────────────────────┐
│ ForEach 控制器                                                       │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 输入变量前缀：userId                                                  │
│ 开始循环索引：0                                                       │
│ 结束循环索引：（留空则自动检测）                                       │
│ 输出变量名称：currentUserId                                           │
│                                                                      │
│ 前提：需要先提取出 userId_1, userId_2, userId_3 等变量                │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

**使用示例**：

```
线程组
├── 获取用户列表
│   └── JSON 提取器
│       变量名：userId
│       JSON Path：$.data[*].id
│       Match No.：-1（提取所有匹配）
│       → 生成 userId_1, userId_2, userId_3...
│
└── ForEach 控制器（遍历 userId）
    └── 获取用户详情
        路径：/api/users/${currentUserId}
```

#### 5.3.4 事务控制器

```
┌─────────────────────────────────────────────────────────────────────┐
│ 事务控制器                                                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 右键"线程组" → 添加 → 逻辑控制器 → 事务控制器                         │
│                                                                      │
│ 名称：完整下单流程                                                    │
│ ☑ Generate parent sample（生成父样本）                               │
│ ☐ Include duration of timer...（包含定时器时间）                     │
│                                                                      │
│ 作用：将多个请求组合成一个事务，统计整体响应时间                       │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

**使用示例**：

```
线程组
└── 事务控制器（完整下单流程）
    ├── 1. 添加购物车
    ├── 2. 获取购物车
    ├── 3. 创建订单
    ├── 4. 支付订单
    └── 5. 查询订单状态

结果：统计整个下单流程的总响应时间
```

#### 5.3.5 仅一次控制器

```
┌─────────────────────────────────────────────────────────────────────┐
│ 仅一次控制器                                                          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 右键"线程组" → 添加 → 逻辑控制器 → 仅一次控制器                       │
│                                                                      │
│ 作用：控制器内的请求每个线程只执行一次                                 │
│ 适用：登录、初始化数据等只需执行一次的操作                             │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

**使用示例**：

```
线程组（循环 100 次）
├── 仅一次控制器
│   └── 登录请求（每个线程只登录一次）
│       └── JSON 提取器（提取 token）
│
└── 业务请求（循环执行 100 次）
    └── 使用 ${token} 访问接口
```

### 5.4 BeanShell / Groovy 脚本

#### 5.4.1 BeanShell 前置处理器

```
┌─────────────────────────────────────────────────────────────────────┐
│ BeanShell 前置处理器                                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 右键"HTTP 请求" → 添加 → 前置处理器 → BeanShell 前置处理器            │
│                                                                      │
│ 常用内置变量：                                                        │
│ - vars: JMeterVariables，操作 JMeter 变量                            │
│ - props: JMeterProperties，操作 JMeter 属性                          │
│ - ctx: JMeterContext，获取上下文信息                                 │
│ - prev: SampleResult，获取上一个请求的结果                           │
│ - sampler: 当前取样器                                                │
│ - log: 日志对象                                                      │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

```java
// BeanShell 脚本示例

// 1. 生成签名
import java.security.MessageDigest;
import java.util.Base64;

String timestamp = String.valueOf(System.currentTimeMillis());
String secret = "your_secret_key";
String data = timestamp + secret;

MessageDigest md = MessageDigest.getInstance("MD5");
byte[] digest = md.digest(data.getBytes("UTF-8"));
StringBuilder sb = new StringBuilder();
for (byte b : digest) {
    sb.append(String.format("%02x", b));
}
String sign = sb.toString();

vars.put("timestamp", timestamp);
vars.put("sign", sign);

log.info("Generated sign: " + sign);

// 2. 生成随机手机号
import java.util.Random;
Random random = new Random();
String[] prefixes = {"138", "139", "150", "151", "152"};
String prefix = prefixes[random.nextInt(prefixes.length)];
String phone = prefix + String.format("%08d", random.nextInt(100000000));
vars.put("phone", phone);

// 3. 读取文件内容
import java.io.*;
BufferedReader br = new BufferedReader(new FileReader("C:/test/data.txt"));
String line = br.readLine();
vars.put("fileContent", line);
br.close();
```

#### 5.4.2 JSR223 处理器（推荐使用 Groovy）

```
┌─────────────────────────────────────────────────────────────────────┐
│ JSR223 前置处理器（Groovy）                                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 语言：groovy                                                         │
│ ☑ Cache compiled script if available（缓存编译脚本，提升性能）        │
│                                                                      │
│ 优势：                                                                │
│ - 性能比 BeanShell 好 10 倍以上                                      │
│ - 语法更现代，支持闭包                                                │
│ - 更好的 Java 兼容性                                                 │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

```groovy
// Groovy 脚本示例

// 1. 生成 UUID
import java.util.UUID
vars.put("uuid", UUID.randomUUID().toString())

// 2. JSON 处理
import groovy.json.JsonSlurper
import groovy.json.JsonOutput

def jsonSlurper = new JsonSlurper()
def response = jsonSlurper.parseText(prev.getResponseDataAsString())
def userId = response.data.id
vars.put("userId", userId.toString())

// 3. 生成请求体
def requestBody = [
    "username": vars.get("username"),
    "timestamp": System.currentTimeMillis(),
    "nonce": UUID.randomUUID().toString()
]
vars.put("requestBody", JsonOutput.toJson(requestBody))

// 4. 日期处理
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

def now = LocalDateTime.now()
def formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")
vars.put("currentTime", now.format(formatter))
vars.put("tomorrow", now.plusDays(1).format(formatter))

// 5. 加密处理
import javax.crypto.Mac
import javax.crypto.spec.SecretKeySpec
import java.util.Base64

def secret = "your_secret_key"
def data = vars.get("timestamp") + vars.get("nonce")

def mac = Mac.getInstance("HmacSHA256")
mac.init(new SecretKeySpec(secret.getBytes("UTF-8"), "HmacSHA256"))
def signature = Base64.getEncoder().encodeToString(mac.doFinal(data.getBytes("UTF-8")))
vars.put("signature", signature)

// 6. 条件判断
def code = vars.get("responseCode")
if (code == "200") {
    log.info("Request successful")
} else {
    log.error("Request failed with code: " + code)
    // 可以设置变量控制后续流程
    vars.put("shouldContinue", "false")
}
```


---

## 6. Spring Boot 接口测试实战

### 6.1 完整的 Spring Boot 测试项目

#### 6.1.1 Spring Boot 接口代码

```java
// 实体类
@Data
public class User {
    private Long id;
    private String username;
    private String email;
    private String password;
    private LocalDateTime createTime;
}

@Data
public class ApiResponse<T> {
    private int code;
    private String message;
    private T data;
    
    public static <T> ApiResponse<T> success(T data) {
        ApiResponse<T> response = new ApiResponse<>();
        response.setCode(200);
        response.setMessage("success");
        response.setData(data);
        return response;
    }
    
    public static <T> ApiResponse<T> error(int code, String message) {
        ApiResponse<T> response = new ApiResponse<>();
        response.setCode(code);
        response.setMessage(message);
        return response;
    }
}

// 登录请求/响应
@Data
public class LoginRequest {
    @NotBlank(message = "用户名不能为空")
    private String username;
    @NotBlank(message = "密码不能为空")
    private String password;
}

@Data
public class LoginResponse {
    private String token;
    private Long userId;
    private String username;
    private Long expireTime;
}
```

```java
// 控制器
@RestController
@RequestMapping("/api")
@Slf4j
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private JwtUtil jwtUtil;
    
    // 登录接口
    @PostMapping("/login")
    public ApiResponse<LoginResponse> login(@Valid @RequestBody LoginRequest request) {
        log.info("用户登录: {}", request.getUsername());
        User user = userService.login(request.getUsername(), request.getPassword());
        if (user == null) {
            return ApiResponse.error(401, "用户名或密码错误");
        }
        
        String token = jwtUtil.generateToken(user.getId(), user.getUsername());
        LoginResponse response = new LoginResponse();
        response.setToken(token);
        response.setUserId(user.getId());
        response.setUsername(user.getUsername());
        response.setExpireTime(System.currentTimeMillis() + 3600000);
        
        return ApiResponse.success(response);
    }
    
    // 获取用户信息（需要认证）
    @GetMapping("/users/{id}")
    public ApiResponse<User> getUser(
            @PathVariable Long id,
            @RequestHeader("Authorization") String authorization) {
        // 验证 token
        String token = authorization.replace("Bearer ", "");
        if (!jwtUtil.validateToken(token)) {
            return ApiResponse.error(401, "token 无效");
        }
        
        User user = userService.findById(id);
        if (user == null) {
            return ApiResponse.error(404, "用户不存在");
        }
        return ApiResponse.success(user);
    }
    
    // 用户列表（分页）
    @GetMapping("/users")
    public ApiResponse<PageResult<User>> listUsers(
            @RequestParam(defaultValue = "1") int page,
            @RequestParam(defaultValue = "10") int size,
            @RequestHeader("Authorization") String authorization) {
        String token = authorization.replace("Bearer ", "");
        if (!jwtUtil.validateToken(token)) {
            return ApiResponse.error(401, "token 无效");
        }
        
        PageResult<User> result = userService.findAll(page, size);
        return ApiResponse.success(result);
    }
    
    // 创建用户
    @PostMapping("/users")
    public ApiResponse<User> createUser(
            @Valid @RequestBody User user,
            @RequestHeader("Authorization") String authorization) {
        String token = authorization.replace("Bearer ", "");
        if (!jwtUtil.validateToken(token)) {
            return ApiResponse.error(401, "token 无效");
        }
        
        User created = userService.create(user);
        return ApiResponse.success(created);
    }
    
    // 更新用户
    @PutMapping("/users/{id}")
    public ApiResponse<User> updateUser(
            @PathVariable Long id,
            @RequestBody User user,
            @RequestHeader("Authorization") String authorization) {
        String token = authorization.replace("Bearer ", "");
        if (!jwtUtil.validateToken(token)) {
            return ApiResponse.error(401, "token 无效");
        }
        
        user.setId(id);
        User updated = userService.update(user);
        return ApiResponse.success(updated);
    }
    
    // 删除用户
    @DeleteMapping("/users/{id}")
    public ApiResponse<Void> deleteUser(
            @PathVariable Long id,
            @RequestHeader("Authorization") String authorization) {
        String token = authorization.replace("Bearer ", "");
        if (!jwtUtil.validateToken(token)) {
            return ApiResponse.error(401, "token 无效");
        }
        
        userService.delete(id);
        return ApiResponse.success(null);
    }
}
```

### 6.2 JMeter 测试计划结构

```
测试计划：Spring Boot API 压力测试
│
├── 用户定义的变量
│   ├── BASE_URL = http://localhost:8080
│   └── API_PREFIX = /api
│
├── HTTP 请求默认值
│   ├── 协议：http
│   ├── 服务器：localhost
│   └── 端口：8080
│
├── HTTP Cookie 管理器
│
├── HTTP 信息头管理器
│   ├── Content-Type: application/json
│   └── Accept: application/json
│
├── CSV 数据文件设置（用户数据）
│   └── users.csv
│
├── 线程组：用户接口测试
│   │
│   ├── 仅一次控制器
│   │   └── 登录请求
│   │       ├── HTTP 请求（POST /api/login）
│   │       ├── JSON 提取器（提取 token）
│   │       ├── JSON 断言（验证 code=200）
│   │       └── 响应断言（验证包含 token）
│   │
│   ├── 获取用户列表
│   │   ├── HTTP 请求（GET /api/users）
│   │   ├── HTTP 信息头管理器（Authorization）
│   │   └── JSON 断言
│   │
│   ├── 获取用户详情
│   │   ├── HTTP 请求（GET /api/users/${userId}）
│   │   └── JSON 断言
│   │
│   ├── 创建用户
│   │   ├── HTTP 请求（POST /api/users）
│   │   ├── JSON 提取器（提取新用户 ID）
│   │   └── JSON 断言
│   │
│   ├── 更新用户
│   │   ├── HTTP 请求（PUT /api/users/${newUserId}）
│   │   └── JSON 断言
│   │
│   └── 删除用户
│       ├── HTTP 请求（DELETE /api/users/${newUserId}）
│       └── 响应断言
│
├── 查看结果树
├── 聚合报告
├── 汇总报告
└── 响应时间图
```

### 6.3 详细配置示例

#### 6.3.1 登录请求配置

```
┌─────────────────────────────────────────────────────────────────────┐
│ HTTP 请求 - 登录                                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 名称：登录请求                                                        │
│ 方法：POST                                                           │
│ 路径：${API_PREFIX}/login                                            │
│                                                                      │
│ Body Data：                                                          │
│ {                                                                    │
│     "username": "${username}",                                       │
│     "password": "${password}"                                        │
│ }                                                                    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│ JSON 提取器 - 提取 Token                                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ Names of created variables：token;userId                             │
│ JSON Path expressions：$.data.token;$.data.userId                    │
│ Match No.：1;1                                                       │
│ Default Values：NOT_FOUND;0                                          │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│ JSON 断言 - 验证登录成功                                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ Assert JSON Path exists：$.data.token                                │
│ Additionally assert value：☐                                         │
│                                                                      │
│ 或者验证 code：                                                       │
│ Assert JSON Path exists：$.code                                      │
│ Expected Value：200                                                  │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 6.3.2 带认证的请求配置

```
┌─────────────────────────────────────────────────────────────────────┐
│ HTTP 信息头管理器 - 认证头                                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 添加到需要认证的请求下：                                              │
│                                                                      │
│ ┌──────────────────┬─────────────────────────────────┐              │
│ │ 名称              │ 值                              │              │
│ ├──────────────────┼─────────────────────────────────┤              │
│ │ Authorization    │ Bearer ${token}                 │              │
│ └──────────────────┴─────────────────────────────────┘              │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 6.3.3 创建用户请求

```
┌─────────────────────────────────────────────────────────────────────┐
│ HTTP 请求 - 创建用户                                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 名称：创建用户                                                        │
│ 方法：POST                                                           │
│ 路径：${API_PREFIX}/users                                            │
│                                                                      │
│ Body Data：                                                          │
│ {                                                                    │
│     "username": "user_${__time(yyyyMMddHHmmssSSS)}_${__Random(1,999)}",│
│     "email": "user_${__UUID}@test.com",                              │
│     "password": "Test123456"                                         │
│ }                                                                    │
│                                                                      │
│ 说明：使用时间戳和随机数确保用户名唯一                                 │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```


### 6.4 JDBC 数据库测试

#### 6.4.1 配置 JDBC 连接

```
┌─────────────────────────────────────────────────────────────────────┐
│ JDBC Connection Configuration                                        │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 1. 添加 MySQL 驱动到 lib 目录                                         │
│    将 mysql-connector-java-8.0.x.jar 复制到 JMeter/lib 目录          │
│                                                                      │
│ 2. 右键"线程组" → 添加 → 配置元件 → JDBC Connection Configuration     │
│                                                                      │
│ Variable Name for created pool：myDatabase                           │
│                                                                      │
│ Database Connection Configuration：                                   │
│ - Database URL：jdbc:mysql://localhost:3306/testdb?useSSL=false      │
│ - JDBC Driver class：com.mysql.cj.jdbc.Driver                        │
│ - Username：root                                                     │
│ - Password：123456                                                   │
│                                                                      │
│ Connection Pool Configuration：                                       │
│ - Max Number of Connections：10                                      │
│ - Max Wait (ms)：10000                                               │
│ - Auto Commit：True                                                  │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 6.4.2 JDBC 请求

```
┌─────────────────────────────────────────────────────────────────────┐
│ JDBC Request - 查询                                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 右键"线程组" → 添加 → 取样器 → JDBC Request                           │
│                                                                      │
│ Variable Name of Pool：myDatabase                                    │
│ Query Type：Select Statement                                         │
│                                                                      │
│ SQL Query：                                                          │
│ SELECT id, username, email FROM users WHERE id = ?                   │
│                                                                      │
│ Parameter values：${userId}                                          │
│ Parameter types：INTEGER                                             │
│                                                                      │
│ Variable names：id,username,email                                    │
│ Result variable name：queryResult                                    │
│                                                                      │
│ 结果变量：                                                            │
│ - id_1, username_1, email_1（第一行）                                │
│ - id_2, username_2, email_2（第二行）                                │
│ - id_#（总行数）                                                     │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│ JDBC Request - 插入                                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ Query Type：Update Statement                                         │
│                                                                      │
│ SQL Query：                                                          │
│ INSERT INTO users (username, email, password, create_time)           │
│ VALUES (?, ?, ?, NOW())                                              │
│                                                                      │
│ Parameter values：${username},${email},${password}                   │
│ Parameter types：VARCHAR,VARCHAR,VARCHAR                             │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│ JDBC Request - 存储过程                                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ Query Type：Callable Statement                                       │
│                                                                      │
│ SQL Query：                                                          │
│ {call sp_get_user_by_id(?)}                                          │
│                                                                      │
│ Parameter values：${userId}                                          │
│ Parameter types：INTEGER                                             │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 6.5 WebSocket 测试

```
┌─────────────────────────────────────────────────────────────────────┐
│ WebSocket 测试配置                                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 1. 安装 WebSocket 插件                                               │
│    通过 Plugins Manager 安装 WebSocket Samplers                      │
│                                                                      │
│ 2. 添加 WebSocket Open Connection                                    │
│    右键"线程组" → 添加 → 取样器 → WebSocket Open Connection           │
│                                                                      │
│    Server URL：ws://localhost:8080/ws                                │
│    Connection timeout：5000                                          │
│                                                                      │
│ 3. 添加 WebSocket request-response Sampler                           │
│    Request data：{"type":"ping","data":"hello"}                      │
│    Response timeout：10000                                           │
│                                                                      │
│ 4. 添加 WebSocket Close                                              │
│    关闭连接                                                          │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 6.6 命令行执行

```bash
# 基本执行
jmeter -n -t test_plan.jmx -l result.jtl

# 参数说明
# -n: 非 GUI 模式（命令行模式）
# -t: 测试计划文件
# -l: 结果文件
# -j: 日志文件
# -e: 生成 HTML 报告
# -o: HTML 报告输出目录

# 生成 HTML 报告
jmeter -n -t test_plan.jmx -l result.jtl -e -o ./report

# 传递参数
jmeter -n -t test_plan.jmx -l result.jtl \
    -Jthreads=100 \
    -Jrampup=10 \
    -Jduration=300 \
    -Jhost=192.168.1.100

# 在测试计划中使用参数
# 线程数：${__P(threads,10)}
# Ramp-Up：${__P(rampup,5)}
# 持续时间：${__P(duration,60)}
# 服务器：${__P(host,localhost)}

# 指定 JVM 参数
JVM_ARGS="-Xms2g -Xmx4g" jmeter -n -t test_plan.jmx -l result.jtl

# Windows 批处理脚本
@echo off
set JMETER_HOME=C:\Tools\apache-jmeter-5.5
set TEST_PLAN=C:\test\api_test.jmx
set RESULT_FILE=C:\test\result_%date:~0,4%%date:~5,2%%date:~8,2%.jtl
set REPORT_DIR=C:\test\report_%date:~0,4%%date:~5,2%%date:~8,2%

%JMETER_HOME%\bin\jmeter -n -t %TEST_PLAN% -l %RESULT_FILE% -e -o %REPORT_DIR%

echo Test completed. Report: %REPORT_DIR%
pause
```

```bash
# Linux Shell 脚本
#!/bin/bash

JMETER_HOME=/opt/apache-jmeter-5.5
TEST_PLAN=/home/test/api_test.jmx
RESULT_DIR=/home/test/results
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
RESULT_FILE=${RESULT_DIR}/result_${TIMESTAMP}.jtl
REPORT_DIR=${RESULT_DIR}/report_${TIMESTAMP}

# 创建结果目录
mkdir -p ${RESULT_DIR}

# 设置 JVM 参数
export JVM_ARGS="-Xms2g -Xmx4g -XX:+UseG1GC"

# 执行测试
${JMETER_HOME}/bin/jmeter -n \
    -t ${TEST_PLAN} \
    -l ${RESULT_FILE} \
    -e -o ${REPORT_DIR} \
    -Jthreads=${1:-100} \
    -Jrampup=${2:-10} \
    -Jduration=${3:-300}

echo "Test completed!"
echo "Result file: ${RESULT_FILE}"
echo "Report directory: ${REPORT_DIR}"
```


---

## 7. 分布式压测

### 7.1 分布式架构

```
┌─────────────────────────────────────────────────────────────────────┐
│                        JMeter 分布式架构                             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│                    ┌─────────────────────┐                          │
│                    │   Master (控制机)    │                          │
│                    │   运行 JMeter GUI    │                          │
│                    │   或命令行           │                          │
│                    └──────────┬──────────┘                          │
│                               │                                      │
│              ┌────────────────┼────────────────┐                    │
│              │                │                │                    │
│              ▼                ▼                ▼                    │
│     ┌────────────────┐ ┌────────────────┐ ┌────────────────┐       │
│     │  Slave 1       │ │  Slave 2       │ │  Slave 3       │       │
│     │  (压力机 1)     │ │  (压力机 2)     │ │  (压力机 3)     │       │
│     │  jmeter-server │ │  jmeter-server │ │  jmeter-server │       │
│     └────────┬───────┘ └────────┬───────┘ └────────┬───────┘       │
│              │                  │                  │                │
│              └──────────────────┼──────────────────┘                │
│                                 │                                    │
│                                 ▼                                    │
│                    ┌─────────────────────┐                          │
│                    │   被测系统           │                          │
│                    │   (Spring Boot)     │                          │
│                    └─────────────────────┘                          │
│                                                                      │
│  说明：                                                              │
│  - Master 负责分发测试计划和收集结果                                  │
│  - Slave 负责实际执行测试                                            │
│  - 总并发数 = 测试计划线程数 × Slave 数量                            │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 7.2 配置步骤

#### 7.2.1 Slave 配置

```bash
# 1. 在每台 Slave 机器上安装 JMeter（版本必须一致）

# 2. 修改 jmeter.properties
# bin/jmeter.properties

# 设置 RMI 端口（默认 1099）
server_port=1099

# 设置 SSL（生产环境建议开启）
server.rmi.ssl.disable=true

# 3. 启动 jmeter-server
# Windows
jmeter-server.bat

# Linux
./jmeter-server

# 或指定端口启动
./jmeter-server -Dserver_port=1099

# 4. 检查是否启动成功
# 应该看到类似输出：
# Created remote object: UnicastServerRef2 [liveRef: [endpoint:[192.168.1.101:1099]...
```

#### 7.2.2 Master 配置

```bash
# 1. 修改 jmeter.properties
# bin/jmeter.properties

# 配置 Slave 地址列表
remote_hosts=192.168.1.101:1099,192.168.1.102:1099,192.168.1.103:1099

# 或者在命令行指定
jmeter -n -t test.jmx -R 192.168.1.101,192.168.1.102,192.168.1.103

# 2. 禁用 SSL（如果 Slave 也禁用了）
server.rmi.ssl.disable=true

# 3. 设置 RMI 本地主机（多网卡时需要）
# 在 Slave 上设置
java.rmi.server.hostname=192.168.1.101
```

#### 7.2.3 执行分布式测试

```bash
# GUI 模式
# 运行 → 远程启动 → 选择 Slave
# 或 运行 → 远程全部启动

# 命令行模式
# 启动所有配置的 Slave
jmeter -n -t test.jmx -r -l result.jtl

# 启动指定的 Slave
jmeter -n -t test.jmx -R 192.168.1.101,192.168.1.102 -l result.jtl

# 生成报告
jmeter -n -t test.jmx -r -l result.jtl -e -o ./report
```

### 7.3 分布式测试注意事项

```
┌─────────────────────────────────────────────────────────────────────┐
│ 分布式测试注意事项                                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 1. 版本一致性                                                        │
│    - 所有机器的 JMeter 版本必须相同                                   │
│    - JDK 版本也建议保持一致                                          │
│                                                                      │
│ 2. 文件路径                                                          │
│    - CSV 文件需要在每台 Slave 上存在                                  │
│    - 使用相对路径或确保路径一致                                       │
│    - 或者将 CSV 数据嵌入测试计划                                      │
│                                                                      │
│ 3. 网络配置                                                          │
│    - 确保 Master 和 Slave 之间网络通畅                               │
│    - 开放 RMI 端口（默认 1099）                                      │
│    - 防火墙配置                                                      │
│                                                                      │
│ 4. 时间同步                                                          │
│    - 所有机器时间必须同步（使用 NTP）                                 │
│    - 否则结果时间戳会混乱                                            │
│                                                                      │
│ 5. 资源监控                                                          │
│    - 监控每台 Slave 的 CPU、内存、网络                               │
│    - 避免 Slave 成为瓶颈                                             │
│                                                                      │
│ 6. 结果收集                                                          │
│    - 结果会汇总到 Master                                             │
│    - 大量数据时考虑使用 Backend Listener                             │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 7.4 Docker 部署分布式 JMeter

```yaml
# docker-compose.yml
version: '3.8'

services:
  jmeter-master:
    image: justb4/jmeter:5.5
    container_name: jmeter-master
    volumes:
      - ./test:/test
      - ./results:/results
    command: >
      -n -t /test/test_plan.jmx 
      -R jmeter-slave1,jmeter-slave2 
      -l /results/result.jtl
      -e -o /results/report
    depends_on:
      - jmeter-slave1
      - jmeter-slave2
    networks:
      - jmeter-network

  jmeter-slave1:
    image: justb4/jmeter:5.5
    container_name: jmeter-slave1
    entrypoint: /entrypoint.sh -s
    networks:
      - jmeter-network

  jmeter-slave2:
    image: justb4/jmeter:5.5
    container_name: jmeter-slave2
    entrypoint: /entrypoint.sh -s
    networks:
      - jmeter-network

networks:
  jmeter-network:
    driver: bridge
```

```bash
# 启动分布式测试
docker-compose up

# 查看结果
ls -la ./results/
```

---

## 8. 性能指标分析

### 8.1 核心性能指标

```
┌─────────────────────────────────────────────────────────────────────┐
│                        核心性能指标                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  1. 响应时间 (Response Time)                                         │
│     ├── 平均响应时间 (Average)：所有请求响应时间的平均值              │
│     ├── 中位数 (Median/50%)：50% 请求的响应时间                      │
│     ├── 90% Line：90% 请求的响应时间                                 │
│     ├── 95% Line：95% 请求的响应时间                                 │
│     ├── 99% Line：99% 请求的响应时间                                 │
│     ├── 最小值 (Min)：最快的响应时间                                 │
│     └── 最大值 (Max)：最慢的响应时间                                 │
│                                                                      │
│  2. 吞吐量 (Throughput)                                              │
│     └── 单位时间内处理的请求数（通常是 TPS 或 QPS）                   │
│     └── TPS = 总请求数 / 总时间                                      │
│                                                                      │
│  3. 错误率 (Error Rate)                                              │
│     └── 失败请求数 / 总请求数 × 100%                                 │
│                                                                      │
│  4. 并发数 (Concurrent Users)                                        │
│     └── 同时在线的用户数                                             │
│                                                                      │
│  5. 网络吞吐量 (Network Throughput)                                  │
│     └── 单位时间内传输的数据量（KB/s 或 MB/s）                       │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 8.2 聚合报告解读

```
┌─────────────────────────────────────────────────────────────────────┐
│ 聚合报告 (Aggregate Report)                                          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ Label    | # Samples | Average | Median | 90% | 95% | 99% | Min | Max│
│ ─────────┼───────────┼─────────┼────────┼─────┼─────┼─────┼─────┼────│
│ 登录     | 1000      | 125     | 98     | 210 | 280 | 450 | 45  | 890│
│ 查询用户 | 10000     | 45      | 38     | 78  | 95  | 150 | 12  | 320│
│ 创建用户 | 1000      | 180     | 150    | 320 | 410 | 580 | 65  | 950│
│ 总计     | 12000     | 68      | 52     | 125 | 180 | 350 | 12  | 950│
│                                                                      │
│ Label    | Error % | Throughput | KB/sec                             │
│ ─────────┼─────────┼────────────┼────────                            │
│ 登录     | 0.00%   | 8.0/sec    | 12.5                               │
│ 查询用户 | 0.10%   | 80.0/sec   | 45.2                               │
│ 创建用户 | 0.50%   | 8.0/sec    | 15.8                               │
│ 总计     | 0.15%   | 96.0/sec   | 73.5                               │
│                                                                      │
│ 指标说明：                                                            │
│ - # Samples：样本数（请求总数）                                       │
│ - Average：平均响应时间（毫秒）                                       │
│ - Median：中位数响应时间                                              │
│ - 90%/95%/99%：百分位响应时间                                        │
│ - Error %：错误率                                                    │
│ - Throughput：吞吐量（每秒请求数）                                    │
│ - KB/sec：每秒传输数据量                                             │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 8.3 性能指标参考标准

```
┌─────────────────────────────────────────────────────────────────────┐
│ 性能指标参考标准                                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 响应时间标准（Web 应用）：                                            │
│ ┌─────────────────┬─────────────────────────────────────────────┐   │
│ │ 响应时间         │ 用户体验                                    │   │
│ ├─────────────────┼─────────────────────────────────────────────┤   │
│ │ < 200ms         │ 优秀，用户感觉即时响应                       │   │
│ │ 200ms - 1s      │ 良好，用户感觉系统在工作                     │   │
│ │ 1s - 3s         │ 可接受，用户开始感到等待                     │   │
│ │ 3s - 10s        │ 较差，用户可能放弃                          │   │
│ │ > 10s           │ 不可接受，用户流失                          │   │
│ └─────────────────┴─────────────────────────────────────────────┘   │
│                                                                      │
│ 错误率标准：                                                          │
│ ┌─────────────────┬─────────────────────────────────────────────┐   │
│ │ 错误率           │ 评价                                        │   │
│ ├─────────────────┼─────────────────────────────────────────────┤   │
│ │ < 0.1%          │ 优秀                                        │   │
│ │ 0.1% - 1%       │ 良好                                        │   │
│ │ 1% - 5%         │ 需要关注                                    │   │
│ │ > 5%            │ 严重问题，需要立即处理                       │   │
│ └─────────────────┴─────────────────────────────────────────────┘   │
│                                                                      │
│ 吞吐量评估：                                                          │
│ - 需要根据业务需求确定                                               │
│ - 一般 Web 应用：100-1000 TPS                                        │
│ - 高并发应用：1000-10000+ TPS                                        │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 8.4 性能拐点分析

```
响应时间 vs 并发用户数

响应时间(ms)
    │
800 │                                    ╱
    │                                  ╱
600 │                               ╱
    │                            ╱
400 │                        ╱
    │                    ╱
200 │        ────────────  ← 性能拐点
    │    ╱
100 │╱
    └────────────────────────────────────────
        50   100  150  200  250  300  350  并发用户数

分析：
- 0-150 用户：响应时间稳定，系统正常
- 150 用户：性能拐点，响应时间开始上升
- 150-300 用户：响应时间快速上升
- 300+ 用户：系统可能崩溃

结论：系统最佳并发数约 150，最大承载约 300
```

```
吞吐量 vs 并发用户数

吞吐量(TPS)
    │
500 │            ────────────────────
    │        ╱                        ╲
400 │      ╱                            ╲
    │    ╱                                ╲
300 │  ╱                                    ╲
    │╱
200 │
    │
100 │
    └────────────────────────────────────────
        50   100  150  200  250  300  350  并发用户数

分析：
- 吞吐量随并发数增加而增加
- 达到峰值后开始下降（资源竞争）
- 最大吞吐量约 500 TPS，对应并发数 150-200
```


---

## 9. 最佳实践

### 9.1 测试计划设计原则

```
┌─────────────────────────────────────────────────────────────────────┐
│ 测试计划设计原则                                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 1. 模块化设计                                                        │
│    - 使用测试片段（Test Fragment）复用公共逻辑                        │
│    - 使用模块控制器（Module Controller）引用片段                      │
│    - 将登录、认证等公共操作抽取为独立模块                             │
│                                                                      │
│ 2. 参数化                                                            │
│    - 使用 CSV 文件管理测试数据                                        │
│    - 使用用户定义变量管理环境配置                                     │
│    - 使用属性（Properties）传递命令行参数                             │
│                                                                      │
│ 3. 关联处理                                                          │
│    - 正确提取动态数据（token、session、id 等）                        │
│    - 使用 Debug Sampler 验证变量值                                   │
│    - 处理好请求间的依赖关系                                          │
│                                                                      │
│ 4. 断言验证                                                          │
│    - 每个请求都应该有断言                                            │
│    - 验证响应码、响应内容、业务数据                                   │
│    - 避免过于复杂的断言影响性能                                       │
│                                                                      │
│ 5. 错误处理                                                          │
│    - 使用 If Controller 处理异常情况                                 │
│    - 记录错误信息便于排查                                            │
│    - 考虑重试机制                                                    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 9.2 性能测试流程

```
┌─────────────────────────────────────────────────────────────────────┐
│ 性能测试标准流程                                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ┌─────────────┐                                                    │
│  │ 1. 需求分析  │ → 确定测试目标、性能指标、测试范围                  │
│  └──────┬──────┘                                                    │
│         ▼                                                           │
│  ┌─────────────┐                                                    │
│  │ 2. 环境准备  │ → 搭建测试环境、准备测试数据、配置监控              │
│  └──────┬──────┘                                                    │
│         ▼                                                           │
│  ┌─────────────┐                                                    │
│  │ 3. 脚本开发  │ → 录制/编写脚本、参数化、关联、断言                 │
│  └──────┬──────┘                                                    │
│         ▼                                                           │
│  ┌─────────────┐                                                    │
│  │ 4. 脚本调试  │ → 单用户调试、小规模验证、修复问题                  │
│  └──────┬──────┘                                                    │
│         ▼                                                           │
│  ┌─────────────┐                                                    │
│  │ 5. 执行测试  │ → 基准测试、负载测试、压力测试、稳定性测试          │
│  └──────┬──────┘                                                    │
│         ▼                                                           │
│  ┌─────────────┐                                                    │
│  │ 6. 结果分析  │ → 分析指标、定位瓶颈、生成报告                      │
│  └──────┬──────┘                                                    │
│         ▼                                                           │
│  ┌─────────────┐                                                    │
│  │ 7. 优化验证  │ → 优化系统、重新测试、对比结果                      │
│  └─────────────┘                                                    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 9.3 JMeter 性能优化

```
┌─────────────────────────────────────────────────────────────────────┐
│ JMeter 自身性能优化                                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 1. 使用命令行模式                                                    │
│    - GUI 模式仅用于调试                                              │
│    - 正式测试使用 -n 参数                                            │
│                                                                      │
│ 2. 减少监听器                                                        │
│    - 移除不必要的监听器                                              │
│    - 使用 Simple Data Writer 替代 View Results Tree                  │
│    - 正式测试时禁用 View Results Tree                                │
│                                                                      │
│ 3. 优化结果收集                                                      │
│    - 只保存必要的数据                                                │
│    - 使用 CSV 格式而非 XML                                           │
│    - 配置 jmeter.properties:                                         │
│      jmeter.save.saveservice.output_format=csv                       │
│      jmeter.save.saveservice.response_data=false                     │
│      jmeter.save.saveservice.samplerData=false                       │
│                                                                      │
│ 4. 增加 JVM 内存                                                     │
│    - 修改 jmeter.bat/jmeter.sh                                       │
│    - HEAP="-Xms2g -Xmx4g"                                            │
│                                                                      │
│ 5. 使用 Groovy 替代 BeanShell                                        │
│    - Groovy 性能比 BeanShell 好 10 倍                                │
│    - 勾选"Cache compiled script"                                     │
│                                                                      │
│ 6. 合理设置超时                                                      │
│    - 连接超时：5000ms                                                │
│    - 响应超时：30000ms                                               │
│                                                                      │
│ 7. 使用 HTTP4 实现                                                   │
│    - 在 HTTP 请求默认值中选择 HttpClient4                            │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 9.4 Spring Boot 应用优化建议

```java
// 1. 连接池配置 (application.yml)
spring:
  datasource:
    hikari:
      minimum-idle: 10
      maximum-pool-size: 50
      idle-timeout: 30000
      connection-timeout: 30000
      max-lifetime: 1800000

// 2. Tomcat 线程池配置
server:
  tomcat:
    threads:
      max: 200
      min-spare: 20
    accept-count: 100
    max-connections: 10000

// 3. Redis 连接池配置
spring:
  redis:
    lettuce:
      pool:
        max-active: 50
        max-idle: 20
        min-idle: 5
        max-wait: 3000ms

// 4. 开启 GZIP 压缩
server:
  compression:
    enabled: true
    mime-types: application/json,application/xml,text/html,text/plain
    min-response-size: 1024

// 5. JVM 参数优化
java -Xms2g -Xmx2g \
     -XX:+UseG1GC \
     -XX:MaxGCPauseMillis=200 \
     -XX:+HeapDumpOnOutOfMemoryError \
     -XX:HeapDumpPath=/var/log/app/ \
     -jar app.jar
```

### 9.5 测试报告模板

```markdown
# 性能测试报告

## 1. 测试概述
- 测试目的：验证系统在预期负载下的性能表现
- 测试时间：2024-01-15 10:00 - 12:00
- 测试环境：生产环境镜像
- 测试工具：Apache JMeter 5.5

## 2. 测试环境
### 2.1 服务器配置
| 服务器 | CPU | 内存 | 磁盘 | 操作系统 |
|--------|-----|------|------|----------|
| 应用服务器 | 8核 | 16GB | 200GB SSD | CentOS 7.9 |
| 数据库服务器 | 16核 | 32GB | 500GB SSD | CentOS 7.9 |

### 2.2 软件版本
- JDK: 1.8.0_301
- Spring Boot: 2.7.18
- MySQL: 8.0.28
- Redis: 6.2.6

## 3. 测试场景
| 场景 | 并发用户 | 持续时间 | 目标 TPS |
|------|----------|----------|----------|
| 基准测试 | 10 | 5分钟 | - |
| 负载测试 | 100 | 30分钟 | 500 |
| 压力测试 | 500 | 10分钟 | - |
| 稳定性测试 | 100 | 2小时 | 500 |

## 4. 测试结果
### 4.1 负载测试结果
| 接口 | 样本数 | 平均响应时间 | 90% | 99% | 错误率 | TPS |
|------|--------|--------------|-----|-----|--------|-----|
| 登录 | 10000 | 125ms | 210ms | 450ms | 0.00% | 8.0 |
| 查询用户 | 100000 | 45ms | 78ms | 150ms | 0.10% | 80.0 |
| 创建用户 | 10000 | 180ms | 320ms | 580ms | 0.50% | 8.0 |

### 4.2 资源使用情况
| 指标 | 平均值 | 最大值 |
|------|--------|--------|
| CPU 使用率 | 65% | 85% |
| 内存使用率 | 70% | 78% |
| 数据库连接数 | 35 | 48 |

## 5. 问题与建议
### 5.1 发现的问题
1. 创建用户接口错误率较高（0.5%）
2. 高并发时数据库连接数接近上限

### 5.2 优化建议
1. 增加数据库连接池大小
2. 优化创建用户接口的事务处理
3. 考虑增加缓存层

## 6. 结论
系统在 100 并发用户下表现稳定，满足预期性能指标。
建议在上线前优化数据库连接池配置。
```


---

## 10. 常见错误与解决

### 10.1 连接相关错误

#### 10.1.1 Connection refused

```
┌─────────────────────────────────────────────────────────────────────┐
│ 错误：java.net.ConnectException: Connection refused                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 原因：                                                               │
│ 1. 目标服务器未启动                                                   │
│ 2. 端口号错误                                                        │
│ 3. 防火墙阻止连接                                                    │
│ 4. 服务器地址错误                                                    │
│                                                                      │
│ 解决方案：                                                            │
│ 1. 确认服务器已启动                                                   │
│    curl http://localhost:8080/actuator/health                        │
│                                                                      │
│ 2. 检查端口是否正确                                                   │
│    netstat -tlnp | grep 8080                                         │
│                                                                      │
│ 3. 检查防火墙设置                                                     │
│    # Linux                                                           │
│    firewall-cmd --list-ports                                         │
│    firewall-cmd --add-port=8080/tcp --permanent                      │
│                                                                      │
│ 4. 使用 telnet 测试连接                                              │
│    telnet localhost 8080                                             │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 10.1.2 Connection timed out

```
┌─────────────────────────────────────────────────────────────────────┐
│ 错误：java.net.SocketTimeoutException: connect timed out             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 原因：                                                               │
│ 1. 网络延迟过高                                                      │
│ 2. 服务器负载过高，无法响应                                          │
│ 3. 连接超时设置过短                                                  │
│                                                                      │
│ 解决方案：                                                            │
│ 1. 增加连接超时时间                                                   │
│    HTTP 请求 → 高级 → 连接超时：10000                                │
│                                                                      │
│ 2. 检查网络连通性                                                     │
│    ping target-server                                                │
│                                                                      │
│ 3. 检查服务器负载                                                     │
│    top / htop                                                        │
│                                                                      │
│ 4. 减少并发数，逐步增加                                              │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 10.1.3 Too many open files

```
┌─────────────────────────────────────────────────────────────────────┐
│ 错误：java.net.SocketException: Too many open files                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 原因：                                                               │
│ 系统文件描述符限制过低                                               │
│                                                                      │
│ 解决方案：                                                            │
│ 1. 查看当前限制                                                       │
│    ulimit -n                                                         │
│                                                                      │
│ 2. 临时修改                                                          │
│    ulimit -n 65535                                                   │
│                                                                      │
│ 3. 永久修改 /etc/security/limits.conf                                │
│    * soft nofile 65535                                               │
│    * hard nofile 65535                                               │
│                                                                      │
│ 4. 修改 /etc/sysctl.conf                                             │
│    fs.file-max = 65535                                               │
│    sysctl -p                                                         │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 10.2 内存相关错误

#### 10.2.1 OutOfMemoryError

```
┌─────────────────────────────────────────────────────────────────────┐
│ 错误：java.lang.OutOfMemoryError: Java heap space                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 原因：                                                               │
│ 1. JMeter 堆内存不足                                                 │
│ 2. 测试数据量过大                                                    │
│ 3. 监听器收集了过多数据                                              │
│                                                                      │
│ 解决方案：                                                            │
│ 1. 增加 JMeter 堆内存                                                │
│    # 修改 jmeter.bat 或 jmeter.sh                                    │
│    HEAP="-Xms2g -Xmx4g"                                              │
│                                                                      │
│ 2. 使用命令行模式                                                     │
│    jmeter -n -t test.jmx -l result.jtl                               │
│                                                                      │
│ 3. 减少监听器                                                        │
│    - 移除 View Results Tree                                          │
│    - 使用 Simple Data Writer                                         │
│                                                                      │
│ 4. 配置结果文件只保存必要数据                                        │
│    jmeter.save.saveservice.response_data=false                       │
│    jmeter.save.saveservice.samplerData=false                         │
│                                                                      │
│ 5. 分布式测试分担压力                                                │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 10.2.2 GC overhead limit exceeded

```
┌─────────────────────────────────────────────────────────────────────┐
│ 错误：java.lang.OutOfMemoryError: GC overhead limit exceeded         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 原因：                                                               │
│ JVM 花费过多时间进行垃圾回收                                         │
│                                                                      │
│ 解决方案：                                                            │
│ 1. 增加堆内存                                                        │
│    HEAP="-Xms4g -Xmx8g"                                              │
│                                                                      │
│ 2. 使用 G1 垃圾收集器                                                │
│    HEAP="-Xms4g -Xmx8g -XX:+UseG1GC"                                 │
│                                                                      │
│ 3. 减少测试数据量                                                    │
│                                                                      │
│ 4. 清理不必要的变量                                                  │
│    vars.remove("largeData");                                         │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 10.3 脚本相关错误

#### 10.3.1 变量未定义

```
┌─────────────────────────────────────────────────────────────────────┐
│ 错误：变量 ${token} 显示为字面值，未被替换                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 原因：                                                               │
│ 1. 变量名拼写错误                                                    │
│ 2. 提取器未正确配置                                                  │
│ 3. 提取器作用域问题                                                  │
│ 4. 前置请求失败                                                      │
│                                                                      │
│ 解决方案：                                                            │
│ 1. 添加 Debug Sampler 查看变量值                                     │
│    右键 → 添加 → 取样器 → Debug Sampler                              │
│                                                                      │
│ 2. 检查提取器配置                                                    │
│    - JSON Path 是否正确                                              │
│    - 变量名是否一致                                                  │
│    - Match No. 是否正确                                              │
│                                                                      │
│ 3. 检查提取器位置                                                    │
│    - 确保在正确的请求下                                              │
│    - 检查作用域                                                      │
│                                                                      │
│ 4. 查看前置请求的响应                                                │
│    - 确认响应中包含需要提取的数据                                    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 10.3.2 JSON 提取失败

```
┌─────────────────────────────────────────────────────────────────────┐
│ 错误：JSON 提取器返回默认值或空值                                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 原因：                                                               │
│ 1. JSON Path 表达式错误                                              │
│ 2. 响应不是有效的 JSON                                               │
│ 3. 响应结构与预期不符                                                │
│                                                                      │
│ 解决方案：                                                            │
│ 1. 使用在线工具验证 JSON Path                                        │
│    https://jsonpath.com/                                             │
│                                                                      │
│ 2. 查看实际响应内容                                                  │
│    在 View Results Tree 中查看 Response Data                         │
│                                                                      │
│ 3. 常见 JSON Path 错误：                                             │
│    错误：$.data.token      （data 可能是数组）                       │
│    正确：$.data[0].token                                             │
│                                                                      │
│    错误：$data.token       （缺少点号）                              │
│    正确：$.data.token                                                │
│                                                                      │
│ 4. 处理嵌套 JSON：                                                   │
│    $.data.user.profile.name                                          │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 10.3.3 中文乱码

```
┌─────────────────────────────────────────────────────────────────────┐
│ 错误：响应中文显示为乱码                                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 解决方案：                                                            │
│                                                                      │
│ 1. 设置 JMeter 编码                                                  │
│    # jmeter.properties                                               │
│    sampleresult.default.encoding=UTF-8                               │
│                                                                      │
│ 2. 添加 HTTP 信息头                                                  │
│    Content-Type: application/json;charset=UTF-8                      │
│                                                                      │
│ 3. 后置处理器转码                                                    │
│    // BeanShell/Groovy                                               │
│    String response = prev.getResponseDataAsString();                 │
│    response = new String(response.getBytes("ISO-8859-1"), "UTF-8");  │
│    prev.setResponseData(response, "UTF-8");                          │
│                                                                      │
│ 4. CSV 文件编码                                                      │
│    - 确保 CSV 文件保存为 UTF-8 编码                                  │
│    - CSV 数据文件设置中指定编码：UTF-8                               │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 10.4 分布式测试错误

#### 10.4.1 无法连接到 Slave

```
┌─────────────────────────────────────────────────────────────────────┐
│ 错误：Cannot connect to remote host                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 原因：                                                               │
│ 1. Slave 未启动                                                      │
│ 2. 防火墙阻止                                                        │
│ 3. RMI 端口未开放                                                    │
│ 4. IP 地址配置错误                                                   │
│                                                                      │
│ 解决方案：                                                            │
│ 1. 确认 Slave 已启动                                                 │
│    ps aux | grep jmeter-server                                       │
│                                                                      │
│ 2. 检查防火墙                                                        │
│    firewall-cmd --add-port=1099/tcp --permanent                      │
│    firewall-cmd --reload                                             │
│                                                                      │
│ 3. 测试端口连通性                                                    │
│    telnet slave-ip 1099                                              │
│                                                                      │
│ 4. 检查 RMI 配置                                                     │
│    # 在 Slave 上设置                                                 │
│    java.rmi.server.hostname=实际IP地址                               │
│                                                                      │
│ 5. 禁用 SSL（测试环境）                                              │
│    server.rmi.ssl.disable=true                                       │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 10.4.2 Slave 上找不到文件

```
┌─────────────────────────────────────────────────────────────────────┐
│ 错误：FileNotFoundException on Slave                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 原因：                                                               │
│ CSV 文件或其他资源文件在 Slave 上不存在                              │
│                                                                      │
│ 解决方案：                                                            │
│ 1. 将文件复制到所有 Slave                                            │
│    scp users.csv slave1:/opt/jmeter/data/                            │
│    scp users.csv slave2:/opt/jmeter/data/                            │
│                                                                      │
│ 2. 使用相对路径                                                      │
│    将文件放在 JMeter bin 目录下                                      │
│    CSV 文件路径：users.csv                                           │
│                                                                      │
│ 3. 使用网络共享                                                      │
│    NFS 或 SMB 共享目录                                               │
│                                                                      │
│ 4. 将数据嵌入测试计划                                                │
│    使用用户定义的变量或 JSR223 脚本                                  │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 10.5 常见错误速查表

| 错误 | 可能原因 | 解决方案 |
|------|---------|---------|
| Connection refused | 服务未启动/端口错误 | 检查服务状态和端口 |
| Connection timed out | 网络问题/服务器过载 | 增加超时/检查网络 |
| Too many open files | 文件描述符限制 | 增加 ulimit |
| OutOfMemoryError | 堆内存不足 | 增加 -Xmx |
| 变量未替换 | 提取器配置错误 | 使用 Debug Sampler |
| JSON 提取失败 | JSON Path 错误 | 验证 JSON Path |
| 中文乱码 | 编码问题 | 设置 UTF-8 |
| 401 Unauthorized | Token 失效/未传递 | 检查认证头 |
| 500 Internal Error | 服务端错误 | 查看服务端日志 |
| 响应时间过长 | 服务器性能问题 | 分析服务端瓶颈 |

---

## 总结

JMeter 是一款功能强大的性能测试工具，掌握它需要理解以下核心内容：

**基础知识**：
- 测试计划结构和元件作用域
- HTTP 请求配置（GET/POST/文件上传）
- 断言和定时器的使用

**进阶技能**：
- 参数化（CSV、函数、变量）
- 关联（JSON/正则提取器）
- 逻辑控制器的使用
- Groovy 脚本编写

**实战能力**：
- Spring Boot 接口测试
- 分布式压测部署
- 性能指标分析
- 问题排查和优化

**最佳实践**：
- 使用命令行模式执行测试
- 合理配置 JVM 参数
- 模块化设计测试计划
- 完善的测试报告

---

> 📚 参考资料
> - [Apache JMeter 官方文档](https://jmeter.apache.org/usermanual/index.html)
> - [JMeter Plugins](https://jmeter-plugins.org/)
> - [JMeter Best Practices](https://jmeter.apache.org/usermanual/best-practices.html)
