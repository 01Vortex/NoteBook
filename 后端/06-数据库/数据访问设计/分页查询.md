# 分页查询完全指南

> 基于 Java 8 + Spring Boot 2.7.18 的分页查询最佳实践
> 本笔记涵盖分页原理、多种实现方式、性能优化及常见问题解决方案

---

## 目录

1. [分页查询概述](#1-分页查询概述)
2. [基础分页实现](#2-基础分页实现)
3. [Spring Data JPA 分页](#3-spring-data-jpa-分页)
4. [MyBatis 分页](#4-mybatis-分页)
5. [MyBatis-Plus 分页](#5-mybatis-plus-分页)
6. [深度分页优化](#6-深度分页优化)
7. [游标分页](#7-游标分页)
8. [分页封装与统一响应](#8-分页封装与统一响应)
9. [前后端分页交互](#9-前后端分页交互)
10. [常见错误与解决方案](#10-常见错误与解决方案)

---

## 1. 分页查询概述

### 1.1 什么是分页查询？

分页查询是将大量数据分成多个"页"来展示的技术。想象一下你在看一本 1000 页的书，你不会一次性看完所有页，而是一页一页地翻看。数据库分页也是同样的道理。

**通俗理解**：假设数据库有 10000 条用户数据，如果一次性全部返回给前端，不仅网络传输慢，前端渲染也会卡顿。分页就是每次只返回一部分数据（比如 20 条），用户需要更多数据时再请求下一页。

```
┌─────────────────────────────────────────────────────────────────────┐
│                    分页查询示意图                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  数据库中的数据（共 100 条）                                         │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │ 1  2  3  4  5  6  7  8  9  10 │ 11 12 13 ... │ 91 92 ... 100 │   │
│  └──────────────────────────────────────────────────────────────┘   │
│       ↓ 第1页(10条)                ↓ 第2页        ↓ 第10页          │
│                                                                      │
│  前端请求: page=1, size=10                                          │
│  后端返回: 第1-10条数据 + 总条数100 + 总页数10                       │
│                                                                      │
│  前端请求: page=2, size=10                                          │
│  后端返回: 第11-20条数据 + 总条数100 + 总页数10                      │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 1.2 分页的核心参数

```
┌─────────────────────────────────────────────────────────────────────┐
│ 分页核心参数                                                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 请求参数（前端传给后端）:                                            │
│ • page/pageNum    - 当前页码（从1开始或从0开始，需统一）             │
│ • size/pageSize   - 每页条数                                        │
│ • sort            - 排序字段（可选）                                │
│ • order           - 排序方向 ASC/DESC（可选）                       │
│                                                                      │
│ 响应参数（后端返回给前端）:                                          │
│ • list/records    - 当前页数据列表                                  │
│ • total           - 总记录数                                        │
│ • pages/totalPages- 总页数                                          │
│ • current/pageNum - 当前页码                                        │
│ • size/pageSize   - 每页条数                                        │
│ • hasNext         - 是否有下一页（可选）                            │
│ • hasPrevious     - 是否有上一页（可选）                            │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 1.3 分页的 SQL 原理

```sql
-- MySQL 分页语法
SELECT * FROM user ORDER BY id LIMIT offset, size;
-- 或
SELECT * FROM user ORDER BY id LIMIT size OFFSET offset;

-- 参数计算
-- offset = (page - 1) * size
-- 例如：第3页，每页10条
-- offset = (3 - 1) * 10 = 20
-- SQL: SELECT * FROM user ORDER BY id LIMIT 20, 10;

-- Oracle 分页（12c 之前）
SELECT * FROM (
    SELECT t.*, ROWNUM rn FROM (
        SELECT * FROM user ORDER BY id
    ) t WHERE ROWNUM <= 30  -- offset + size
) WHERE rn > 20;            -- offset

-- Oracle 12c+ 分页
SELECT * FROM user ORDER BY id 
OFFSET 20 ROWS FETCH NEXT 10 ROWS ONLY;

-- PostgreSQL 分页
SELECT * FROM user ORDER BY id LIMIT 10 OFFSET 20;

-- SQL Server 分页（2012+）
SELECT * FROM user ORDER BY id 
OFFSET 20 ROWS FETCH NEXT 10 ROWS ONLY;
```

### 1.4 为什么需要分页？

```
┌─────────────────────────────────────────────────────────────────────┐
│ 分页的必要性                                                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 1. 性能考虑                                                          │
│    • 减少数据库查询压力                                              │
│    • 减少网络传输数据量                                              │
│    • 减少服务器内存占用                                              │
│    • 加快前端渲染速度                                                │
│                                                                      │
│ 2. 用户体验                                                          │
│    • 快速展示首屏数据                                                │
│    • 避免页面卡顿                                                    │
│    • 便于数据浏览和定位                                              │
│                                                                      │
│ 3. 资源节约                                                          │
│    • 用户可能只看前几页                                              │
│    • 按需加载，避免浪费                                              │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 2. 基础分页实现

### 2.1 原生 JDBC 分页

这是最基础的分页实现方式，帮助理解分页原理。

```java
/**
 * 分页查询结果封装
 */
@Data
public class PageResult<T> {
    private List<T> list;       // 数据列表
    private long total;         // 总记录数
    private int pages;          // 总页数
    private int pageNum;        // 当前页码
    private int pageSize;       // 每页条数
    
    public PageResult(List<T> list, long total, int pageNum, int pageSize) {
        this.list = list;
        this.total = total;
        this.pageNum = pageNum;
        this.pageSize = pageSize;
        this.pages = (int) Math.ceil((double) total / pageSize);
    }
    
    public boolean hasNext() {
        return pageNum < pages;
    }
    
    public boolean hasPrevious() {
        return pageNum > 1;
    }
}
```

```java
/**
 * 原生 JDBC 分页查询示例
 */
@Repository
public class UserDao {
    
    @Autowired
    private DataSource dataSource;
    
    /**
     * 分页查询用户
     * @param pageNum 页码（从1开始）
     * @param pageSize 每页条数
     * @return 分页结果
     */
    public PageResult<User> findByPage(int pageNum, int pageSize) {
        // 1. 参数校验
        if (pageNum < 1) pageNum = 1;
        if (pageSize < 1) pageSize = 10;
        if (pageSize > 100) pageSize = 100; // 限制最大条数，防止恶意请求
        
        // 2. 计算偏移量
        int offset = (pageNum - 1) * pageSize;
        
        List<User> list = new ArrayList<>();
        long total = 0;
        
        try (Connection conn = dataSource.getConnection()) {
            // 3. 查询总数
            String countSql = "SELECT COUNT(*) FROM user";
            try (PreparedStatement ps = conn.prepareStatement(countSql);
                 ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    total = rs.getLong(1);
                }
            }
            
            // 4. 查询分页数据
            String dataSql = "SELECT id, username, email, created_at FROM user ORDER BY id LIMIT ?, ?";
            try (PreparedStatement ps = conn.prepareStatement(dataSql)) {
                ps.setInt(1, offset);
                ps.setInt(2, pageSize);
                try (ResultSet rs = ps.executeQuery()) {
                    while (rs.next()) {
                        User user = new User();
                        user.setId(rs.getLong("id"));
                        user.setUsername(rs.getString("username"));
                        user.setEmail(rs.getString("email"));
                        user.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
                        list.add(user);
                    }
                }
            }
        } catch (SQLException e) {
            throw new RuntimeException("分页查询失败", e);
        }
        
        return new PageResult<>(list, total, pageNum, pageSize);
    }
}
```

### 2.2 JdbcTemplate 分页

Spring 的 JdbcTemplate 简化了 JDBC 操作。

```java
@Repository
public class UserRepository {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    /**
     * 使用 JdbcTemplate 分页查询
     */
    public PageResult<User> findByPage(int pageNum, int pageSize) {
        // 参数校验
        pageNum = Math.max(1, pageNum);
        pageSize = Math.min(Math.max(1, pageSize), 100);
        int offset = (pageNum - 1) * pageSize;
        
        // 查询总数
        String countSql = "SELECT COUNT(*) FROM user";
        Long total = jdbcTemplate.queryForObject(countSql, Long.class);
        
        // 查询数据
        String dataSql = "SELECT id, username, email, created_at FROM user ORDER BY id LIMIT ? OFFSET ?";
        List<User> list = jdbcTemplate.query(dataSql, new Object[]{pageSize, offset}, (rs, rowNum) -> {
            User user = new User();
            user.setId(rs.getLong("id"));
            user.setUsername(rs.getString("username"));
            user.setEmail(rs.getString("email"));
            user.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
            return user;
        });
        
        return new PageResult<>(list, total != null ? total : 0, pageNum, pageSize);
    }
    
    /**
     * 带条件的分页查询
     */
    public PageResult<User> findByCondition(String username, String email, int pageNum, int pageSize) {
        StringBuilder whereSql = new StringBuilder(" WHERE 1=1");
        List<Object> params = new ArrayList<>();
        
        // 动态拼接条件
        if (StringUtils.hasText(username)) {
            whereSql.append(" AND username LIKE ?");
            params.add("%" + username + "%");
        }
        if (StringUtils.hasText(email)) {
            whereSql.append(" AND email LIKE ?");
            params.add("%" + email + "%");
        }
        
        // 查询总数
        String countSql = "SELECT COUNT(*) FROM user" + whereSql;
        Long total = jdbcTemplate.queryForObject(countSql, Long.class, params.toArray());
        
        // 查询数据
        int offset = (pageNum - 1) * pageSize;
        params.add(pageSize);
        params.add(offset);
        String dataSql = "SELECT * FROM user" + whereSql + " ORDER BY id LIMIT ? OFFSET ?";
        List<User> list = jdbcTemplate.query(dataSql, params.toArray(), new BeanPropertyRowMapper<>(User.class));
        
        return new PageResult<>(list, total != null ? total : 0, pageNum, pageSize);
    }
}
```

---

## 3. Spring Data JPA 分页

Spring Data JPA 提供了开箱即用的分页支持，是最简单的分页实现方式。

### 3.1 基础配置

```xml
<!-- pom.xml -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <scope>runtime</scope>
</dependency>
```

```yaml
# application.yml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/demo?useSSL=false&serverTimezone=Asia/Shanghai
    username: root
    password: root
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        format_sql: true
```

### 3.2 实体类定义

```java
@Entity
@Table(name = "user")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, length = 50)
    private String username;
    
    @Column(nullable = false, length = 100)
    private String email;
    
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @PrePersist
    public void prePersist() {
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }
    
    @PreUpdate
    public void preUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
}
```

### 3.3 Repository 接口

```java
/**
 * 继承 JpaRepository 自动获得分页能力
 * 继承 JpaSpecificationExecutor 获得动态查询能力
 */
public interface UserRepository extends JpaRepository<User, Long>, JpaSpecificationExecutor<User> {
    
    // 方法名查询 + 分页
    Page<User> findByUsernameContaining(String username, Pageable pageable);
    
    // 多条件查询 + 分页
    Page<User> findByUsernameContainingAndEmailContaining(String username, String email, Pageable pageable);
    
    // @Query 注解 + 分页
    @Query("SELECT u FROM User u WHERE u.username LIKE %:keyword% OR u.email LIKE %:keyword%")
    Page<User> searchByKeyword(@Param("keyword") String keyword, Pageable pageable);
    
    // 原生 SQL + 分页（需要额外的 countQuery）
    @Query(value = "SELECT * FROM user WHERE username LIKE %:username%",
           countQuery = "SELECT COUNT(*) FROM user WHERE username LIKE %:username%",
           nativeQuery = true)
    Page<User> findByUsernameNative(@Param("username") String username, Pageable pageable);
}
```

### 3.4 Service 层

```java
@Service
@Transactional(readOnly = true)
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    /**
     * 基础分页查询
     * @param pageNum 页码（从1开始，内部转换为从0开始）
     * @param pageSize 每页条数
     * @return 分页结果
     */
    public Page<User> findByPage(int pageNum, int pageSize) {
        // JPA 的页码从 0 开始，所以需要 -1
        // PageRequest.of(page, size) 创建分页请求
        Pageable pageable = PageRequest.of(pageNum - 1, pageSize);
        return userRepository.findAll(pageable);
    }
    
    /**
     * 带排序的分页查询
     */
    public Page<User> findByPageWithSort(int pageNum, int pageSize, String sortField, String sortOrder) {
        Sort sort = "desc".equalsIgnoreCase(sortOrder) 
            ? Sort.by(sortField).descending() 
            : Sort.by(sortField).ascending();
        Pageable pageable = PageRequest.of(pageNum - 1, pageSize, sort);
        return userRepository.findAll(pageable);
    }
    
    /**
     * 多字段排序
     */
    public Page<User> findByPageWithMultiSort(int pageNum, int pageSize) {
        Sort sort = Sort.by(
            Sort.Order.desc("createdAt"),
            Sort.Order.asc("username")
        );
        Pageable pageable = PageRequest.of(pageNum - 1, pageSize, sort);
        return userRepository.findAll(pageable);
    }
    
    /**
     * 动态条件分页查询（使用 Specification）
     */
    public Page<User> findByCondition(UserQueryDTO query, int pageNum, int pageSize) {
        Specification<User> spec = (root, criteriaQuery, cb) -> {
            List<Predicate> predicates = new ArrayList<>();
            
            // 用户名模糊查询
            if (StringUtils.hasText(query.getUsername())) {
                predicates.add(cb.like(root.get("username"), "%" + query.getUsername() + "%"));
            }
            
            // 邮箱模糊查询
            if (StringUtils.hasText(query.getEmail())) {
                predicates.add(cb.like(root.get("email"), "%" + query.getEmail() + "%"));
            }
            
            // 时间范围查询
            if (query.getStartTime() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("createdAt"), query.getStartTime()));
            }
            if (query.getEndTime() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("createdAt"), query.getEndTime()));
            }
            
            return cb.and(predicates.toArray(new Predicate[0]));
        };
        
        Pageable pageable = PageRequest.of(pageNum - 1, pageSize, Sort.by("id").descending());
        return userRepository.findAll(spec, pageable);
    }
}
```

### 3.5 Controller 层

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    /**
     * 基础分页查询
     * GET /api/users?pageNum=1&pageSize=10
     */
    @GetMapping
    public Result<PageResult<UserVO>> list(
            @RequestParam(defaultValue = "1") int pageNum,
            @RequestParam(defaultValue = "10") int pageSize) {
        
        Page<User> page = userService.findByPage(pageNum, pageSize);
        
        // 转换为 VO
        List<UserVO> voList = page.getContent().stream()
                .map(this::convertToVO)
                .collect(Collectors.toList());
        
        PageResult<UserVO> result = new PageResult<>(
                voList,
                page.getTotalElements(),
                page.getNumber() + 1,  // JPA 页码从0开始，返回时+1
                page.getSize()
        );
        
        return Result.success(result);
    }
    
    /**
     * 带排序的分页查询
     * GET /api/users?pageNum=1&pageSize=10&sortField=createdAt&sortOrder=desc
     */
    @GetMapping("/sorted")
    public Result<PageResult<UserVO>> listWithSort(
            @RequestParam(defaultValue = "1") int pageNum,
            @RequestParam(defaultValue = "10") int pageSize,
            @RequestParam(defaultValue = "id") String sortField,
            @RequestParam(defaultValue = "asc") String sortOrder) {
        
        Page<User> page = userService.findByPageWithSort(pageNum, pageSize, sortField, sortOrder);
        // ... 转换逻辑同上
        return Result.success(convertToPageResult(page));
    }
    
    /**
     * 条件分页查询
     * GET /api/users/search?username=john&pageNum=1&pageSize=10
     */
    @GetMapping("/search")
    public Result<PageResult<UserVO>> search(UserQueryDTO query,
            @RequestParam(defaultValue = "1") int pageNum,
            @RequestParam(defaultValue = "10") int pageSize) {
        
        Page<User> page = userService.findByCondition(query, pageNum, pageSize);
        return Result.success(convertToPageResult(page));
    }
    
    /**
     * 使用 Spring Data 的 Pageable 参数解析
     * GET /api/users/v2?page=0&size=10&sort=createdAt,desc
     */
    @GetMapping("/v2")
    public Result<Page<UserVO>> listV2(Pageable pageable) {
        // Spring 会自动解析 page, size, sort 参数
        Page<User> page = userService.findAll(pageable);
        Page<UserVO> voPage = page.map(this::convertToVO);
        return Result.success(voPage);
    }
    
    private UserVO convertToVO(User user) {
        UserVO vo = new UserVO();
        BeanUtils.copyProperties(user, vo);
        return vo;
    }
    
    private PageResult<UserVO> convertToPageResult(Page<User> page) {
        List<UserVO> voList = page.getContent().stream()
                .map(this::convertToVO)
                .collect(Collectors.toList());
        return new PageResult<>(voList, page.getTotalElements(), 
                page.getNumber() + 1, page.getSize());
    }
}
```

---

## 4. MyBatis 分页

### 4.1 手动分页

```java
// Mapper 接口
@Mapper
public interface UserMapper {
    
    /**
     * 查询总数
     */
    long count(@Param("query") UserQueryDTO query);
    
    /**
     * 分页查询
     */
    List<User> selectByPage(@Param("query") UserQueryDTO query, 
                            @Param("offset") int offset, 
                            @Param("limit") int limit);
}
```

```xml
<!-- UserMapper.xml -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.example.mapper.UserMapper">
    
    <!-- 通用查询条件 -->
    <sql id="whereCondition">
        <where>
            <if test="query.username != null and query.username != ''">
                AND username LIKE CONCAT('%', #{query.username}, '%')
            </if>
            <if test="query.email != null and query.email != ''">
                AND email LIKE CONCAT('%', #{query.email}, '%')
            </if>
            <if test="query.startTime != null">
                AND created_at >= #{query.startTime}
            </if>
            <if test="query.endTime != null">
                AND created_at &lt;= #{query.endTime}
            </if>
        </where>
    </sql>
    
    <!-- 查询总数 -->
    <select id="count" resultType="long">
        SELECT COUNT(*) FROM user
        <include refid="whereCondition"/>
    </select>
    
    <!-- 分页查询 -->
    <select id="selectByPage" resultType="com.example.entity.User">
        SELECT id, username, email, created_at, updated_at
        FROM user
        <include refid="whereCondition"/>
        ORDER BY id DESC
        LIMIT #{offset}, #{limit}
    </select>
    
</mapper>
```

```java
// Service 层
@Service
public class UserService {
    
    @Autowired
    private UserMapper userMapper;
    
    public PageResult<User> findByPage(UserQueryDTO query, int pageNum, int pageSize) {
        // 参数校验
        pageNum = Math.max(1, pageNum);
        pageSize = Math.min(Math.max(1, pageSize), 100);
        
        // 计算偏移量
        int offset = (pageNum - 1) * pageSize;
        
        // 查询总数
        long total = userMapper.count(query);
        
        // 查询数据
        List<User> list = Collections.emptyList();
        if (total > 0) {
            list = userMapper.selectByPage(query, offset, pageSize);
        }
        
        return new PageResult<>(list, total, pageNum, pageSize);
    }
}
```

### 4.2 PageHelper 分页插件

PageHelper 是 MyBatis 最常用的分页插件，使用简单，功能强大。

```xml
<!-- pom.xml -->
<dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper-spring-boot-starter</artifactId>
    <version>1.4.6</version>
</dependency>
```

```yaml
# application.yml
pagehelper:
  helper-dialect: mysql
  reasonable: true           # 页码合理化，小于1返回第一页，大于总页数返回最后一页
  support-methods-arguments: true
  params: count=countSql
```

```java
// Mapper 接口（不需要分页参数）
@Mapper
public interface UserMapper {
    
    List<User> selectAll();
    
    List<User> selectByCondition(@Param("query") UserQueryDTO query);
}
```

```xml
<!-- UserMapper.xml -->
<mapper namespace="com.example.mapper.UserMapper">
    
    <select id="selectAll" resultType="com.example.entity.User">
        SELECT * FROM user ORDER BY id DESC
    </select>
    
    <select id="selectByCondition" resultType="com.example.entity.User">
        SELECT * FROM user
        <where>
            <if test="query.username != null and query.username != ''">
                AND username LIKE CONCAT('%', #{query.username}, '%')
            </if>
            <if test="query.email != null and query.email != ''">
                AND email LIKE CONCAT('%', #{query.email}, '%')
            </if>
        </where>
        ORDER BY id DESC
    </select>
    
</mapper>
```

```java
// Service 层
@Service
public class UserService {
    
    @Autowired
    private UserMapper userMapper;
    
    /**
     * 使用 PageHelper 分页
     * 核心原理：PageHelper.startPage() 会在 ThreadLocal 中设置分页参数，
     * 紧接着的第一个查询会被拦截并添加分页 SQL
     */
    public PageResult<User> findByPage(int pageNum, int pageSize) {
        // 开启分页（必须紧跟查询语句）
        PageHelper.startPage(pageNum, pageSize);
        
        // 执行查询（会被 PageHelper 拦截）
        List<User> list = userMapper.selectAll();
        
        // 获取分页信息
        PageInfo<User> pageInfo = new PageInfo<>(list);
        
        return new PageResult<>(
                pageInfo.getList(),
                pageInfo.getTotal(),
                pageInfo.getPageNum(),
                pageInfo.getPageSize()
        );
    }
    
    /**
     * 带条件的分页查询
     */
    public PageResult<User> findByCondition(UserQueryDTO query, int pageNum, int pageSize) {
        // 开启分页
        PageHelper.startPage(pageNum, pageSize);
        
        // 执行查询
        List<User> list = userMapper.selectByCondition(query);
        
        // 获取分页信息
        PageInfo<User> pageInfo = new PageInfo<>(list);
        
        return new PageResult<>(
                pageInfo.getList(),
                pageInfo.getTotal(),
                pageInfo.getPageNum(),
                pageInfo.getPageSize()
        );
    }
    
    /**
     * 带排序的分页查询
     */
    public PageResult<User> findByPageWithSort(int pageNum, int pageSize, String orderBy) {
        // 开启分页并设置排序
        PageHelper.startPage(pageNum, pageSize, orderBy);
        
        List<User> list = userMapper.selectAll();
        PageInfo<User> pageInfo = new PageInfo<>(list);
        
        return new PageResult<>(
                pageInfo.getList(),
                pageInfo.getTotal(),
                pageInfo.getPageNum(),
                pageInfo.getPageSize()
        );
    }
}
```

### 4.3 PageHelper 注意事项

```java
/**
 * PageHelper 使用注意事项
 */
@Service
public class UserService {
    
    // ❌ 错误用法 1：startPage 和查询之间有其他操作
    public PageResult<User> wrongUsage1(int pageNum, int pageSize) {
        PageHelper.startPage(pageNum, pageSize);
        
        // 这里有其他查询，会消耗掉分页参数！
        int count = userMapper.countSomething();
        
        // 这个查询不会分页
        List<User> list = userMapper.selectAll();
        return new PageResult<>(list, 0, pageNum, pageSize);
    }
    
    // ❌ 错误用法 2：在循环中使用
    public void wrongUsage2() {
        for (int i = 1; i <= 10; i++) {
            PageHelper.startPage(i, 10);
            List<User> list = userMapper.selectAll();
            // 每次循环都会查询数据库，性能差
        }
    }
    
    // ❌ 错误用法 3：分页后对结果进行过滤
    public PageResult<User> wrongUsage3(int pageNum, int pageSize) {
        PageHelper.startPage(pageNum, pageSize);
        List<User> list = userMapper.selectAll();
        
        // 分页后再过滤，会导致每页数据量不一致
        list = list.stream()
                .filter(u -> u.getStatus() == 1)
                .collect(Collectors.toList());
        
        PageInfo<User> pageInfo = new PageInfo<>(list);
        return new PageResult<>(pageInfo.getList(), pageInfo.getTotal(), 
                pageInfo.getPageNum(), pageInfo.getPageSize());
    }
    
    // ✅ 正确用法：使用 try-finally 确保清理
    public PageResult<User> correctUsage(int pageNum, int pageSize) {
        try {
            PageHelper.startPage(pageNum, pageSize);
            List<User> list = userMapper.selectAll();
            PageInfo<User> pageInfo = new PageInfo<>(list);
            return new PageResult<>(pageInfo.getList(), pageInfo.getTotal(), 
                    pageInfo.getPageNum(), pageInfo.getPageSize());
        } finally {
            // 清理 ThreadLocal，防止内存泄漏
            PageHelper.clearPage();
        }
    }
    
    // ✅ 正确用法：只查询数量不查询数据
    public long countOnly(UserQueryDTO query) {
        // 只查询数量
        PageHelper.startPage(1, 0, false);
        userMapper.selectByCondition(query);
        PageInfo<User> pageInfo = new PageInfo<>();
        return pageInfo.getTotal();
    }
}
```

---

## 5. MyBatis-Plus 分页

MyBatis-Plus 是 MyBatis 的增强工具，提供了更简洁的分页 API。

### 5.1 配置

```xml
<!-- pom.xml -->
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.5.3.1</version>
</dependency>
```

```java
/**
 * MyBatis-Plus 配置类
 */
@Configuration
@MapperScan("com.example.mapper")
public class MybatisPlusConfig {
    
    /**
     * 分页插件配置
     */
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        
        // 分页插件
        PaginationInnerInterceptor paginationInterceptor = new PaginationInnerInterceptor(DbType.MYSQL);
        // 设置最大单页限制数量，默认 500 条，-1 不受限制
        paginationInterceptor.setMaxLimit(500L);
        // 溢出总页数后是否进行处理
        paginationInterceptor.setOverflow(true);
        
        interceptor.addInnerInterceptor(paginationInterceptor);
        
        return interceptor;
    }
}
```

### 5.2 实体类

```java
@Data
@TableName("user")
public class User {
    
    @TableId(type = IdType.AUTO)
    private Long id;
    
    private String username;
    
    private String email;
    
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createdAt;
    
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updatedAt;
    
    @TableLogic
    private Integer deleted;
}
```

### 5.3 Mapper 接口

```java
/**
 * 继承 BaseMapper 获得 CRUD 能力
 */
@Mapper
public interface UserMapper extends BaseMapper<User> {
    
    /**
     * 自定义分页查询
     * 第一个参数必须是 IPage
     */
    IPage<User> selectPageByCondition(IPage<User> page, @Param("query") UserQueryDTO query);
    
    /**
     * 自定义 SQL 分页
     */
    @Select("SELECT * FROM user WHERE status = #{status}")
    IPage<User> selectPageByStatus(IPage<User> page, @Param("status") Integer status);
}
```

```xml
<!-- UserMapper.xml -->
<mapper namespace="com.example.mapper.UserMapper">
    
    <select id="selectPageByCondition" resultType="com.example.entity.User">
        SELECT * FROM user
        <where>
            <if test="query.username != null and query.username != ''">
                AND username LIKE CONCAT('%', #{query.username}, '%')
            </if>
            <if test="query.email != null and query.email != ''">
                AND email LIKE CONCAT('%', #{query.email}, '%')
            </if>
            <if test="query.status != null">
                AND status = #{query.status}
            </if>
        </where>
        ORDER BY id DESC
    </select>
    
</mapper>
```

### 5.4 Service 层

```java
@Service
public class UserService extends ServiceImpl<UserMapper, User> {
    
    /**
     * 基础分页查询
     */
    public IPage<User> findByPage(int pageNum, int pageSize) {
        // 创建分页对象
        Page<User> page = new Page<>(pageNum, pageSize);
        
        // 执行分页查询
        return this.page(page);
    }
    
    /**
     * 带条件的分页查询（使用 LambdaQueryWrapper）
     */
    public IPage<User> findByCondition(UserQueryDTO query, int pageNum, int pageSize) {
        Page<User> page = new Page<>(pageNum, pageSize);
        
        // 构建查询条件
        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();
        wrapper.like(StringUtils.hasText(query.getUsername()), User::getUsername, query.getUsername())
               .like(StringUtils.hasText(query.getEmail()), User::getEmail, query.getEmail())
               .ge(query.getStartTime() != null, User::getCreatedAt, query.getStartTime())
               .le(query.getEndTime() != null, User::getCreatedAt, query.getEndTime())
               .orderByDesc(User::getId);
        
        return this.page(page, wrapper);
    }
    
    /**
     * 使用 QueryWrapper 构建复杂查询
     */
    public IPage<User> findByComplexCondition(UserQueryDTO query, int pageNum, int pageSize) {
        Page<User> page = new Page<>(pageNum, pageSize);
        
        QueryWrapper<User> wrapper = new QueryWrapper<>();
        wrapper.select("id", "username", "email", "created_at")  // 指定查询字段
               .like(StringUtils.hasText(query.getUsername()), "username", query.getUsername())
               .and(StringUtils.hasText(query.getKeyword()), w -> 
                   w.like("username", query.getKeyword())
                    .or()
                    .like("email", query.getKeyword())
               )
               .between(query.getStartTime() != null && query.getEndTime() != null,
                       "created_at", query.getStartTime(), query.getEndTime())
               .orderByDesc("created_at");
        
        return this.page(page, wrapper);
    }
    
    /**
     * 自定义 SQL 分页
     */
    public IPage<User> findByCustomSql(UserQueryDTO query, int pageNum, int pageSize) {
        Page<User> page = new Page<>(pageNum, pageSize);
        return baseMapper.selectPageByCondition(page, query);
    }
    
    /**
     * 不查询总数的分页（适用于大数据量场景）
     */
    public IPage<User> findByPageWithoutCount(int pageNum, int pageSize) {
        // 第三个参数 false 表示不查询总数
        Page<User> page = new Page<>(pageNum, pageSize, false);
        return this.page(page);
    }
    
    /**
     * 分页结果转换
     */
    public IPage<UserVO> findByPageWithConvert(int pageNum, int pageSize) {
        Page<User> page = new Page<>(pageNum, pageSize);
        IPage<User> userPage = this.page(page);
        
        // 使用 convert 方法转换
        return userPage.convert(user -> {
            UserVO vo = new UserVO();
            BeanUtils.copyProperties(user, vo);
            return vo;
        });
    }
}
```

### 5.5 Controller 层

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    /**
     * 分页查询
     */
    @GetMapping
    public Result<IPage<UserVO>> list(
            @RequestParam(defaultValue = "1") Integer pageNum,
            @RequestParam(defaultValue = "10") Integer pageSize) {
        
        IPage<UserVO> page = userService.findByPageWithConvert(pageNum, pageSize);
        return Result.success(page);
    }
    
    /**
     * 条件分页查询
     */
    @GetMapping("/search")
    public Result<IPage<User>> search(UserQueryDTO query,
            @RequestParam(defaultValue = "1") Integer pageNum,
            @RequestParam(defaultValue = "10") Integer pageSize) {
        
        IPage<User> page = userService.findByCondition(query, pageNum, pageSize);
        return Result.success(page);
    }
}
```

---

## 6. 深度分页优化

### 6.1 深度分页问题

当页码很大时（如第 10000 页），传统的 LIMIT OFFSET 分页会有严重的性能问题。

```sql
-- 假设查询第 10000 页，每页 10 条
SELECT * FROM user ORDER BY id LIMIT 99990, 10;

-- 问题：MySQL 需要扫描前 100000 条记录，然后丢弃前 99990 条
-- 随着 offset 增大，性能急剧下降
```

```
┌─────────────────────────────────────────────────────────────────────┐
│ 深度分页性能问题                                                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ LIMIT 10 OFFSET 0      → 扫描 10 条，返回 10 条    ✅ 快            │
│ LIMIT 10 OFFSET 100    → 扫描 110 条，返回 10 条   ✅ 还行          │
│ LIMIT 10 OFFSET 10000  → 扫描 10010 条，返回 10 条 ⚠️ 慢           │
│ LIMIT 10 OFFSET 100000 → 扫描 100010 条，返回 10 条 ❌ 很慢         │
│ LIMIT 10 OFFSET 1000000→ 扫描 1000010 条，返回 10 条 ❌ 极慢        │
│                                                                      │
│ 原因：                                                               │
│ 1. MySQL 需要扫描 offset + limit 条记录                             │
│ 2. 然后丢弃前 offset 条                                             │
│ 3. offset 越大，扫描和丢弃的数据越多                                │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 6.2 优化方案一：子查询优化

```sql
-- 原始 SQL（慢）
SELECT * FROM user ORDER BY id LIMIT 100000, 10;

-- 优化后（快）
-- 先通过子查询找到起始 ID，再查询数据
SELECT * FROM user 
WHERE id >= (SELECT id FROM user ORDER BY id LIMIT 100000, 1)
ORDER BY id 
LIMIT 10;

-- 或者使用 JOIN
SELECT u.* FROM user u
INNER JOIN (SELECT id FROM user ORDER BY id LIMIT 100000, 10) t
ON u.id = t.id;
```

```java
// MyBatis 实现
@Mapper
public interface UserMapper {
    
    /**
     * 子查询优化的分页
     */
    @Select("SELECT * FROM user WHERE id >= " +
            "(SELECT id FROM user ORDER BY id LIMIT #{offset}, 1) " +
            "ORDER BY id LIMIT #{limit}")
    List<User> selectByPageOptimized(@Param("offset") int offset, @Param("limit") int limit);
    
    /**
     * JOIN 优化的分页
     */
    @Select("SELECT u.* FROM user u " +
            "INNER JOIN (SELECT id FROM user ORDER BY id LIMIT #{offset}, #{limit}) t " +
            "ON u.id = t.id")
    List<User> selectByPageWithJoin(@Param("offset") int offset, @Param("limit") int limit);
}
```

### 6.3 优化方案二：记住上次位置

```java
/**
 * 基于上次查询位置的分页
 * 适用于只能"上一页/下一页"的场景
 */
@Service
public class UserService {
    
    @Autowired
    private UserMapper userMapper;
    
    /**
     * 基于 lastId 的分页查询
     * @param lastId 上一页最后一条记录的 ID（首页传 0 或 null）
     * @param pageSize 每页条数
     * @return 分页结果
     */
    public List<User> findByLastId(Long lastId, int pageSize) {
        if (lastId == null || lastId <= 0) {
            // 首页
            return userMapper.selectFirstPage(pageSize);
        }
        // 后续页
        return userMapper.selectByLastId(lastId, pageSize);
    }
}

// Mapper
@Mapper
public interface UserMapper {
    
    @Select("SELECT * FROM user ORDER BY id LIMIT #{limit}")
    List<User> selectFirstPage(@Param("limit") int limit);
    
    @Select("SELECT * FROM user WHERE id > #{lastId} ORDER BY id LIMIT #{limit}")
    List<User> selectByLastId(@Param("lastId") Long lastId, @Param("limit") int limit);
}
```

```java
// Controller
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    /**
     * 基于 lastId 的分页
     * GET /api/users/scroll?lastId=100&pageSize=10
     */
    @GetMapping("/scroll")
    public Result<ScrollPageResult<User>> scroll(
            @RequestParam(required = false) Long lastId,
            @RequestParam(defaultValue = "10") int pageSize) {
        
        List<User> list = userService.findByLastId(lastId, pageSize + 1);
        
        // 判断是否有下一页
        boolean hasMore = list.size() > pageSize;
        if (hasMore) {
            list = list.subList(0, pageSize);
        }
        
        // 获取最后一条记录的 ID
        Long nextLastId = list.isEmpty() ? null : list.get(list.size() - 1).getId();
        
        return Result.success(new ScrollPageResult<>(list, hasMore, nextLastId));
    }
}

@Data
@AllArgsConstructor
public class ScrollPageResult<T> {
    private List<T> list;
    private boolean hasMore;
    private Long lastId;
}
```

### 6.4 优化方案三：延迟关联

```sql
-- 原始 SQL（需要回表查询所有字段）
SELECT * FROM user ORDER BY id LIMIT 100000, 10;

-- 优化：先查 ID，再关联查询
-- 第一步：只查 ID（走覆盖索引，不回表）
SELECT id FROM user ORDER BY id LIMIT 100000, 10;

-- 第二步：根据 ID 查询完整数据
SELECT * FROM user WHERE id IN (100001, 100002, ..., 100010);

-- 合并为一条 SQL
SELECT u.* FROM user u
INNER JOIN (
    SELECT id FROM user ORDER BY id LIMIT 100000, 10
) t ON u.id = t.id;
```

```java
@Mapper
public interface UserMapper {
    
    /**
     * 延迟关联分页
     */
    List<User> selectByPageDeferred(@Param("offset") int offset, @Param("limit") int limit);
}
```

```xml
<select id="selectByPageDeferred" resultType="com.example.entity.User">
    SELECT u.* FROM user u
    INNER JOIN (
        SELECT id FROM user ORDER BY id LIMIT #{offset}, #{limit}
    ) t ON u.id = t.id
</select>
```

---

## 7. 游标分页

游标分页（Cursor-based Pagination）是解决深度分页问题的最佳方案，特别适合无限滚动场景。

### 7.1 游标分页原理

```
┌─────────────────────────────────────────────────────────────────────┐
│ 游标分页 vs 偏移分页                                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 偏移分页（Offset Pagination）:                                       │
│ • 请求: page=5, size=10                                             │
│ • SQL: LIMIT 10 OFFSET 40                                           │
│ • 问题: 需要扫描前 50 条记录                                        │
│                                                                      │
│ 游标分页（Cursor Pagination）:                                       │
│ • 请求: cursor=xxx, size=10                                         │
│ • SQL: WHERE id > cursor_id LIMIT 10                                │
│ • 优点: 直接定位，不需要扫描                                        │
│                                                                      │
│ 游标可以是:                                                          │
│ • 主键 ID                                                           │
│ • 时间戳                                                            │
│ • 复合字段（如 created_at + id）                                    │
│ • Base64 编码的复合值                                               │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 7.2 简单游标分页实现

```java
/**
 * 游标分页结果
 */
@Data
public class CursorPageResult<T> {
    private List<T> list;           // 数据列表
    private String nextCursor;      // 下一页游标
    private String prevCursor;      // 上一页游标
    private boolean hasNext;        // 是否有下一页
    private boolean hasPrev;        // 是否有上一页
    
    public static <T> CursorPageResult<T> of(List<T> list, String nextCursor, boolean hasNext) {
        CursorPageResult<T> result = new CursorPageResult<>();
        result.setList(list);
        result.setNextCursor(nextCursor);
        result.setHasNext(hasNext);
        return result;
    }
}

/**
 * 游标分页服务
 */
@Service
public class UserService {
    
    @Autowired
    private UserMapper userMapper;
    
    /**
     * 基于 ID 的游标分页
     * @param cursor 游标（上一页最后一条记录的 ID，首页传 null）
     * @param size 每页条数
     * @param direction 方向：next（下一页）或 prev（上一页）
     */
    public CursorPageResult<User> findByCursor(Long cursor, int size, String direction) {
        List<User> list;
        
        if (cursor == null) {
            // 首页
            list = userMapper.selectFirstPage(size + 1);
        } else if ("next".equals(direction)) {
            // 下一页：ID > cursor
            list = userMapper.selectNextPage(cursor, size + 1);
        } else {
            // 上一页：ID < cursor，倒序查询后反转
            list = userMapper.selectPrevPage(cursor, size + 1);
            Collections.reverse(list);
        }
        
        // 判断是否有更多数据
        boolean hasMore = list.size() > size;
        if (hasMore) {
            list = list.subList(0, size);
        }
        
        // 获取下一页游标
        String nextCursor = list.isEmpty() ? null : 
                String.valueOf(list.get(list.size() - 1).getId());
        
        return CursorPageResult.of(list, nextCursor, hasMore);
    }
}

// Mapper
@Mapper
public interface UserMapper {
    
    @Select("SELECT * FROM user ORDER BY id DESC LIMIT #{limit}")
    List<User> selectFirstPage(@Param("limit") int limit);
    
    @Select("SELECT * FROM user WHERE id < #{cursor} ORDER BY id DESC LIMIT #{limit}")
    List<User> selectNextPage(@Param("cursor") Long cursor, @Param("limit") int limit);
    
    @Select("SELECT * FROM user WHERE id > #{cursor} ORDER BY id ASC LIMIT #{limit}")
    List<User> selectPrevPage(@Param("cursor") Long cursor, @Param("limit") int limit);
}
```

### 7.3 复合游标分页

当排序字段不是唯一的时候，需要使用复合游标。

```java
/**
 * 复合游标（时间 + ID）
 */
@Data
public class Cursor {
    private LocalDateTime createdAt;
    private Long id;
    
    public String encode() {
        String json = String.format("%s,%d", createdAt.toString(), id);
        return Base64.getEncoder().encodeToString(json.getBytes());
    }
    
    public static Cursor decode(String encoded) {
        if (encoded == null || encoded.isEmpty()) {
            return null;
        }
        try {
            String json = new String(Base64.getDecoder().decode(encoded));
            String[] parts = json.split(",");
            Cursor cursor = new Cursor();
            cursor.setCreatedAt(LocalDateTime.parse(parts[0]));
            cursor.setId(Long.parseLong(parts[1]));
            return cursor;
        } catch (Exception e) {
            return null;
        }
    }
}

@Service
public class UserService {
    
    @Autowired
    private UserMapper userMapper;
    
    /**
     * 复合游标分页（按创建时间倒序）
     */
    public CursorPageResult<User> findByCompositeCursor(String cursorStr, int size) {
        Cursor cursor = Cursor.decode(cursorStr);
        
        List<User> list;
        if (cursor == null) {
            // 首页
            list = userMapper.selectFirstPageByTime(size + 1);
        } else {
            // 后续页：(created_at < cursor.createdAt) OR (created_at = cursor.createdAt AND id < cursor.id)
            list = userMapper.selectByCompositeCursor(cursor.getCreatedAt(), cursor.getId(), size + 1);
        }
        
        boolean hasMore = list.size() > size;
        if (hasMore) {
            list = list.subList(0, size);
        }
        
        String nextCursor = null;
        if (!list.isEmpty()) {
            User last = list.get(list.size() - 1);
            Cursor next = new Cursor();
            next.setCreatedAt(last.getCreatedAt());
            next.setId(last.getId());
            nextCursor = next.encode();
        }
        
        return CursorPageResult.of(list, nextCursor, hasMore);
    }
}
```

```xml
<!-- UserMapper.xml -->
<select id="selectFirstPageByTime" resultType="com.example.entity.User">
    SELECT * FROM user 
    ORDER BY created_at DESC, id DESC 
    LIMIT #{limit}
</select>

<select id="selectByCompositeCursor" resultType="com.example.entity.User">
    SELECT * FROM user 
    WHERE (created_at &lt; #{createdAt}) 
       OR (created_at = #{createdAt} AND id &lt; #{id})
    ORDER BY created_at DESC, id DESC 
    LIMIT #{limit}
</select>
```

---

## 8. 分页封装与统一响应

### 8.1 统一分页请求参数

```java
/**
 * 分页请求基类
 */
@Data
public class PageRequest {
    
    @Min(value = 1, message = "页码最小为1")
    private Integer pageNum = 1;
    
    @Min(value = 1, message = "每页条数最小为1")
    @Max(value = 100, message = "每页条数最大为100")
    private Integer pageSize = 10;
    
    private String sortField;
    
    private String sortOrder = "asc";
    
    /**
     * 获取偏移量
     */
    public int getOffset() {
        return (pageNum - 1) * pageSize;
    }
    
    /**
     * 是否降序
     */
    public boolean isDesc() {
        return "desc".equalsIgnoreCase(sortOrder);
    }
}

/**
 * 用户查询请求
 */
@Data
@EqualsAndHashCode(callSuper = true)
public class UserQueryRequest extends PageRequest {
    
    private String username;
    
    private String email;
    
    private Integer status;
    
    @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime startTime;
    
    @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime endTime;
}
```

### 8.2 统一分页响应

```java
/**
 * 统一分页响应
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class PageResponse<T> {
    
    /** 数据列表 */
    private List<T> list;
    
    /** 总记录数 */
    private long total;
    
    /** 总页数 */
    private int pages;
    
    /** 当前页码 */
    private int pageNum;
    
    /** 每页条数 */
    private int pageSize;
    
    /** 是否有下一页 */
    private boolean hasNext;
    
    /** 是否有上一页 */
    private boolean hasPrev;
    
    /**
     * 构造方法
     */
    public PageResponse(List<T> list, long total, int pageNum, int pageSize) {
        this.list = list;
        this.total = total;
        this.pageNum = pageNum;
        this.pageSize = pageSize;
        this.pages = (int) Math.ceil((double) total / pageSize);
        this.hasNext = pageNum < pages;
        this.hasPrev = pageNum > 1;
    }
    
    /**
     * 从 Spring Data Page 转换
     */
    public static <T> PageResponse<T> from(Page<T> page) {
        return new PageResponse<>(
                page.getContent(),
                page.getTotalElements(),
                page.getNumber() + 1,  // JPA 页码从 0 开始
                page.getSize()
        );
    }
    
    /**
     * 从 MyBatis-Plus IPage 转换
     */
    public static <T> PageResponse<T> from(IPage<T> page) {
        return new PageResponse<>(
                page.getRecords(),
                page.getTotal(),
                (int) page.getCurrent(),
                (int) page.getSize()
        );
    }
    
    /**
     * 从 PageHelper PageInfo 转换
     */
    public static <T> PageResponse<T> from(PageInfo<T> pageInfo) {
        return new PageResponse<>(
                pageInfo.getList(),
                pageInfo.getTotal(),
                pageInfo.getPageNum(),
                pageInfo.getPageSize()
        );
    }
    
    /**
     * 数据转换
     */
    public <R> PageResponse<R> map(Function<T, R> converter) {
        List<R> newList = list.stream()
                .map(converter)
                .collect(Collectors.toList());
        return new PageResponse<>(newList, total, pageNum, pageSize);
    }
    
    /**
     * 空分页
     */
    public static <T> PageResponse<T> empty(int pageNum, int pageSize) {
        return new PageResponse<>(Collections.emptyList(), 0, pageNum, pageSize);
    }
}
```

### 8.3 统一响应封装

```java
/**
 * 统一响应结果
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Result<T> {
    
    private int code;
    private String message;
    private T data;
    private long timestamp;
    
    public static <T> Result<T> success(T data) {
        return new Result<>(200, "success", data, System.currentTimeMillis());
    }
    
    public static <T> Result<T> success() {
        return success(null);
    }
    
    public static <T> Result<T> error(int code, String message) {
        return new Result<>(code, message, null, System.currentTimeMillis());
    }
    
    public static <T> Result<T> error(String message) {
        return error(500, message);
    }
}
```

### 8.4 Controller 使用示例

```java
@RestController
@RequestMapping("/api/users")
@Validated
public class UserController {
    
    @Autowired
    private UserService userService;
    
    /**
     * 分页查询用户
     * GET /api/users?pageNum=1&pageSize=10&username=john&sortField=createdAt&sortOrder=desc
     */
    @GetMapping
    public Result<PageResponse<UserVO>> list(@Valid UserQueryRequest request) {
        PageResponse<User> page = userService.findByPage(request);
        
        // 转换为 VO
        PageResponse<UserVO> voPage = page.map(user -> {
            UserVO vo = new UserVO();
            BeanUtils.copyProperties(user, vo);
            return vo;
        });
        
        return Result.success(voPage);
    }
}
```

---

## 9. 前后端分页交互

### 9.1 RESTful API 设计

```
┌─────────────────────────────────────────────────────────────────────┐
│ 分页 API 设计规范                                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 请求方式: GET                                                        │
│                                                                      │
│ URL 参数:                                                            │
│ • pageNum/page     - 页码                                           │
│ • pageSize/size    - 每页条数                                       │
│ • sort             - 排序字段                                       │
│ • order            - 排序方向 (asc/desc)                            │
│ • 其他查询条件                                                       │
│                                                                      │
│ 示例:                                                                │
│ GET /api/users?pageNum=1&pageSize=10                                │
│ GET /api/users?pageNum=1&pageSize=10&username=john                  │
│ GET /api/users?pageNum=1&pageSize=10&sort=createdAt&order=desc      │
│                                                                      │
│ 响应格式:                                                            │
│ {                                                                    │
│   "code": 200,                                                       │
│   "message": "success",                                              │
│   "data": {                                                          │
│     "list": [...],                                                   │
│     "total": 100,                                                    │
│     "pages": 10,                                                     │
│     "pageNum": 1,                                                    │
│     "pageSize": 10,                                                  │
│     "hasNext": true,                                                 │
│     "hasPrev": false                                                 │
│   }                                                                  │
│ }                                                                    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 9.2 前端请求示例

```javascript
// axios 封装
import axios from 'axios'

const request = axios.create({
  baseURL: '/api',
  timeout: 10000
})

// 分页查询用户
export function getUserList(params) {
  return request({
    url: '/users',
    method: 'get',
    params: {
      pageNum: params.pageNum || 1,
      pageSize: params.pageSize || 10,
      username: params.username,
      email: params.email,
      sort: params.sort,
      order: params.order
    }
  })
}

// Vue 组件使用
export default {
  data() {
    return {
      tableData: [],
      pagination: {
        pageNum: 1,
        pageSize: 10,
        total: 0
      },
      queryForm: {
        username: '',
        email: ''
      },
      loading: false
    }
  },
  methods: {
    async fetchData() {
      this.loading = true
      try {
        const res = await getUserList({
          ...this.pagination,
          ...this.queryForm
        })
        if (res.code === 200) {
          this.tableData = res.data.list
          this.pagination.total = res.data.total
        }
      } finally {
        this.loading = false
      }
    },
    handlePageChange(pageNum) {
      this.pagination.pageNum = pageNum
      this.fetchData()
    },
    handleSizeChange(pageSize) {
      this.pagination.pageSize = pageSize
      this.pagination.pageNum = 1
      this.fetchData()
    },
    handleSearch() {
      this.pagination.pageNum = 1
      this.fetchData()
    }
  },
  mounted() {
    this.fetchData()
  }
}
```

---

## 10. 常见错误与解决方案

### 10.1 分页参数错误

```java
// ❌ 错误 1：页码从 0 开始还是从 1 开始不统一
// JPA 页码从 0 开始，但前端通常从 1 开始

// ✅ 解决：统一转换
public Page<User> findByPage(int pageNum, int pageSize) {
    // 前端传 1，JPA 需要 0
    Pageable pageable = PageRequest.of(pageNum - 1, pageSize);
    return userRepository.findAll(pageable);
}

// ❌ 错误 2：没有限制最大页数
// 恶意请求 pageSize=10000 会导致内存溢出

// ✅ 解决：限制最大值
public PageResponse<User> findByPage(int pageNum, int pageSize) {
    pageNum = Math.max(1, pageNum);
    pageSize = Math.min(Math.max(1, pageSize), 100);  // 最大 100
    // ...
}

// ❌ 错误 3：页码超出范围
// 请求第 100 页，但只有 10 页数据

// ✅ 解决：返回空数据或最后一页
// 方案 1：返回空数据
if (pageNum > totalPages) {
    return PageResponse.empty(pageNum, pageSize);
}

// 方案 2：返回最后一页（PageHelper 的 reasonable 配置）
pagehelper:
  reasonable: true
```

### 10.2 PageHelper 常见问题

```java
// ❌ 错误 1：startPage 和查询不紧邻
public PageResponse<User> findByPage(int pageNum, int pageSize) {
    PageHelper.startPage(pageNum, pageSize);
    
    // 这里有其他查询，会消耗分页参数！
    long count = userMapper.countActive();
    
    // 这个查询不会分页
    List<User> list = userMapper.selectAll();
    return new PageResponse<>(list, count, pageNum, pageSize);
}

// ✅ 解决：确保 startPage 紧跟查询
public PageResponse<User> findByPage(int pageNum, int pageSize) {
    // 先执行其他查询
    long count = userMapper.countActive();
    
    // 再开启分页
    PageHelper.startPage(pageNum, pageSize);
    List<User> list = userMapper.selectAll();
    PageInfo<User> pageInfo = new PageInfo<>(list);
    return PageResponse.from(pageInfo);
}

// ❌ 错误 2：分页后过滤数据
public PageResponse<User> findByPage(int pageNum, int pageSize) {
    PageHelper.startPage(pageNum, pageSize);
    List<User> list = userMapper.selectAll();
    
    // 分页后再过滤，每页数据量不一致！
    list = list.stream()
            .filter(u -> u.getStatus() == 1)
            .collect(Collectors.toList());
    
    PageInfo<User> pageInfo = new PageInfo<>(list);
    return PageResponse.from(pageInfo);
}

// ✅ 解决：在 SQL 中过滤
public PageResponse<User> findByPage(int pageNum, int pageSize, int status) {
    PageHelper.startPage(pageNum, pageSize);
    List<User> list = userMapper.selectByStatus(status);  // SQL 中过滤
    PageInfo<User> pageInfo = new PageInfo<>(list);
    return PageResponse.from(pageInfo);
}

// ❌ 错误 3：异常时未清理 ThreadLocal
public PageResponse<User> findByPage(int pageNum, int pageSize) {
    PageHelper.startPage(pageNum, pageSize);
    List<User> list = userMapper.selectAll();  // 如果这里抛异常
    // ThreadLocal 中的分页参数不会被清理，影响下次请求
    return PageResponse.from(new PageInfo<>(list));
}

// ✅ 解决：使用 try-finally
public PageResponse<User> findByPage(int pageNum, int pageSize) {
    try {
        PageHelper.startPage(pageNum, pageSize);
        List<User> list = userMapper.selectAll();
        return PageResponse.from(new PageInfo<>(list));
    } finally {
        PageHelper.clearPage();
    }
}
```

### 10.3 深度分页性能问题

```java
// ❌ 错误：大偏移量查询
// SELECT * FROM user LIMIT 1000000, 10  -- 非常慢

// ✅ 解决方案 1：子查询优化
@Select("SELECT * FROM user WHERE id >= " +
        "(SELECT id FROM user ORDER BY id LIMIT #{offset}, 1) " +
        "ORDER BY id LIMIT #{limit}")
List<User> selectByPageOptimized(@Param("offset") int offset, @Param("limit") int limit);

// ✅ 解决方案 2：游标分页
@Select("SELECT * FROM user WHERE id > #{lastId} ORDER BY id LIMIT #{limit}")
List<User> selectByLastId(@Param("lastId") Long lastId, @Param("limit") int limit);

// ✅ 解决方案 3：限制最大页码
public PageResponse<User> findByPage(int pageNum, int pageSize) {
    int maxPage = 100;  // 最多查询 100 页
    if (pageNum > maxPage) {
        throw new BusinessException("页码超出限制，请使用搜索功能");
    }
    // ...
}

// ✅ 解决方案 4：使用 ES 等搜索引擎
// 对于需要深度分页的场景，考虑使用 Elasticsearch
```

### 10.4 排序注入风险

```java
// ❌ 错误：直接拼接排序字段（SQL 注入风险）
public PageResponse<User> findByPage(int pageNum, int pageSize, String sortField) {
    String sql = "SELECT * FROM user ORDER BY " + sortField;  // 危险！
    // ...
}

// ✅ 解决：白名单校验
private static final Set<String> ALLOWED_SORT_FIELDS = 
    Set.of("id", "username", "email", "created_at", "updated_at");

public PageResponse<User> findByPage(int pageNum, int pageSize, String sortField) {
    // 校验排序字段
    if (!ALLOWED_SORT_FIELDS.contains(sortField)) {
        sortField = "id";  // 默认排序字段
    }
    // ...
}

// ✅ 或使用枚举
public enum SortField {
    ID("id"),
    USERNAME("username"),
    EMAIL("email"),
    CREATED_AT("created_at");
    
    private final String column;
    
    SortField(String column) {
        this.column = column;
    }
    
    public String getColumn() {
        return column;
    }
}
```

### 10.5 并发数据变化问题

```java
// 问题：分页查询时数据发生变化
// 用户在第 1 页，此时有新数据插入
// 用户翻到第 2 页时，可能看到重复数据或漏掉数据

// ✅ 解决方案 1：使用游标分页
// 基于 ID 或时间戳，不受新数据影响

// ✅ 解决方案 2：快照查询
// 首次查询时记录时间戳，后续查询只查该时间戳之前的数据
public PageResponse<User> findByPage(int pageNum, int pageSize, LocalDateTime snapshot) {
    if (snapshot == null) {
        snapshot = LocalDateTime.now();
    }
    // WHERE created_at <= snapshot
    // ...
}

// ✅ 解决方案 3：接受不一致
// 对于大多数场景，轻微的数据不一致是可以接受的
```

### 10.6 总数查询性能问题

```java
// 问题：COUNT(*) 在大表上很慢
// SELECT COUNT(*) FROM user WHERE ...  -- 可能需要全表扫描

// ✅ 解决方案 1：不查询总数（适用于无限滚动）
Page<User> page = new Page<>(pageNum, pageSize, false);  // MyBatis-Plus
// 或
PageHelper.startPage(pageNum, pageSize, false);  // PageHelper

// ✅ 解决方案 2：缓存总数
@Cacheable(value = "userCount", key = "#query.hashCode()")
public long countUsers(UserQueryDTO query) {
    return userMapper.count(query);
}

// ✅ 解决方案 3：估算总数
// 使用 EXPLAIN 或表统计信息估算
@Select("SELECT TABLE_ROWS FROM information_schema.TABLES " +
        "WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'user'")
long estimateCount();

// ✅ 解决方案 4：异步查询总数
public CompletableFuture<PageResponse<User>> findByPageAsync(int pageNum, int pageSize) {
    CompletableFuture<Long> countFuture = CompletableFuture.supplyAsync(() -> 
        userMapper.count()
    );
    CompletableFuture<List<User>> dataFuture = CompletableFuture.supplyAsync(() -> 
        userMapper.selectByPage((pageNum - 1) * pageSize, pageSize)
    );
    
    return countFuture.thenCombine(dataFuture, (total, list) -> 
        new PageResponse<>(list, total, pageNum, pageSize)
    );
}
```

### 10.7 常见错误速查表

```
┌─────────────────────────────────────────────────────────────────────┐
│ 分页常见错误速查表                                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 错误现象                    │ 可能原因                │ 解决方案    │
│─────────────────────────────┼────────────────────────┼─────────────│
│ 分页不生效                  │ PageHelper 未紧跟查询  │ 调整代码顺序│
│ 每页数据量不对              │ 分页后过滤数据         │ SQL 中过滤  │
│ 总数不对                    │ 使用了错误的 PageInfo  │ 检查构造参数│
│ 深度分页很慢                │ LIMIT OFFSET 性能问题  │ 游标分页    │
│ 页码超出范围报错            │ 未处理边界情况         │ 参数校验    │
│ 排序不生效                  │ 排序字段名错误         │ 检查字段名  │
│ SQL 注入                    │ 排序字段未校验         │ 白名单校验  │
│ 内存溢出                    │ pageSize 过大          │ 限制最大值  │
│ 数据重复/遗漏               │ 并发数据变化           │ 游标分页    │
│ COUNT 查询慢                │ 大表全表扫描           │ 缓存/估算   │
│ ThreadLocal 泄漏            │ 异常未清理             │ try-finally │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 附录

### A. 分页方案选择指南

```
┌─────────────────────────────────────────────────────────────────────┐
│ 分页方案选择                                                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│ 场景                        │ 推荐方案                              │
│─────────────────────────────┼───────────────────────────────────────│
│ 简单 CRUD                   │ Spring Data JPA / MyBatis-Plus        │
│ 复杂查询                    │ MyBatis + PageHelper                  │
│ 大数据量                    │ 游标分页 / 子查询优化                 │
│ 无限滚动                    │ 游标分页                              │
│ 需要跳页                    │ 传统分页 + 深度分页优化               │
│ 实时性要求高                │ 游标分页                              │
│ 搜索场景                    │ Elasticsearch                         │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### B. 性能优化检查清单

```
□ 是否添加了合适的索引（排序字段、查询条件字段）
□ 是否限制了最大页码和每页条数
□ 是否使用了覆盖索引优化
□ 深度分页是否使用了优化方案
□ COUNT 查询是否有性能问题
□ 是否考虑了缓存
□ 排序字段是否做了白名单校验
□ 是否处理了边界情况（空数据、超出范围）
□ PageHelper 是否正确使用（紧跟查询、清理 ThreadLocal）
```

### C. 相关资源

```
• PageHelper 官方文档: https://github.com/pagehelper/Mybatis-PageHelper
• MyBatis-Plus 分页: https://baomidou.com/pages/97710a/
• Spring Data JPA: https://docs.spring.io/spring-data/jpa/docs/current/reference/html/
```

---

> 最后更新: 2025年1月
> 
> 分页看似简单，但要做好并不容易。希望这份笔记能帮助你避开常见的坑，写出高性能的分页查询代码！
