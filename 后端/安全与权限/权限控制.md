

> 权限控制是后端安全的核心，决定"谁能访问什么资源"
> 本笔记基于 Java 8 + Spring Boot 2.7.18 + Spring Security

---

## 目录

1. [基础概念](#1-基础概念)
2. [认证与授权的区别](#2-认证与授权的区别)
3. [Spring Security 入门](#3-spring-security-入门)
4. [基于角色的访问控制 RBAC](#4-基于角色的访问控制-rbac)
5. [基于权限的访问控制](#5-基于权限的访问控制)
6. [方法级安全控制](#6-方法级安全控制)
7. [JWT 令牌认证](#7-jwt-令牌认证)
8. [OAuth2 与第三方登录](#8-oauth2-与第三方登录)
9. [数据权限控制](#9-数据权限控制)
10. [动态权限管理](#10-动态权限管理)
11. [权限缓存优化](#11-权限缓存优化)
12. [多租户权限隔离](#12-多租户权限隔离)
13. [常见错误与解决方案](#13-常见错误与解决方案)
14. [最佳实践总结](#14-最佳实践总结)

---

## 1. 基础概念

### 1.1 什么是权限控制？

权限控制（Access Control）是指系统对用户访问资源的限制机制。简单来说，就是回答三个问题：
- **你是谁？**（身份识别 - Identification）
- **你真的是你吗？**（身份认证 - Authentication）
- **你能做什么？**（授权 - Authorization）

举个生活中的例子：你去公司上班
1. 你说"我是张三"（身份识别）
2. 你刷工卡验证身份（身份认证）
3. 你只能进入自己部门的办公区（授权）

### 1.2 权限模型演进

```
硬编码权限 → ACL → RBAC → ABAC → PBAC
   ↓          ↓      ↓       ↓       ↓
 最简单    访问控制列表  角色   属性    策略
```

| 模型 | 全称 | 特点 | 适用场景 |
|------|------|------|----------|
| ACL | Access Control List | 直接给用户分配权限 | 小型系统 |
| RBAC | Role-Based Access Control | 用户→角色→权限 | 中大型系统（最常用） |
| ABAC | Attribute-Based Access Control | 基于属性动态判断 | 复杂业务场景 |
| PBAC | Policy-Based Access Control | 基于策略规则 | 企业级复杂系统 |


### 1.3 核心术语解释

| 术语 | 英文 | 解释 | 举例 |
|------|------|------|------|
| 主体 | Subject/Principal | 访问资源的实体 | 用户、程序、设备 |
| 资源 | Resource | 被保护的对象 | API接口、文件、数据 |
| 权限 | Permission | 对资源的操作许可 | 读、写、删除 |
| 角色 | Role | 权限的集合 | 管理员、普通用户 |
| 策略 | Policy | 访问控制规则 | "只有管理员能删除" |

---

## 2. 认证与授权的区别

这是很多初学者容易混淆的概念，必须搞清楚！

### 2.1 认证（Authentication）- 你是谁？

认证是验证用户身份的过程，常见方式：

```java
// 认证的本质：验证凭证
public interface AuthenticationProvider {
    // 输入：用户提供的凭证（用户名+密码）
    // 输出：认证成功的用户信息，或抛出异常
    Authentication authenticate(Authentication authentication) 
        throws AuthenticationException;
}
```

常见认证方式：
- **用户名密码**：最传统的方式
- **手机验证码**：短信/语音验证
- **第三方登录**：微信、QQ、GitHub
- **生物识别**：指纹、人脸
- **证书认证**：数字证书

### 2.2 授权（Authorization）- 你能做什么？

授权是在认证通过后，判断用户是否有权限执行某操作：

```java
// 授权的本质：权限判断
public interface AccessDecisionManager {
    // 输入：认证信息、请求的资源、需要的权限
    // 输出：允许访问或抛出拒绝异常
    void decide(Authentication authentication, Object object,
                Collection<ConfigAttribute> configAttributes)
        throws AccessDeniedException, InsufficientAuthenticationException;
}
```

### 2.3 一图看懂区别

```
用户请求 → [认证过滤器] → 认证成功？ 
                              ↓ 是
                         [授权过滤器] → 有权限？
                                           ↓ 是
                                        访问资源
                              ↓ 否              ↓ 否
                         401 Unauthorized   403 Forbidden
```

**重要区别**：
- `401 Unauthorized`：未认证（没登录或登录失效）
- `403 Forbidden`：已认证但无权限（登录了但没权限）

---

## 3. Spring Security 入门

Spring Security 是 Spring 生态中最强大的安全框架，功能全面但学习曲线较陡。

### 3.1 添加依赖

```xml
<!-- pom.xml -->
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.7.18</version>
</parent>

<dependencies>
    <!-- Spring Security -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    
    <!-- Web -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
</dependencies>
```

### 3.2 默认行为

添加依赖后，Spring Security 会自动：
1. 所有接口都需要认证
2. 生成一个默认用户 `user`
3. 在控制台打印随机密码
4. 提供默认登录页面 `/login`

```
Using generated security password: 8e3d5c2a-1234-5678-9abc-def012345678
```

### 3.3 基础配置类

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    /**
     * 安全过滤器链配置
     * 这是 Spring Security 的核心配置
     */
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            // 授权配置
            .authorizeRequests()
                // 公开接口，无需认证
                .antMatchers("/public/**", "/login", "/register").permitAll()
                // 静态资源放行
                .antMatchers("/css/**", "/js/**", "/images/**").permitAll()
                // 其他所有请求需要认证
                .anyRequest().authenticated()
            .and()
            // 表单登录配置
            .formLogin()
                .loginPage("/login")           // 自定义登录页
                .loginProcessingUrl("/doLogin") // 登录表单提交地址
                .defaultSuccessUrl("/home")     // 登录成功跳转
                .failureUrl("/login?error")     // 登录失败跳转
            .and()
            // 登出配置
            .logout()
                .logoutUrl("/logout")
                .logoutSuccessUrl("/login?logout")
            .and()
            // CSRF 保护（前后端分离项目通常禁用）
            .csrf().disable();
        
        return http.build();
    }

    /**
     * 密码编码器
     * 生产环境必须使用！明文存储密码是严重安全漏洞
     */
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    /**
     * 内存用户（仅用于测试）
     * 生产环境应该从数据库加载用户
     */
    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails user = User.builder()
            .username("user")
            .password(passwordEncoder().encode("123456"))
            .roles("USER")
            .build();
        
        UserDetails admin = User.builder()
            .username("admin")
            .password(passwordEncoder().encode("admin123"))
            .roles("ADMIN", "USER")
            .build();
        
        return new InMemoryUserDetailsManager(user, admin);
    }
}
```


### 3.4 从数据库加载用户（生产环境）

```java
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.security.core.authority.SimpleGrantedAuthority;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class CustomUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;
    private final RoleRepository roleRepository;

    public CustomUserDetailsService(UserRepository userRepository, 
                                    RoleRepository roleRepository) {
        this.userRepository = userRepository;
        this.roleRepository = roleRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String username) 
            throws UsernameNotFoundException {
        // 1. 从数据库查询用户
        User user = userRepository.findByUsername(username)
            .orElseThrow(() -> new UsernameNotFoundException(
                "用户不存在: " + username));
        
        // 2. 查询用户的角色和权限
        List<String> permissions = roleRepository
            .findPermissionsByUserId(user.getId());
        
        // 3. 转换为 Spring Security 的权限对象
        List<SimpleGrantedAuthority> authorities = permissions.stream()
            .map(SimpleGrantedAuthority::new)
            .collect(Collectors.toList());
        
        // 4. 返回 UserDetails 对象
        return org.springframework.security.core.userdetails.User.builder()
            .username(user.getUsername())
            .password(user.getPassword())  // 数据库中已加密的密码
            .authorities(authorities)
            .accountExpired(false)
            .accountLocked(user.isLocked())
            .credentialsExpired(false)
            .disabled(!user.isEnabled())
            .build();
    }
}
```

### 3.5 Spring Security 过滤器链

理解过滤器链是掌握 Spring Security 的关键：

```
请求 → SecurityContextPersistenceFilter  // 加载/保存安全上下文
     → UsernamePasswordAuthenticationFilter  // 处理表单登录
     → BasicAuthenticationFilter  // 处理 HTTP Basic 认证
     → RememberMeAuthenticationFilter  // 处理"记住我"
     → AnonymousAuthenticationFilter  // 匿名用户处理
     → ExceptionTranslationFilter  // 异常转换
     → FilterSecurityInterceptor  // 最终的授权判断
     → Controller
```

---

## 4. 基于角色的访问控制 RBAC

RBAC（Role-Based Access Control）是最常用的权限模型，核心思想是：**用户 → 角色 → 权限**

### 4.1 数据库设计

```sql
-- 用户表
CREATE TABLE sys_user (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL UNIQUE,
    password VARCHAR(100) NOT NULL,
    nickname VARCHAR(50),
    email VARCHAR(100),
    phone VARCHAR(20),
    status TINYINT DEFAULT 1 COMMENT '0禁用 1启用',
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 角色表
CREATE TABLE sys_role (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    role_code VARCHAR(50) NOT NULL UNIQUE COMMENT '角色编码，如 ROLE_ADMIN',
    role_name VARCHAR(50) NOT NULL COMMENT '角色名称',
    description VARCHAR(200),
    status TINYINT DEFAULT 1,
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 权限/菜单表
CREATE TABLE sys_permission (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    parent_id BIGINT DEFAULT 0 COMMENT '父级ID',
    permission_code VARCHAR(100) NOT NULL UNIQUE COMMENT '权限编码，如 user:add',
    permission_name VARCHAR(50) NOT NULL COMMENT '权限名称',
    permission_type TINYINT COMMENT '类型：1菜单 2按钮 3接口',
    path VARCHAR(200) COMMENT '路由路径',
    icon VARCHAR(50) COMMENT '图标',
    sort_order INT DEFAULT 0 COMMENT '排序',
    status TINYINT DEFAULT 1
);

-- 用户-角色关联表（多对多）
CREATE TABLE sys_user_role (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    role_id BIGINT NOT NULL,
    UNIQUE KEY uk_user_role (user_id, role_id)
);

-- 角色-权限关联表（多对多）
CREATE TABLE sys_role_permission (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    role_id BIGINT NOT NULL,
    permission_id BIGINT NOT NULL,
    UNIQUE KEY uk_role_permission (role_id, permission_id)
);
```

### 4.2 实体类设计

```java
// 用户实体
@Data
@TableName("sys_user")
public class SysUser {
    @TableId(type = IdType.AUTO)
    private Long id;
    private String username;
    private String password;
    private String nickname;
    private String email;
    private String phone;
    private Integer status;
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
    
    // 非数据库字段，用于存储用户的角色
    @TableField(exist = false)
    private List<SysRole> roles;
}

// 角色实体
@Data
@TableName("sys_role")
public class SysRole {
    @TableId(type = IdType.AUTO)
    private Long id;
    private String roleCode;
    private String roleName;
    private String description;
    private Integer status;
    
    @TableField(exist = false)
    private List<SysPermission> permissions;
}

// 权限实体
@Data
@TableName("sys_permission")
public class SysPermission {
    @TableId(type = IdType.AUTO)
    private Long id;
    private Long parentId;
    private String permissionCode;
    private String permissionName;
    private Integer permissionType;
    private String path;
    private String icon;
    private Integer sortOrder;
    private Integer status;
}
```

### 4.3 基于角色的访问控制配置

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.authorizeRequests()
            // 公开接口
            .antMatchers("/public/**").permitAll()
            
            // 基于角色控制
            // hasRole 会自动添加 ROLE_ 前缀
            .antMatchers("/admin/**").hasRole("ADMIN")
            .antMatchers("/manager/**").hasAnyRole("ADMIN", "MANAGER")
            
            // 基于权限控制（更细粒度）
            // hasAuthority 不会添加前缀，需要完全匹配
            .antMatchers(HttpMethod.POST, "/user/**").hasAuthority("user:add")
            .antMatchers(HttpMethod.PUT, "/user/**").hasAuthority("user:edit")
            .antMatchers(HttpMethod.DELETE, "/user/**").hasAuthority("user:delete")
            .antMatchers(HttpMethod.GET, "/user/**").hasAuthority("user:view")
            
            .anyRequest().authenticated();
        
        return http.build();
    }
}
```

### 4.4 hasRole vs hasAuthority 的区别

这是一个常见的困惑点：

```java
// hasRole("ADMIN") 等价于 hasAuthority("ROLE_ADMIN")
// Spring Security 会自动给 hasRole 添加 "ROLE_" 前缀

// 数据库存储建议：
// 角色：ROLE_ADMIN, ROLE_USER（带前缀）
// 权限：user:add, user:edit（不带前缀）

// 使用示例
.antMatchers("/admin/**").hasRole("ADMIN")        // 检查 ROLE_ADMIN
.antMatchers("/user/add").hasAuthority("user:add") // 检查 user:add
```


---

## 5. 基于权限的访问控制

相比角色，权限控制更加细粒度，推荐使用 **资源:操作** 的命名方式。

### 5.1 权限命名规范

```
格式：资源:操作
示例：
  user:add      - 添加用户
  user:edit     - 编辑用户
  user:delete   - 删除用户
  user:view     - 查看用户
  user:export   - 导出用户
  order:audit   - 审核订单
  report:print  - 打印报表
```

### 5.2 SpEL 表达式权限控制

Spring Security 支持强大的 SpEL 表达式：

```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http.authorizeRequests()
        // 简单权限
        .antMatchers("/user/list").hasAuthority("user:view")
        
        // 多个权限满足其一
        .antMatchers("/user/**").hasAnyAuthority("user:view", "user:admin")
        
        // 使用 SpEL 表达式（更灵活）
        .antMatchers("/api/**").access(
            "hasAuthority('api:access') and hasIpAddress('192.168.1.0/24')")
        
        // 自定义表达式
        .antMatchers("/order/{orderId}/**").access(
            "@orderSecurity.checkOwner(authentication, #orderId)")
        
        .anyRequest().authenticated();
    
    return http.build();
}
```

### 5.3 自定义权限表达式

```java
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;

@Component("orderSecurity")
public class OrderSecurityExpression {

    private final OrderRepository orderRepository;

    public OrderSecurityExpression(OrderRepository orderRepository) {
        this.orderRepository = orderRepository;
    }

    /**
     * 检查当前用户是否是订单的所有者
     */
    public boolean checkOwner(Authentication authentication, Long orderId) {
        if (authentication == null || !authentication.isAuthenticated()) {
            return false;
        }
        
        String username = authentication.getName();
        Order order = orderRepository.findById(orderId).orElse(null);
        
        if (order == null) {
            return false;
        }
        
        // 管理员可以访问所有订单
        boolean isAdmin = authentication.getAuthorities().stream()
            .anyMatch(a -> a.getAuthority().equals("ROLE_ADMIN"));
        if (isAdmin) {
            return true;
        }
        
        // 普通用户只能访问自己的订单
        return order.getUsername().equals(username);
    }
}
```

---

## 6. 方法级安全控制

除了 URL 级别的控制，Spring Security 还支持方法级别的细粒度控制。

### 6.1 启用方法级安全

```java
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(
    prePostEnabled = true,   // 启用 @PreAuthorize 和 @PostAuthorize
    securedEnabled = true,   // 启用 @Secured
    jsr250Enabled = true     // 启用 @RolesAllowed
)
public class SecurityConfig {
    // ...
}
```

### 6.2 @PreAuthorize - 方法执行前检查

```java
@Service
public class UserService {

    // 简单角色检查
    @PreAuthorize("hasRole('ADMIN')")
    public void deleteUser(Long userId) {
        // 只有管理员能删除用户
    }

    // 权限检查
    @PreAuthorize("hasAuthority('user:add')")
    public User createUser(UserDTO dto) {
        // 需要 user:add 权限
    }

    // 多条件组合
    @PreAuthorize("hasRole('ADMIN') or hasAuthority('user:edit')")
    public void updateUser(Long userId, UserDTO dto) {
        // 管理员或有编辑权限的用户
    }

    // 使用方法参数
    @PreAuthorize("#userId == authentication.principal.id or hasRole('ADMIN')")
    public User getUser(Long userId) {
        // 只能查看自己的信息，管理员除外
    }

    // 使用对象属性
    @PreAuthorize("#user.username == authentication.name")
    public void updateProfile(User user) {
        // 只能更新自己的资料
    }
}
```

### 6.3 @PostAuthorize - 方法执行后检查

```java
@Service
public class OrderService {

    // 方法执行后检查返回值
    @PostAuthorize("returnObject.username == authentication.name or hasRole('ADMIN')")
    public Order getOrder(Long orderId) {
        // 查询订单后，检查是否是自己的订单
        return orderRepository.findById(orderId).orElse(null);
    }

    // 返回 null 时的处理
    @PostAuthorize("returnObject == null or returnObject.status != 'DELETED'")
    public Order findOrder(Long orderId) {
        // 不能返回已删除的订单
    }
}
```

### 6.4 @PreFilter 和 @PostFilter - 集合过滤

```java
@Service
public class DocumentService {

    // 过滤输入集合
    @PreFilter("filterObject.owner == authentication.name")
    public void batchDelete(List<Document> documents) {
        // 只删除属于当前用户的文档
        documentRepository.deleteAll(documents);
    }

    // 过滤输出集合
    @PostFilter("filterObject.visible == true or filterObject.owner == authentication.name")
    public List<Document> getAllDocuments() {
        // 只返回可见的或自己的文档
        return documentRepository.findAll();
    }
}
```

### 6.5 @Secured 和 @RolesAllowed

```java
@Service
public class ReportService {

    // @Secured - Spring 特有注解
    @Secured("ROLE_ADMIN")
    public void generateReport() {
        // 需要 ROLE_ADMIN
    }

    @Secured({"ROLE_ADMIN", "ROLE_MANAGER"})
    public void viewReport() {
        // 需要 ROLE_ADMIN 或 ROLE_MANAGER
    }

    // @RolesAllowed - JSR-250 标准注解
    @RolesAllowed("ADMIN")  // 会自动添加 ROLE_ 前缀
    public void deleteReport(Long reportId) {
        // 需要 ROLE_ADMIN
    }
}
```


### 6.6 自定义权限校验器

```java
import org.springframework.security.access.PermissionEvaluator;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;

import java.io.Serializable;

@Component
public class CustomPermissionEvaluator implements PermissionEvaluator {

    private final PermissionService permissionService;

    public CustomPermissionEvaluator(PermissionService permissionService) {
        this.permissionService = permissionService;
    }

    /**
     * 检查用户是否有对某个对象的某种权限
     * 用法：@PreAuthorize("hasPermission(#document, 'write')")
     */
    @Override
    public boolean hasPermission(Authentication authentication, 
                                  Object targetDomainObject, 
                                  Object permission) {
        if (authentication == null || targetDomainObject == null) {
            return false;
        }
        
        String username = authentication.getName();
        String permissionStr = permission.toString();
        
        // 根据对象类型判断权限
        if (targetDomainObject instanceof Document) {
            Document doc = (Document) targetDomainObject;
            return permissionService.hasDocumentPermission(
                username, doc.getId(), permissionStr);
        }
        
        return false;
    }

    /**
     * 检查用户是否有对某类型某ID对象的权限
     * 用法：@PreAuthorize("hasPermission(#docId, 'Document', 'read')")
     */
    @Override
    public boolean hasPermission(Authentication authentication,
                                  Serializable targetId,
                                  String targetType,
                                  Object permission) {
        if (authentication == null || targetId == null) {
            return false;
        }
        
        String username = authentication.getName();
        String permissionStr = permission.toString();
        
        return permissionService.hasPermission(
            username, targetType, (Long) targetId, permissionStr);
    }
}

// 注册自定义权限校验器
@Configuration
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {

    @Autowired
    private CustomPermissionEvaluator permissionEvaluator;

    @Override
    protected MethodSecurityExpressionHandler createExpressionHandler() {
        DefaultMethodSecurityExpressionHandler handler = 
            new DefaultMethodSecurityExpressionHandler();
        handler.setPermissionEvaluator(permissionEvaluator);
        return handler;
    }
}
```

---

## 7. JWT 令牌认证

前后端分离项目中，JWT（JSON Web Token）是最常用的认证方案。

### 7.1 JWT 基础知识

JWT 由三部分组成，用 `.` 分隔：
```
Header.Payload.Signature
xxxxx.yyyyy.zzzzz
```

```
Header（头部）：算法和类型
{
  "alg": "HS256",
  "typ": "JWT"
}

Payload（载荷）：用户信息和声明
{
  "sub": "1234567890",
  "name": "张三",
  "iat": 1516239022,
  "exp": 1516242622
}

Signature（签名）：防篡改
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)
```

### 7.2 添加 JWT 依赖

```xml
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-api</artifactId>
    <version>0.11.5</version>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-impl</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-jackson</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>
</dependency>
```

### 7.3 JWT 工具类

```java
import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

@Component
public class JwtUtils {

    @Value("${jwt.secret}")
    private String secret;

    @Value("${jwt.expiration}")
    private Long expiration;  // 毫秒

    @Value("${jwt.refresh-expiration}")
    private Long refreshExpiration;

    private SecretKey getSigningKey() {
        byte[] keyBytes = secret.getBytes(StandardCharsets.UTF_8);
        return Keys.hmacShaKeyFor(keyBytes);
    }

    /**
     * 生成访问令牌
     */
    public String generateToken(UserDetails userDetails) {
        Map<String, Object> claims = new HashMap<>();
        // 可以在 claims 中添加额外信息
        claims.put("authorities", userDetails.getAuthorities());
        return createToken(claims, userDetails.getUsername(), expiration);
    }

    /**
     * 生成刷新令牌
     */
    public String generateRefreshToken(UserDetails userDetails) {
        return createToken(new HashMap<>(), userDetails.getUsername(), refreshExpiration);
    }

    private String createToken(Map<String, Object> claims, String subject, Long expiration) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + expiration);

        return Jwts.builder()
            .setClaims(claims)
            .setSubject(subject)
            .setIssuedAt(now)
            .setExpiration(expiryDate)
            .signWith(getSigningKey(), SignatureAlgorithm.HS256)
            .compact();
    }

    /**
     * 从令牌中获取用户名
     */
    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    /**
     * 从令牌中获取过期时间
     */
    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    private Claims extractAllClaims(String token) {
        return Jwts.parserBuilder()
            .setSigningKey(getSigningKey())
            .build()
            .parseClaimsJws(token)
            .getBody();
    }

    /**
     * 验证令牌是否有效
     */
    public boolean validateToken(String token, UserDetails userDetails) {
        try {
            final String username = extractUsername(token);
            return username.equals(userDetails.getUsername()) && !isTokenExpired(token);
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }

    /**
     * 检查令牌是否过期
     */
    public boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }
}
```


### 7.4 JWT 认证过滤器

```java
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtUtils jwtUtils;
    private final UserDetailsService userDetailsService;

    public JwtAuthenticationFilter(JwtUtils jwtUtils, 
                                   UserDetailsService userDetailsService) {
        this.jwtUtils = jwtUtils;
        this.userDetailsService = userDetailsService;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain)
            throws ServletException, IOException {
        
        try {
            // 1. 从请求头获取 JWT
            String jwt = getJwtFromRequest(request);

            // 2. 验证 JWT 并设置认证信息
            if (StringUtils.hasText(jwt)) {
                String username = jwtUtils.extractUsername(jwt);

                if (username != null && 
                    SecurityContextHolder.getContext().getAuthentication() == null) {
                    
                    UserDetails userDetails = userDetailsService
                        .loadUserByUsername(username);

                    if (jwtUtils.validateToken(jwt, userDetails)) {
                        UsernamePasswordAuthenticationToken authentication =
                            new UsernamePasswordAuthenticationToken(
                                userDetails,
                                null,
                                userDetails.getAuthorities()
                            );
                        authentication.setDetails(
                            new WebAuthenticationDetailsSource()
                                .buildDetails(request)
                        );
                        
                        // 设置到安全上下文
                        SecurityContextHolder.getContext()
                            .setAuthentication(authentication);
                    }
                }
            }
        } catch (Exception e) {
            logger.error("无法设置用户认证", e);
        }

        filterChain.doFilter(request, response);
    }

    /**
     * 从请求头中提取 JWT
     * 格式：Authorization: Bearer <token>
     */
    private String getJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
```

### 7.5 JWT 安全配置

```java
@Configuration
@EnableWebSecurity
public class JwtSecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;
    private final UserDetailsService userDetailsService;

    public JwtSecurityConfig(JwtAuthenticationFilter jwtAuthenticationFilter,
                             UserDetailsService userDetailsService) {
        this.jwtAuthenticationFilter = jwtAuthenticationFilter;
        this.userDetailsService = userDetailsService;
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            // 禁用 CSRF（JWT 不需要）
            .csrf().disable()
            
            // 禁用 Session（JWT 是无状态的）
            .sessionManagement()
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            
            // 配置异常处理
            .exceptionHandling()
                .authenticationEntryPoint(new JwtAuthenticationEntryPoint())
                .accessDeniedHandler(new JwtAccessDeniedHandler())
            .and()
            
            // 授权配置
            .authorizeRequests()
                .antMatchers("/auth/**").permitAll()
                .antMatchers("/public/**").permitAll()
                .anyRequest().authenticated()
            .and()
            
            // 添加 JWT 过滤器
            .addFilterBefore(jwtAuthenticationFilter, 
                UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public AuthenticationManager authenticationManager(
            AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}

// 认证失败处理器
@Component
public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {
    @Override
    public void commence(HttpServletRequest request,
                         HttpServletResponse response,
                         AuthenticationException authException) throws IOException {
        response.setContentType("application/json;charset=UTF-8");
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.getWriter().write("{\"code\":401,\"message\":\"未认证，请先登录\"}");
    }
}

// 授权失败处理器
@Component
public class JwtAccessDeniedHandler implements AccessDeniedHandler {
    @Override
    public void handle(HttpServletRequest request,
                       HttpServletResponse response,
                       AccessDeniedException accessDeniedException) throws IOException {
        response.setContentType("application/json;charset=UTF-8");
        response.setStatus(HttpServletResponse.SC_FORBIDDEN);
        response.getWriter().write("{\"code\":403,\"message\":\"权限不足，拒绝访问\"}");
    }
}
```

### 7.6 登录接口

```java
@RestController
@RequestMapping("/auth")
public class AuthController {

    private final AuthenticationManager authenticationManager;
    private final UserDetailsService userDetailsService;
    private final JwtUtils jwtUtils;

    public AuthController(AuthenticationManager authenticationManager,
                          UserDetailsService userDetailsService,
                          JwtUtils jwtUtils) {
        this.authenticationManager = authenticationManager;
        this.userDetailsService = userDetailsService;
        this.jwtUtils = jwtUtils;
    }

    @PostMapping("/login")
    public Result<LoginResponse> login(@RequestBody LoginRequest request) {
        // 1. 认证
        Authentication authentication = authenticationManager.authenticate(
            new UsernamePasswordAuthenticationToken(
                request.getUsername(),
                request.getPassword()
            )
        );

        // 2. 认证成功，生成 JWT
        SecurityContextHolder.getContext().setAuthentication(authentication);
        UserDetails userDetails = (UserDetails) authentication.getPrincipal();
        
        String accessToken = jwtUtils.generateToken(userDetails);
        String refreshToken = jwtUtils.generateRefreshToken(userDetails);

        // 3. 返回令牌
        LoginResponse response = new LoginResponse();
        response.setAccessToken(accessToken);
        response.setRefreshToken(refreshToken);
        response.setTokenType("Bearer");
        response.setExpiresIn(jwtUtils.getExpiration());

        return Result.success(response);
    }

    @PostMapping("/refresh")
    public Result<LoginResponse> refresh(@RequestBody RefreshRequest request) {
        String refreshToken = request.getRefreshToken();
        
        // 验证刷新令牌
        if (jwtUtils.isTokenExpired(refreshToken)) {
            return Result.error(401, "刷新令牌已过期，请重新登录");
        }

        String username = jwtUtils.extractUsername(refreshToken);
        UserDetails userDetails = userDetailsService.loadUserByUsername(username);
        
        // 生成新的访问令牌
        String newAccessToken = jwtUtils.generateToken(userDetails);

        LoginResponse response = new LoginResponse();
        response.setAccessToken(newAccessToken);
        response.setRefreshToken(refreshToken);  // 刷新令牌不变
        response.setTokenType("Bearer");

        return Result.success(response);
    }
}
```


---

## 8. OAuth2 与第三方登录

OAuth2 是一个授权框架，允许第三方应用获取有限的访问权限。

### 8.1 OAuth2 四种授权模式

| 模式 | 适用场景 | 安全性 |
|------|----------|--------|
| 授权码模式 | Web 应用 | 最高 |
| 简化模式 | 纯前端应用 | 较低 |
| 密码模式 | 高度信任的应用 | 中等 |
| 客户端模式 | 服务间调用 | 中等 |

### 8.2 授权码模式流程

```
用户 → 客户端 → 授权服务器 → 用户登录授权 → 返回授权码
                    ↓
客户端用授权码换取 Access Token
                    ↓
客户端用 Access Token 访问资源服务器
```

### 8.3 Spring Security OAuth2 客户端配置

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-client</artifactId>
</dependency>
```

```yaml
# application.yml
spring:
  security:
    oauth2:
      client:
        registration:
          github:
            client-id: your-github-client-id
            client-secret: your-github-client-secret
            scope: read:user,user:email
          google:
            client-id: your-google-client-id
            client-secret: your-google-client-secret
            scope: openid,profile,email
          wechat:
            client-id: your-wechat-appid
            client-secret: your-wechat-secret
            authorization-grant-type: authorization_code
            redirect-uri: "{baseUrl}/login/oauth2/code/{registrationId}"
            scope: snsapi_login
        provider:
          wechat:
            authorization-uri: https://open.weixin.qq.com/connect/qrconnect
            token-uri: https://api.weixin.qq.com/sns/oauth2/access_token
            user-info-uri: https://api.weixin.qq.com/sns/userinfo
            user-name-attribute: openid
```

### 8.4 OAuth2 安全配置

```java
@Configuration
@EnableWebSecurity
public class OAuth2SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/", "/login/**", "/error").permitAll()
                .anyRequest().authenticated()
            .and()
            .oauth2Login()
                .loginPage("/login")
                .defaultSuccessUrl("/home")
                .failureUrl("/login?error")
                .userInfoEndpoint()
                    .userService(customOAuth2UserService());

        return http.build();
    }

    @Bean
    public OAuth2UserService<OAuth2UserRequest, OAuth2User> customOAuth2UserService() {
        return new CustomOAuth2UserService();
    }
}
```

### 8.5 自定义 OAuth2 用户服务

```java
@Service
public class CustomOAuth2UserService extends DefaultOAuth2UserService {

    private final UserRepository userRepository;

    public CustomOAuth2UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    public OAuth2User loadUser(OAuth2UserRequest userRequest) 
            throws OAuth2AuthenticationException {
        OAuth2User oauth2User = super.loadUser(userRequest);

        // 获取第三方平台标识
        String registrationId = userRequest.getClientRegistration()
            .getRegistrationId();
        
        // 获取用户信息
        Map<String, Object> attributes = oauth2User.getAttributes();
        
        // 根据不同平台处理用户信息
        String providerId;
        String email;
        String name;
        String avatar;

        switch (registrationId) {
            case "github":
                providerId = String.valueOf(attributes.get("id"));
                email = (String) attributes.get("email");
                name = (String) attributes.get("name");
                avatar = (String) attributes.get("avatar_url");
                break;
            case "google":
                providerId = (String) attributes.get("sub");
                email = (String) attributes.get("email");
                name = (String) attributes.get("name");
                avatar = (String) attributes.get("picture");
                break;
            default:
                throw new OAuth2AuthenticationException("不支持的登录方式");
        }

        // 查找或创建用户
        User user = userRepository
            .findByProviderAndProviderId(registrationId, providerId)
            .orElseGet(() -> {
                User newUser = new User();
                newUser.setProvider(registrationId);
                newUser.setProviderId(providerId);
                newUser.setEmail(email);
                newUser.setNickname(name);
                newUser.setAvatar(avatar);
                newUser.setRoles(Collections.singletonList("ROLE_USER"));
                return userRepository.save(newUser);
            });

        return new CustomOAuth2User(user, attributes);
    }
}
```

---

## 9. 数据权限控制

数据权限是指控制用户能看到哪些数据，比如"只能看自己部门的数据"。

### 9.1 数据权限类型

| 类型 | 说明 | 示例 |
|------|------|------|
| 全部数据 | 可以看所有数据 | 超级管理员 |
| 本部门数据 | 只能看本部门 | 部门经理 |
| 本部门及下级 | 本部门和子部门 | 分公司负责人 |
| 仅本人数据 | 只能看自己的 | 普通员工 |
| 自定义 | 指定部门 | 特殊角色 |

### 9.2 基于 MyBatis 拦截器实现

```java
import org.apache.ibatis.executor.statement.StatementHandler;
import org.apache.ibatis.mapping.BoundSql;
import org.apache.ibatis.mapping.MappedStatement;
import org.apache.ibatis.plugin.*;
import org.apache.ibatis.reflection.MetaObject;
import org.apache.ibatis.reflection.SystemMetaObject;
import org.springframework.stereotype.Component;

import java.sql.Connection;
import java.util.Properties;

@Component
@Intercepts({
    @Signature(type = StatementHandler.class, method = "prepare", 
               args = {Connection.class, Integer.class})
})
public class DataPermissionInterceptor implements Interceptor {

    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        StatementHandler handler = (StatementHandler) invocation.getTarget();
        MetaObject metaObject = SystemMetaObject.forObject(handler);

        // 获取 MappedStatement
        MappedStatement ms = (MappedStatement) metaObject
            .getValue("delegate.mappedStatement");
        
        // 只处理查询语句
        if (!ms.getSqlCommandType().name().equals("SELECT")) {
            return invocation.proceed();
        }

        // 检查是否需要数据权限过滤
        String mapperId = ms.getId();
        if (!needDataPermission(mapperId)) {
            return invocation.proceed();
        }

        // 获取原始 SQL
        BoundSql boundSql = handler.getBoundSql();
        String originalSql = boundSql.getSql();

        // 获取当前用户的数据权限
        String dataPermissionSql = buildDataPermissionSql();
        
        if (dataPermissionSql != null) {
            // 修改 SQL，添加数据权限条件
            String newSql = addDataPermissionCondition(originalSql, dataPermissionSql);
            metaObject.setValue("delegate.boundSql.sql", newSql);
        }

        return invocation.proceed();
    }

    private boolean needDataPermission(String mapperId) {
        // 可以通过注解或配置判断是否需要数据权限
        return mapperId.contains("Mapper.selectList") || 
               mapperId.contains("Mapper.selectPage");
    }

    private String buildDataPermissionSql() {
        // 获取当前登录用户
        LoginUser loginUser = SecurityUtils.getLoginUser();
        if (loginUser == null) {
            return null;
        }

        // 根据数据权限类型构建 SQL
        Integer dataScope = loginUser.getDataScope();
        
        switch (dataScope) {
            case 1: // 全部数据
                return null;
            case 2: // 本部门数据
                return "dept_id = " + loginUser.getDeptId();
            case 3: // 本部门及下级
                return "dept_id IN (SELECT id FROM sys_dept WHERE id = " + 
                       loginUser.getDeptId() + " OR parent_id = " + 
                       loginUser.getDeptId() + ")";
            case 4: // 仅本人数据
                return "create_by = " + loginUser.getUserId();
            case 5: // 自定义部门
                String deptIds = String.join(",", loginUser.getDataScopeDeptIds());
                return "dept_id IN (" + deptIds + ")";
            default:
                return "1 = 0"; // 无权限
        }
    }

    private String addDataPermissionCondition(String sql, String condition) {
        // 简单实现：在 WHERE 后添加条件
        if (sql.toLowerCase().contains("where")) {
            return sql + " AND (" + condition + ")";
        } else {
            return sql + " WHERE " + condition;
        }
    }

    @Override
    public Object plugin(Object target) {
        return Plugin.wrap(target, this);
    }

    @Override
    public void setProperties(Properties properties) {
    }
}
```


### 9.3 基于注解的数据权限

```java
// 数据权限注解
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface DataScope {
    /**
     * 部门表的别名
     */
    String deptAlias() default "";

    /**
     * 用户表的别名
     */
    String userAlias() default "";
}

// 数据权限切面
@Aspect
@Component
public class DataScopeAspect {

    @Before("@annotation(dataScope)")
    public void doBefore(JoinPoint point, DataScope dataScope) {
        // 清除之前的数据权限
        clearDataScope();
        
        // 获取当前用户
        LoginUser loginUser = SecurityUtils.getLoginUser();
        if (loginUser == null) {
            return;
        }

        // 构建数据权限 SQL
        StringBuilder sqlBuilder = new StringBuilder();
        
        for (SysRole role : loginUser.getRoles()) {
            Integer dataScope = role.getDataScope();
            
            if (dataScope == 1) {
                // 全部数据权限
                sqlBuilder = new StringBuilder();
                break;
            } else if (dataScope == 2) {
                // 本部门数据
                sqlBuilder.append(String.format(
                    " OR %s.dept_id = %d",
                    dataScope.deptAlias(),
                    loginUser.getDeptId()
                ));
            } else if (dataScope == 3) {
                // 本部门及下级
                sqlBuilder.append(String.format(
                    " OR %s.dept_id IN (SELECT id FROM sys_dept WHERE id = %d OR FIND_IN_SET(%d, ancestors))",
                    dataScope.deptAlias(),
                    loginUser.getDeptId(),
                    loginUser.getDeptId()
                ));
            } else if (dataScope == 4) {
                // 仅本人数据
                sqlBuilder.append(String.format(
                    " OR %s.user_id = %d",
                    dataScope.userAlias(),
                    loginUser.getUserId()
                ));
            }
        }

        if (sqlBuilder.length() > 0) {
            String sql = sqlBuilder.substring(4); // 去掉开头的 " OR "
            // 存储到 ThreadLocal，供 MyBatis 拦截器使用
            DataScopeContextHolder.setDataScope(" AND (" + sql + ")");
        }
    }

    @After("@annotation(dataScope)")
    public void doAfter(DataScope dataScope) {
        clearDataScope();
    }

    private void clearDataScope() {
        DataScopeContextHolder.clear();
    }
}

// 使用示例
@Service
public class UserService {

    @DataScope(deptAlias = "u", userAlias = "u")
    public List<User> selectUserList(User user) {
        return userMapper.selectUserList(user);
    }
}
```

---

## 10. 动态权限管理

实际项目中，权限配置通常存储在数据库，需要动态加载。

### 10.1 动态权限数据源

```java
import org.springframework.security.access.ConfigAttribute;
import org.springframework.security.access.SecurityConfig;
import org.springframework.security.web.FilterInvocation;
import org.springframework.security.web.access.intercept.FilterInvocationSecurityMetadataSource;
import org.springframework.stereotype.Component;
import org.springframework.util.AntPathMatcher;

import javax.annotation.PostConstruct;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

@Component
public class DynamicSecurityMetadataSource 
        implements FilterInvocationSecurityMetadataSource {

    private final PermissionService permissionService;
    private final AntPathMatcher pathMatcher = new AntPathMatcher();
    
    // 缓存：URL -> 所需权限
    private Map<String, Collection<ConfigAttribute>> permissionMap = 
        new ConcurrentHashMap<>();

    public DynamicSecurityMetadataSource(PermissionService permissionService) {
        this.permissionService = permissionService;
    }

    @PostConstruct
    public void loadPermissions() {
        refreshPermissions();
    }

    /**
     * 刷新权限缓存
     * 当权限配置变更时调用
     */
    public void refreshPermissions() {
        permissionMap.clear();
        
        // 从数据库加载所有权限配置
        List<SysPermission> permissions = permissionService.listAllPermissions();
        
        for (SysPermission permission : permissions) {
            String url = permission.getPath();
            String permCode = permission.getPermissionCode();
            
            if (url != null && permCode != null) {
                Collection<ConfigAttribute> attributes = permissionMap
                    .computeIfAbsent(url, k -> new ArrayList<>());
                attributes.add(new SecurityConfig(permCode));
            }
        }
    }

    /**
     * 获取访问某个 URL 所需的权限
     */
    @Override
    public Collection<ConfigAttribute> getAttributes(Object object) 
            throws IllegalArgumentException {
        FilterInvocation fi = (FilterInvocation) object;
        String requestUrl = fi.getRequestUrl();
        String method = fi.getRequest().getMethod();

        // 遍历权限配置，匹配 URL
        for (Map.Entry<String, Collection<ConfigAttribute>> entry : 
                permissionMap.entrySet()) {
            String pattern = entry.getKey();
            if (pathMatcher.match(pattern, requestUrl)) {
                return entry.getValue();
            }
        }

        // 没有配置的 URL，返回空（根据策略决定是否放行）
        return null;
    }

    @Override
    public Collection<ConfigAttribute> getAllConfigAttributes() {
        Set<ConfigAttribute> allAttributes = new HashSet<>();
        permissionMap.values().forEach(allAttributes::addAll);
        return allAttributes;
    }

    @Override
    public boolean supports(Class<?> clazz) {
        return FilterInvocation.class.isAssignableFrom(clazz);
    }
}
```

### 10.2 动态权限决策管理器

```java
import org.springframework.security.access.AccessDecisionManager;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.access.ConfigAttribute;
import org.springframework.security.authentication.InsufficientAuthenticationException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.stereotype.Component;

import java.util.Collection;

@Component
public class DynamicAccessDecisionManager implements AccessDecisionManager {

    @Override
    public void decide(Authentication authentication, 
                       Object object,
                       Collection<ConfigAttribute> configAttributes)
            throws AccessDeniedException, InsufficientAuthenticationException {
        
        // 没有配置权限要求，放行
        if (configAttributes == null || configAttributes.isEmpty()) {
            return;
        }

        // 获取用户拥有的权限
        Collection<? extends GrantedAuthority> authorities = 
            authentication.getAuthorities();

        // 检查是否有所需权限
        for (ConfigAttribute attribute : configAttributes) {
            String needPermission = attribute.getAttribute();
            
            for (GrantedAuthority authority : authorities) {
                if (needPermission.equals(authority.getAuthority())) {
                    return; // 有权限，放行
                }
            }
        }

        // 没有权限，拒绝访问
        throw new AccessDeniedException("权限不足，无法访问");
    }

    @Override
    public boolean supports(ConfigAttribute attribute) {
        return true;
    }

    @Override
    public boolean supports(Class<?> clazz) {
        return true;
    }
}
```

### 10.3 配置动态权限

```java
@Configuration
@EnableWebSecurity
public class DynamicSecurityConfig {

    private final DynamicSecurityMetadataSource securityMetadataSource;
    private final DynamicAccessDecisionManager accessDecisionManager;

    public DynamicSecurityConfig(
            DynamicSecurityMetadataSource securityMetadataSource,
            DynamicAccessDecisionManager accessDecisionManager) {
        this.securityMetadataSource = securityMetadataSource;
        this.accessDecisionManager = accessDecisionManager;
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/public/**", "/auth/**").permitAll()
                .anyRequest().authenticated()
            .and()
            // 添加动态权限过滤器
            .addFilterBefore(
                dynamicSecurityFilter(),
                FilterSecurityInterceptor.class
            );

        return http.build();
    }

    @Bean
    public DynamicSecurityFilter dynamicSecurityFilter() {
        return new DynamicSecurityFilter(
            securityMetadataSource, 
            accessDecisionManager
        );
    }
}

// 动态权限过滤器
public class DynamicSecurityFilter extends AbstractSecurityInterceptor 
        implements Filter {

    private final FilterInvocationSecurityMetadataSource metadataSource;

    public DynamicSecurityFilter(
            FilterInvocationSecurityMetadataSource metadataSource,
            AccessDecisionManager accessDecisionManager) {
        this.metadataSource = metadataSource;
        super.setAccessDecisionManager(accessDecisionManager);
    }

    @Override
    public void doFilter(ServletRequest request, 
                         ServletResponse response,
                         FilterChain chain) 
            throws IOException, ServletException {
        
        FilterInvocation fi = new FilterInvocation(request, response, chain);
        invoke(fi);
    }

    private void invoke(FilterInvocation fi) throws IOException, ServletException {
        InterceptorStatusToken token = super.beforeInvocation(fi);
        try {
            fi.getChain().doFilter(fi.getRequest(), fi.getResponse());
        } finally {
            super.afterInvocation(token, null);
        }
    }

    @Override
    public Class<?> getSecureObjectClass() {
        return FilterInvocation.class;
    }

    @Override
    public SecurityMetadataSource obtainSecurityMetadataSource() {
        return metadataSource;
    }
}
```


---

## 11. 权限缓存优化

权限数据频繁查询，使用缓存可以显著提升性能。

### 11.1 使用 Redis 缓存权限

```java
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Set;
import java.util.concurrent.TimeUnit;

@Service
public class PermissionCacheService {

    private static final String PERMISSION_KEY_PREFIX = "user:permissions:";
    private static final String ROLE_KEY_PREFIX = "user:roles:";
    private static final long CACHE_EXPIRE_HOURS = 2;

    private final RedisTemplate<String, Object> redisTemplate;
    private final PermissionMapper permissionMapper;

    public PermissionCacheService(RedisTemplate<String, Object> redisTemplate,
                                  PermissionMapper permissionMapper) {
        this.redisTemplate = redisTemplate;
        this.permissionMapper = permissionMapper;
    }

    /**
     * 获取用户权限（优先从缓存获取）
     */
    @SuppressWarnings("unchecked")
    public Set<String> getUserPermissions(Long userId) {
        String key = PERMISSION_KEY_PREFIX + userId;
        
        // 1. 尝试从缓存获取
        Set<String> permissions = (Set<String>) redisTemplate.opsForValue().get(key);
        
        if (permissions != null) {
            return permissions;
        }

        // 2. 缓存未命中，从数据库查询
        permissions = permissionMapper.selectPermissionsByUserId(userId);
        
        // 3. 写入缓存
        redisTemplate.opsForValue().set(key, permissions, 
            CACHE_EXPIRE_HOURS, TimeUnit.HOURS);
        
        return permissions;
    }

    /**
     * 清除用户权限缓存
     * 当用户权限变更时调用
     */
    public void clearUserPermissionCache(Long userId) {
        String permKey = PERMISSION_KEY_PREFIX + userId;
        String roleKey = ROLE_KEY_PREFIX + userId;
        redisTemplate.delete(permKey);
        redisTemplate.delete(roleKey);
    }

    /**
     * 清除所有用户权限缓存
     * 当角色权限变更时调用
     */
    public void clearAllPermissionCache() {
        Set<String> keys = redisTemplate.keys(PERMISSION_KEY_PREFIX + "*");
        if (keys != null && !keys.isEmpty()) {
            redisTemplate.delete(keys);
        }
    }

    /**
     * 刷新用户权限缓存
     */
    public void refreshUserPermissionCache(Long userId) {
        clearUserPermissionCache(userId);
        getUserPermissions(userId); // 重新加载
    }
}
```

### 11.2 使用 Spring Cache 简化缓存

```java
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;

@Service
public class CachedPermissionService {

    private final PermissionMapper permissionMapper;

    public CachedPermissionService(PermissionMapper permissionMapper) {
        this.permissionMapper = permissionMapper;
    }

    /**
     * 获取用户权限，自动缓存
     */
    @Cacheable(value = "userPermissions", key = "#userId")
    public Set<String> getUserPermissions(Long userId) {
        return permissionMapper.selectPermissionsByUserId(userId);
    }

    /**
     * 获取用户角色，自动缓存
     */
    @Cacheable(value = "userRoles", key = "#userId")
    public Set<String> getUserRoles(Long userId) {
        return permissionMapper.selectRolesByUserId(userId);
    }

    /**
     * 清除指定用户的权限缓存
     */
    @CacheEvict(value = {"userPermissions", "userRoles"}, key = "#userId")
    public void evictUserCache(Long userId) {
        // 方法体为空，仅用于清除缓存
    }

    /**
     * 清除所有权限缓存
     */
    @CacheEvict(value = {"userPermissions", "userRoles"}, allEntries = true)
    public void evictAllCache() {
        // 方法体为空
    }
}

// Redis 缓存配置
@Configuration
@EnableCaching
public class RedisCacheConfig {

    @Bean
    public RedisCacheManager cacheManager(RedisConnectionFactory factory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofHours(2))  // 缓存过期时间
            .serializeKeysWith(
                RedisSerializationContext.SerializationPair
                    .fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(
                RedisSerializationContext.SerializationPair
                    .fromSerializer(new GenericJackson2JsonRedisSerializer()));

        return RedisCacheManager.builder(factory)
            .cacheDefaults(config)
            .build();
    }
}
```

### 11.3 本地缓存 + Redis 二级缓存

```java
import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import org.springframework.stereotype.Service;

import java.util.Set;
import java.util.concurrent.TimeUnit;

@Service
public class TwoLevelPermissionCache {

    // 本地缓存（一级缓存）
    private final Cache<Long, Set<String>> localCache = Caffeine.newBuilder()
        .maximumSize(1000)
        .expireAfterWrite(5, TimeUnit.MINUTES)
        .build();

    private final RedisTemplate<String, Object> redisTemplate;
    private final PermissionMapper permissionMapper;

    public TwoLevelPermissionCache(RedisTemplate<String, Object> redisTemplate,
                                   PermissionMapper permissionMapper) {
        this.redisTemplate = redisTemplate;
        this.permissionMapper = permissionMapper;
    }

    @SuppressWarnings("unchecked")
    public Set<String> getUserPermissions(Long userId) {
        // 1. 查本地缓存
        Set<String> permissions = localCache.getIfPresent(userId);
        if (permissions != null) {
            return permissions;
        }

        // 2. 查 Redis 缓存
        String redisKey = "user:permissions:" + userId;
        permissions = (Set<String>) redisTemplate.opsForValue().get(redisKey);
        if (permissions != null) {
            localCache.put(userId, permissions);
            return permissions;
        }

        // 3. 查数据库
        permissions = permissionMapper.selectPermissionsByUserId(userId);
        
        // 4. 写入缓存
        localCache.put(userId, permissions);
        redisTemplate.opsForValue().set(redisKey, permissions, 2, TimeUnit.HOURS);
        
        return permissions;
    }

    public void clearCache(Long userId) {
        localCache.invalidate(userId);
        redisTemplate.delete("user:permissions:" + userId);
    }
}
```

---

## 12. 多租户权限隔离

多租户系统中，不同租户的数据必须严格隔离。

### 12.1 租户上下文

```java
/**
 * 租户上下文持有者
 * 使用 ThreadLocal 存储当前请求的租户信息
 */
public class TenantContextHolder {

    private static final ThreadLocal<Long> TENANT_ID = new ThreadLocal<>();

    public static void setTenantId(Long tenantId) {
        TENANT_ID.set(tenantId);
    }

    public static Long getTenantId() {
        return TENANT_ID.get();
    }

    public static void clear() {
        TENANT_ID.remove();
    }
}

// 租户过滤器
@Component
public class TenantFilter extends OncePerRequestFilter {

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain)
            throws ServletException, IOException {
        try {
            // 从请求头或 JWT 中获取租户 ID
            String tenantId = request.getHeader("X-Tenant-Id");
            if (tenantId != null) {
                TenantContextHolder.setTenantId(Long.parseLong(tenantId));
            }
            
            filterChain.doFilter(request, response);
        } finally {
            TenantContextHolder.clear();
        }
    }
}
```

### 12.2 MyBatis 租户拦截器

```java
@Component
@Intercepts({
    @Signature(type = StatementHandler.class, method = "prepare",
               args = {Connection.class, Integer.class})
})
public class TenantInterceptor implements Interceptor {

    // 不需要租户过滤的表
    private static final Set<String> IGNORE_TABLES = new HashSet<>(
        Arrays.asList("sys_tenant", "sys_config")
    );

    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        Long tenantId = TenantContextHolder.getTenantId();
        
        // 没有租户上下文，不处理
        if (tenantId == null) {
            return invocation.proceed();
        }

        StatementHandler handler = (StatementHandler) invocation.getTarget();
        MetaObject metaObject = SystemMetaObject.forObject(handler);
        
        MappedStatement ms = (MappedStatement) metaObject
            .getValue("delegate.mappedStatement");
        BoundSql boundSql = handler.getBoundSql();
        String originalSql = boundSql.getSql();

        // 解析 SQL，添加租户条件
        String newSql = addTenantCondition(originalSql, tenantId, ms);
        metaObject.setValue("delegate.boundSql.sql", newSql);

        return invocation.proceed();
    }

    private String addTenantCondition(String sql, Long tenantId, 
                                       MappedStatement ms) {
        // 使用 JSqlParser 解析和修改 SQL
        try {
            Statement statement = CCJSqlParserUtil.parse(sql);
            
            if (statement instanceof Select) {
                Select select = (Select) statement;
                processSelect(select, tenantId);
            } else if (statement instanceof Insert) {
                Insert insert = (Insert) statement;
                processInsert(insert, tenantId);
            } else if (statement instanceof Update) {
                Update update = (Update) statement;
                processUpdate(update, tenantId);
            } else if (statement instanceof Delete) {
                Delete delete = (Delete) statement;
                processDelete(delete, tenantId);
            }
            
            return statement.toString();
        } catch (Exception e) {
            return sql;
        }
    }

    private void processSelect(Select select, Long tenantId) {
        SelectBody selectBody = select.getSelectBody();
        if (selectBody instanceof PlainSelect) {
            PlainSelect plainSelect = (PlainSelect) selectBody;
            
            // 获取表名
            FromItem fromItem = plainSelect.getFromItem();
            if (fromItem instanceof Table) {
                Table table = (Table) fromItem;
                if (!IGNORE_TABLES.contains(table.getName().toLowerCase())) {
                    // 添加租户条件
                    Expression where = plainSelect.getWhere();
                    Expression tenantCondition = new EqualsTo(
                        new Column("tenant_id"),
                        new LongValue(tenantId)
                    );
                    
                    if (where == null) {
                        plainSelect.setWhere(tenantCondition);
                    } else {
                        plainSelect.setWhere(new AndExpression(where, tenantCondition));
                    }
                }
            }
        }
    }

    // processInsert, processUpdate, processDelete 类似实现...

    @Override
    public Object plugin(Object target) {
        return Plugin.wrap(target, this);
    }

    @Override
    public void setProperties(Properties properties) {
    }
}
```


### 12.3 租户权限校验

```java
@Aspect
@Component
public class TenantPermissionAspect {

    @Before("@annotation(tenantCheck)")
    public void checkTenantPermission(JoinPoint point, TenantCheck tenantCheck) {
        Long currentTenantId = TenantContextHolder.getTenantId();
        
        if (currentTenantId == null) {
            throw new TenantException("租户信息缺失");
        }

        // 获取方法参数中的租户 ID
        Object[] args = point.getArgs();
        for (Object arg : args) {
            if (arg instanceof TenantAware) {
                TenantAware tenantAware = (TenantAware) arg;
                Long dataTenantId = tenantAware.getTenantId();
                
                if (dataTenantId != null && !dataTenantId.equals(currentTenantId)) {
                    throw new TenantException("无权访问其他租户数据");
                }
            }
        }
    }
}

// 租户感知接口
public interface TenantAware {
    Long getTenantId();
    void setTenantId(Long tenantId);
}

// 租户检查注解
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface TenantCheck {
}

// 使用示例
@Service
public class OrderService {

    @TenantCheck
    public Order getOrder(Long orderId) {
        return orderMapper.selectById(orderId);
    }
}
```

---

## 13. 常见错误与解决方案

### 13.1 401 Unauthorized - 未认证

**错误现象**：
```json
{
    "status": 401,
    "error": "Unauthorized",
    "message": "Full authentication is required to access this resource"
}
```

**常见原因及解决**：

```java
// 原因1：忘记放行公开接口
// 错误
.authorizeRequests()
    .anyRequest().authenticated()

// 正确
.authorizeRequests()
    .antMatchers("/public/**", "/login").permitAll()
    .anyRequest().authenticated()

// 原因2：JWT Token 格式错误
// 错误：Authorization: <token>
// 正确：Authorization: Bearer <token>

// 原因3：Token 过期
// 检查 Token 过期时间，实现 Token 刷新机制

// 原因4：跨域请求未携带认证信息
// 前端需要设置
axios.defaults.withCredentials = true;
// 或在请求头中手动添加 Authorization
```

### 13.2 403 Forbidden - 无权限

**错误现象**：
```json
{
    "status": 403,
    "error": "Forbidden",
    "message": "Access Denied"
}
```

**常见原因及解决**：

```java
// 原因1：角色前缀问题
// 数据库存储：ADMIN
// hasRole("ADMIN") 会检查 ROLE_ADMIN
// 解决：数据库存储 ROLE_ADMIN，或使用 hasAuthority("ADMIN")

// 原因2：权限配置顺序错误
// 错误：更具体的规则放在后面
.antMatchers("/**").authenticated()
.antMatchers("/admin/**").hasRole("ADMIN")  // 永远不会执行

// 正确：更具体的规则放在前面
.antMatchers("/admin/**").hasRole("ADMIN")
.antMatchers("/**").authenticated()

// 原因3：方法级安全未启用
// 忘记添加 @EnableGlobalMethodSecurity
@Configuration
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class SecurityConfig { }
```

### 13.3 CSRF 相关错误

**错误现象**：
```
Invalid CSRF Token 'null' was found on the request parameter '_csrf'
```

**解决方案**：

```java
// 方案1：前后端分离项目禁用 CSRF
http.csrf().disable();

// 方案2：传统项目配置 CSRF
// 表单中添加 CSRF Token
<input type="hidden" name="${_csrf.parameterName}" value="${_csrf.token}"/>

// 方案3：AJAX 请求携带 CSRF Token
// 在 meta 标签中存储
<meta name="_csrf" content="${_csrf.token}"/>
<meta name="_csrf_header" content="${_csrf.headerName}"/>

// JavaScript 中获取并添加到请求头
var token = $("meta[name='_csrf']").attr("content");
var header = $("meta[name='_csrf_header']").attr("content");
$.ajax({
    beforeSend: function(xhr) {
        xhr.setRequestHeader(header, token);
    }
});
```

### 13.4 循环依赖问题

**错误现象**：
```
The dependencies of some of the beans in the application context form a cycle
```

**解决方案**：

```java
// 原因：SecurityConfig 和 UserDetailsService 循环依赖

// 方案1：使用 @Lazy 延迟加载
@Configuration
public class SecurityConfig {
    
    private final UserDetailsService userDetailsService;
    
    public SecurityConfig(@Lazy UserDetailsService userDetailsService) {
        this.userDetailsService = userDetailsService;
    }
}

// 方案2：使用 setter 注入
@Configuration
public class SecurityConfig {
    
    private UserDetailsService userDetailsService;
    
    @Autowired
    public void setUserDetailsService(UserDetailsService userDetailsService) {
        this.userDetailsService = userDetailsService;
    }
}

// 方案3：重构代码，打破循环
// 将 PasswordEncoder 单独配置
@Configuration
public class PasswordEncoderConfig {
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

### 13.5 密码编码问题

**错误现象**：
```
There is no PasswordEncoder mapped for the id "null"
```

**解决方案**：

```java
// 原因：密码没有使用编码器前缀

// 方案1：配置默认密码编码器
@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}

// 方案2：使用 DelegatingPasswordEncoder（推荐）
@Bean
public PasswordEncoder passwordEncoder() {
    return PasswordEncoderFactories.createDelegatingPasswordEncoder();
}
// 数据库密码格式：{bcrypt}$2a$10$...

// 方案3：明文密码（仅测试用，生产环境禁止！）
@Bean
public PasswordEncoder passwordEncoder() {
    return NoOpPasswordEncoder.getInstance();
}
```

### 13.6 跨域问题

**错误现象**：
```
Access to XMLHttpRequest at 'http://api.example.com' from origin 
'http://localhost:3000' has been blocked by CORS policy
```

**解决方案**：

```java
@Configuration
public class CorsConfig {

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowedOrigins(Arrays.asList("http://localhost:3000"));
        config.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        config.setAllowedHeaders(Arrays.asList("*"));
        config.setAllowCredentials(true);
        config.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        return source;
    }
}

// 在 SecurityConfig 中启用
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .cors().configurationSource(corsConfigurationSource())
        .and()
        // ... 其他配置
    return http.build();
}
```

### 13.7 Session 固定攻击防护失效

**问题**：登录后 Session ID 没有变化

```java
// 解决：配置 Session 固定攻击防护策略
http.sessionManagement()
    .sessionFixation().migrateSession()  // 登录后迁移 Session
    // 或
    .sessionFixation().newSession()      // 登录后创建新 Session
    // 或
    .sessionFixation().changeSessionId() // 仅改变 Session ID（Servlet 3.1+）
```

### 13.8 Remember-Me 不生效

```java
// 检查配置
http.rememberMe()
    .key("uniqueAndSecretKey")           // 必须设置
    .tokenValiditySeconds(604800)         // 7天
    .userDetailsService(userDetailsService)  // 必须设置
    .rememberMeParameter("remember-me");  // 表单参数名

// 前端表单
<input type="checkbox" name="remember-me" /> 记住我
```


### 13.9 @PreAuthorize 不生效

```java
// 原因1：未启用方法级安全
@Configuration
@EnableGlobalMethodSecurity(prePostEnabled = true)  // 必须添加
public class SecurityConfig { }

// 原因2：同类方法调用
@Service
public class UserService {
    
    public void methodA() {
        methodB();  // 直接调用，不会触发 AOP
    }
    
    @PreAuthorize("hasRole('ADMIN')")
    public void methodB() { }
}

// 解决：注入自身或使用 AopContext
@Service
public class UserService {
    
    @Autowired
    private UserService self;  // 注入自身
    
    public void methodA() {
        self.methodB();  // 通过代理调用
    }
}

// 原因3：方法不是 public
// @PreAuthorize 只对 public 方法生效
```

### 13.10 并发登录控制问题

```java
// 限制同一用户只能在一处登录
http.sessionManagement()
    .maximumSessions(1)                    // 最大会话数
    .maxSessionsPreventsLogin(false)       // false: 踢掉旧会话; true: 阻止新登录
    .expiredSessionStrategy(event -> {
        HttpServletResponse response = event.getResponse();
        response.setContentType("application/json;charset=UTF-8");
        response.getWriter().write("{\"code\":401,\"message\":\"账号在其他地方登录\"}");
    });

// 注意：需要配置 HttpSessionEventPublisher
@Bean
public HttpSessionEventPublisher httpSessionEventPublisher() {
    return new HttpSessionEventPublisher();
}
```

---

## 14. 最佳实践总结

### 14.1 安全配置清单

```java
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class SecurityBestPracticeConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            // 1. HTTPS 强制（生产环境）
            .requiresChannel()
                .anyRequest().requiresSecure()
            .and()
            
            // 2. 安全响应头
            .headers()
                .contentSecurityPolicy("default-src 'self'")
                .and()
                .frameOptions().deny()
                .xssProtection().block(true)
            .and()
            
            // 3. CSRF 配置（根据项目类型）
            .csrf()
                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
            .and()
            
            // 4. 会话管理
            .sessionManagement()
                .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)
                .sessionFixation().migrateSession()
                .maximumSessions(1)
                .maxSessionsPreventsLogin(false)
            .and()
            
            // 5. 授权配置（从严到宽）
            .authorizeRequests()
                .antMatchers("/admin/**").hasRole("ADMIN")
                .antMatchers("/api/**").authenticated()
                .antMatchers("/public/**").permitAll()
                .anyRequest().authenticated()
            .and()
            
            // 6. 异常处理
            .exceptionHandling()
                .authenticationEntryPoint(authenticationEntryPoint())
                .accessDeniedHandler(accessDeniedHandler())
            .and()
            
            // 7. 登出配置
            .logout()
                .logoutUrl("/logout")
                .logoutSuccessHandler(logoutSuccessHandler())
                .invalidateHttpSession(true)
                .deleteCookies("JSESSIONID", "remember-me");

        return http.build();
    }

    // 使用强密码编码器
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder(12);  // 强度 12
    }
}
```

### 14.2 权限设计原则

```
1. 最小权限原则
   - 用户只拥有完成工作所需的最小权限
   - 默认拒绝，显式授权

2. 职责分离原则
   - 关键操作需要多人协作
   - 如：申请人不能审批自己的申请

3. 权限继承原则
   - 子角色继承父角色权限
   - 避免重复配置

4. 权限命名规范
   - 资源:操作 格式
   - 如：user:add, order:audit

5. 接口权限与数据权限分离
   - 接口权限：能否调用接口
   - 数据权限：能看到哪些数据
```

### 14.3 安全编码规范

```java
// 1. 永远不要在日志中打印敏感信息
// 错误
log.info("用户登录: username={}, password={}", username, password);
// 正确
log.info("用户登录: username={}", username);

// 2. 使用参数化查询，防止 SQL 注入
// 错误
String sql = "SELECT * FROM user WHERE username = '" + username + "'";
// 正确
@Select("SELECT * FROM user WHERE username = #{username}")
User findByUsername(String username);

// 3. 敏感数据加密存储
// 密码使用 BCrypt
String encodedPassword = passwordEncoder.encode(rawPassword);
// 手机号等使用 AES 加密
String encryptedPhone = AesUtils.encrypt(phone);

// 4. 接口返回脱敏
@JsonSerialize(using = PhoneDesensitizeSerializer.class)
private String phone;  // 返回 138****8888

// 5. 防止越权访问
@PreAuthorize("#userId == authentication.principal.id or hasRole('ADMIN')")
public User getUser(Long userId) { }

// 6. 限制登录失败次数
if (loginFailCount >= 5) {
    lockAccount(username, Duration.ofMinutes(30));
    throw new AccountLockedException("账号已锁定，请30分钟后重试");
}

// 7. 敏感操作二次验证
@PostMapping("/transfer")
public Result transfer(@RequestBody TransferDTO dto,
                       @RequestParam String verifyCode) {
    // 验证短信验证码
    if (!smsService.verify(dto.getPhone(), verifyCode)) {
        throw new VerifyException("验证码错误");
    }
    // 执行转账
}
```

### 14.4 权限系统架构建议

```
┌─────────────────────────────────────────────────────────────┐
│                        网关层                                │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │  限流控制   │  │  黑白名单   │  │  Token验证  │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                       认证服务                               │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │  用户认证   │  │  Token管理  │  │  OAuth2     │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                       权限服务                               │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │  RBAC管理   │  │  数据权限   │  │  权限缓存   │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                       业务服务                               │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │  方法级权限 │  │  数据过滤   │  │  审计日志   │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
└─────────────────────────────────────────────────────────────┘
```

### 14.5 常用配置参考

```yaml
# application.yml
spring:
  security:
    # 忽略静态资源
    ignored: /css/**,/js/**,/images/**,/favicon.ico

# JWT 配置
jwt:
  secret: your-256-bit-secret-key-here-must-be-long-enough
  expiration: 7200000        # 2小时
  refresh-expiration: 604800000  # 7天
  header: Authorization
  prefix: "Bearer "

# 登录安全配置
login:
  max-retry-count: 5         # 最大重试次数
  lock-time: 30              # 锁定时间（分钟）
  captcha-enabled: true      # 是否启用验证码
  captcha-type: math         # 验证码类型：math/char

# 密码策略
password:
  min-length: 8
  max-length: 20
  require-digit: true
  require-lowercase: true
  require-uppercase: true
  require-special: true
  history-count: 5           # 不能使用最近5次密码
  expire-days: 90            # 90天过期
```

---

## 参考资料

- [Spring Security 官方文档](https://docs.spring.io/spring-security/reference/)
- [JWT 官网](https://jwt.io/)
- [OAuth 2.0 规范](https://oauth.net/2/)
- [OWASP 安全指南](https://owasp.org/www-project-web-security-testing-guide/)
