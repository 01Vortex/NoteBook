

> 分布式事务是保证跨多个服务或数据库的数据一致性的关键技术
> 本笔记涵盖主流分布式事务解决方案，从理论到实战

---

## 目录

1. [基础概念](#1-基础概念)
2. [本地事务回顾](#2-本地事务回顾)
3. [分布式事务理论](#3-分布式事务理论)
4. [2PC 两阶段提交](#4-2pc-两阶段提交)
5. [3PC 三阶段提交](#5-3pc-三阶段提交)
6. [TCC 模式](#6-tcc-模式)
7. [Saga 模式](#7-saga-模式)
8. [本地消息表](#8-本地消息表)
9. [可靠消息最终一致性](#9-可靠消息最终一致性)
10. [最大努力通知](#10-最大努力通知)
11. [Seata 框架实战](#11-seata-框架实战)
12. [方案对比与选型](#12-方案对比与选型)
13. [生产环境最佳实践](#13-生产环境最佳实践)
14. [常见错误与解决方案](#14-常见错误与解决方案)

---

## 1. 基础概念

### 1.1 什么是分布式事务？

在单体应用中，一个事务只涉及一个数据库，通过数据库的 ACID 特性就能保证数据一致性。但在微服务架构中，一个业务操作可能涉及多个服务、多个数据库：

```
┌─────────────────────────────────────────────────────────────────┐
│                        电商下单场景                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   用户下单                                                       │
│      │                                                          │
│      ├──► 订单服务：创建订单          ──► 订单数据库             │
│      │                                                          │
│      ├──► 库存服务：扣减库存          ──► 库存数据库             │
│      │                                                          │
│      ├──► 账户服务：扣减余额          ──► 账户数据库             │
│      │                                                          │
│      └──► 积分服务：增加积分          ──► 积分数据库             │
│                                                                 │
│   问题：如何保证这 4 个操作要么全部成功，要么全部失败？           │
└─────────────────────────────────────────────────────────────────┘
```

**分布式事务**就是要解决这个问题：保证跨多个服务/数据库的操作具有原子性。

### 1.2 分布式事务的挑战

```
┌─────────────────────────────────────────────────────────────────┐
│                        挑战与困难                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 网络不可靠                                                   │
│     - 网络延迟、丢包、分区                                       │
│     - 无法确定远程操作是否成功                                   │
│                                                                 │
│  2. 服务不可靠                                                   │
│     - 服务可能宕机、重启                                         │
│     - 处理过程中可能失败                                         │
│                                                                 │
│  3. 没有全局时钟                                                 │
│     - 各节点时间不同步                                           │
│     - 无法确定事件的先后顺序                                     │
│                                                                 │
│  4. 性能要求                                                     │
│     - 不能长时间锁定资源                                         │
│     - 需要高并发支持                                             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 1.3 ACID vs BASE

**ACID（强一致性）**
- Atomicity（原子性）：全部成功或全部失败
- Consistency（一致性）：数据保持一致状态
- Isolation（隔离性）：事务之间互不干扰
- Durability（持久性）：提交后永久保存

**BASE（最终一致性）**
- Basically Available（基本可用）：允许部分失败
- Soft state（软状态）：允许中间状态
- Eventually consistent（最终一致性）：最终达到一致

```java
// ACID 示例：银行转账（强一致性）
@Transactional
public void transfer(Long fromId, Long toId, BigDecimal amount) {
    accountDao.deduct(fromId, amount);  // 扣款
    accountDao.add(toId, amount);       // 加款
    // 要么都成功，要么都失败，立即一致
}

// BASE 示例：电商下单（最终一致性）
public void createOrder(Order order) {
    orderDao.save(order);                    // 创建订单
    messageQueue.send("deduct-stock", order); // 异步扣库存
    // 订单创建成功，库存稍后扣减，最终一致
}
```

---

## 2. 本地事务回顾

### 2.1 Spring 事务管理

在深入分布式事务之前，先回顾本地事务的使用：

```java
/**
 * 本地事务示例
 */
@Service
public class OrderService {
    
    @Autowired
    private OrderMapper orderMapper;
    
    @Autowired
    private OrderItemMapper orderItemMapper;
    
    /**
     * 声明式事务：使用 @Transactional 注解
     */
    @Transactional(rollbackFor = Exception.class)
    public void createOrder(Order order, List<OrderItem> items) {
        // 1. 插入订单
        orderMapper.insert(order);
        
        // 2. 插入订单明细
        for (OrderItem item : items) {
            item.setOrderId(order.getId());
            orderItemMapper.insert(item);
        }
        
        // 如果任何步骤失败，整个事务回滚
    }
    
    /**
     * 编程式事务：使用 TransactionTemplate
     */
    @Autowired
    private TransactionTemplate transactionTemplate;
    
    public void createOrderProgrammatic(Order order, List<OrderItem> items) {
        transactionTemplate.execute(status -> {
            try {
                orderMapper.insert(order);
                for (OrderItem item : items) {
                    item.setOrderId(order.getId());
                    orderItemMapper.insert(item);
                }
                return true;
            } catch (Exception e) {
                status.setRollbackOnly();
                throw e;
            }
        });
    }
}
```

### 2.2 事务传播行为

```java
/**
 * 事务传播行为示例
 */
@Service
public class TransactionPropagationExample {
    
    /**
     * REQUIRED（默认）：如果当前有事务，加入；没有则新建
     */
    @Transactional(propagation = Propagation.REQUIRED)
    public void methodA() {
        // 业务逻辑
    }
    
    /**
     * REQUIRES_NEW：总是新建事务，挂起当前事务
     */
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void methodB() {
        // 独立事务，不受外部事务影响
    }
    
    /**
     * NESTED：嵌套事务，外部回滚会影响内部，内部回滚不影响外部
     */
    @Transactional(propagation = Propagation.NESTED)
    public void methodC() {
        // 嵌套事务
    }
    
    /**
     * 示例：组合使用
     */
    @Transactional
    public void parentMethod() {
        methodA();  // 加入当前事务
        methodB();  // 新建独立事务
        methodC();  // 嵌套事务
    }
}
```

### 2.3 本地事务的局限性

```java
/**
 * 本地事务无法解决的场景
 */
@Service
public class CrossServiceExample {
    
    @Autowired
    private OrderService orderService;
    
    @Autowired
    private StockServiceClient stockServiceClient;  // Feign 客户端
    
    @Autowired
    private AccountServiceClient accountServiceClient;
    
    /**
     * ❌ 错误示例：@Transactional 无法管理远程调用
     */
    @Transactional  // 这个注解只能管理本地数据库事务
    public void createOrder(OrderDTO dto) {
        // 1. 本地操作：创建订单（在事务中）
        Order order = new Order();
        orderService.save(order);
        
        // 2. 远程调用：扣减库存（不在事务中！）
        stockServiceClient.deduct(dto.getProductId(), dto.getQuantity());
        
        // 3. 远程调用：扣减余额（不在事务中！）
        accountServiceClient.deduct(dto.getUserId(), dto.getAmount());
        
        // 问题：如果步骤3失败，步骤1会回滚，但步骤2已经执行无法回滚！
    }
}
```

**本地事务的局限：**
- 只能管理单个数据源
- 无法跨服务协调
- 无法处理远程调用失败

这就是为什么需要分布式事务！

---

## 3. 分布式事务理论

### 3.1 CAP 定理

CAP 定理指出，分布式系统最多只能同时满足以下三项中的两项：

```
┌─────────────────────────────────────────────────────────────────┐
│                          CAP 定理                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   C (Consistency)          一致性                                │
│   所有节点在同一时间看到相同的数据                                │
│                                                                 │
│   A (Availability)         可用性                                │
│   每个请求都能得到响应（成功或失败）                              │
│                                                                 │
│   P (Partition Tolerance)  分区容错性                            │
│   系统在网络分区时仍能继续工作                                    │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   组合选择：                                                     │
│                                                                 │
│   CP：牺牲可用性，保证一致性（如：Zookeeper、HBase）             │
│   AP：牺牲一致性，保证可用性（如：Cassandra、DynamoDB）          │
│   CA：不存在（网络分区无法避免）                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

```java
/**
 * CAP 权衡示例
 */
public class CAPExample {
    
    /**
     * CP 模式：强一致性，可能不可用
     */
    public Order getOrderCP(Long orderId) {
        // 从主库读取，保证一致性
        // 如果主库不可用，请求失败（牺牲可用性）
        return masterDB.queryOrder(orderId);
    }
    
    /**
     * AP 模式：高可用，可能不一致
     */
    public Order getOrderAP(Long orderId) {
        // 从任意可用节点读取
        // 可能读到旧数据（牺牲一致性）
        return anyAvailableDB.queryOrder(orderId);
    }
}
```

### 3.2 BASE 理论

BASE 是对 CAP 中 AP 的延伸，通过牺牲强一致性来获得可用性：

```java
/**
 * BASE 理论实践
 */
@Service
public class BASEExample {
    
    @Autowired
    private OrderService orderService;
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    /**
     * 基本可用 + 软状态 + 最终一致性
     */
    public OrderResult createOrder(OrderDTO dto) {
        // 1. 创建订单（基本可用）
        Order order = orderService.create(dto);
        order.setStatus("PENDING");  // 软状态：待处理
        
        // 2. 发送消息异步处理
        rabbitTemplate.convertAndSend("order.created", order);
        
        // 3. 立即返回，不等待后续处理
        return OrderResult.success(order.getId());
        
        // 后续：消息消费者会处理库存、支付等
        // 最终：订单状态会变为 SUCCESS 或 FAILED（最终一致性）
    }
}
```

### 3.3 分布式事务的分类

```
┌─────────────────────────────────────────────────────────────────┐
│                    分布式事务解决方案分类                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  刚性事务（强一致性）                                            │
│  ├─ 2PC（两阶段提交）                                           │
│  ├─ 3PC（三阶段提交）                                           │
│  └─ XA 协议                                                     │
│                                                                 │
│  柔性事务（最终一致性）                                          │
│  ├─ TCC（Try-Confirm-Cancel）                                  │
│  ├─ Saga 模式                                                   │
│  ├─ 本地消息表                                                   │
│  ├─ 可靠消息最终一致性                                           │
│  └─ 最大努力通知                                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 4. 2PC 两阶段提交

### 4.1 原理说明

2PC 是最经典的分布式事务解决方案，分为准备阶段和提交阶段：

```
┌─────────────────────────────────────────────────────────────────┐
│                      2PC 执行流程                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  协调者 (Coordinator)                                            │
│     │                                                           │
│     │  阶段一：准备阶段 (Prepare)                                │
│     ├──────► 参与者A: 能否提交？                                │
│     ├──────► 参与者B: 能否提交？                                │
│     ├──────► 参与者C: 能否提交？                                │
│     │                                                           │
│     │  ◄────── YES                                              │
│     │  ◄────── YES                                              │
│     │  ◄────── YES                                              │
│     │                                                           │
│     │  阶段二：提交阶段 (Commit)                                 │
│     ├──────► 参与者A: 提交！                                    │
│     ├──────► 参与者B: 提交！                                    │
│     ├──────► 参与者C: 提交！                                    │
│     │                                                           │
│     │  ◄────── ACK                                              │
│     │  ◄────── ACK                                              │
│     │  ◄────── ACK                                              │
│     │                                                           │
│     └──► 事务完成                                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.2 Java 实现（XA 协议）

```java
/**
 * 2PC 实现：使用 Atomikos 实现 XA 事务
 */

// 1. Maven 依赖
/*
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jta-atomikos</artifactId>
</dependency>
*/

// 2. 配置多数据源
@Configuration
public class XADataSourceConfig {
    
    /**
     * 配置第一个 XA 数据源（订单库）
     */
    @Bean("orderDataSource")
    public DataSource orderDataSource() {
        MysqlXADataSource xaDataSource = new MysqlXADataSource();
        xaDataSource.setUrl("jdbc:mysql://localhost:3306/order_db");
        xaDataSource.setUser("root");
        xaDataSource.setPassword("password");
        
        AtomikosDataSourceBean atomikosDataSource = new AtomikosDataSourceBean();
        atomikosDataSource.setXaDataSource(xaDataSource);
        atomikosDataSource.setUniqueResourceName("orderDS");
        atomikosDataSource.setMinPoolSize(5);
        atomikosDataSource.setMaxPoolSize(20);
        
        return atomikosDataSource;
    }
    
    /**
     * 配置第二个 XA 数据源（库存库）
     */
    @Bean("stockDataSource")
    public DataSource stockDataSource() {
        MysqlXADataSource xaDataSource = new MysqlXADataSource();
        xaDataSource.setUrl("jdbc:mysql://localhost:3306/stock_db");
        xaDataSource.setUser("root");
        xaDataSource.setPassword("password");
        
        AtomikosDataSourceBean atomikosDataSource = new AtomikosDataSourceBean();
        atomikosDataSource.setXaDataSource(xaDataSource);
        atomikosDataSource.setUniqueResourceName("stockDS");
        atomikosDataSource.setMinPoolSize(5);
        atomikosDataSource.setMaxPoolSize(20);
        
        return atomikosDataSource;
    }
    
    /**
     * 配置 JTA 事务管理器
     */
    @Bean
    public JtaTransactionManager transactionManager() {
        UserTransactionManager userTransactionManager = new UserTransactionManager();
        UserTransaction userTransaction = new UserTransactionImp();
        return new JtaTransactionManager(userTransaction, userTransactionManager);
    }
}

/**
 * 使用 XA 事务
 */
@Service
public class OrderServiceXA {
    
    @Autowired
    @Qualifier("orderDataSource")
    private DataSource orderDataSource;
    
    @Autowired
    @Qualifier("stockDataSource")
    private DataSource stockDataSource;
    
    /**
     * 跨数据库事务
     */
    @Transactional  // 使用 JTA 事务管理器
    public void createOrder(OrderDTO dto) throws SQLException {
        // 1. 操作订单库
        try (Connection orderConn = orderDataSource.getConnection();
             PreparedStatement ps = orderConn.prepareStatement(
                 "INSERT INTO orders (user_id, amount) VALUES (?, ?)")) {
            ps.setLong(1, dto.getUserId());
            ps.setBigDecimal(2, dto.getAmount());
            ps.executeUpdate();
        }
        
        // 2. 操作库存库
        try (Connection stockConn = stockDataSource.getConnection();
             PreparedStatement ps = stockConn.prepareStatement(
                 "UPDATE stock SET quantity = quantity - ? WHERE product_id = ?")) {
            ps.setInt(1, dto.getQuantity());
            ps.setLong(2, dto.getProductId());
            int rows = ps.executeUpdate();
            
            if (rows == 0) {
                throw new RuntimeException("库存不足");
            }
        }
        
        // 如果任何操作失败，两个数据库都会回滚
    }
}
```

### 4.3 2PC 的优缺点

**优点：**
- 强一致性，符合 ACID
- 实现相对简单
- 数据库原生支持（XA 协议）

**缺点：**
